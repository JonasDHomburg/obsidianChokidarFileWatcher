/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var scan = require_scan();
    var parse = require_parse();
    var utils = require_utils();
    var constants = require_constants();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/readdirp/index.js
var require_readdirp = __commonJS({
  "node_modules/readdirp/index.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var { Readable } = require("stream");
    var sysPath = require("path");
    var { promisify } = require("util");
    var picomatch = require_picomatch2();
    var readdir = promisify(fs.readdir);
    var stat = promisify(fs.stat);
    var lstat = promisify(fs.lstat);
    var realpath = promisify(fs.realpath);
    var BANG = "!";
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
    var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n) => Number.parseInt(n, 10));
    var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    var normalizeFilter = (filter) => {
      if (filter === void 0)
        return;
      if (typeof filter === "function")
        return filter;
      if (typeof filter === "string") {
        const glob = picomatch(filter.trim());
        return (entry) => glob(entry.basename);
      }
      if (Array.isArray(filter)) {
        const positive = [];
        const negative = [];
        for (const item of filter) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG) {
            negative.push(picomatch(trimmed.slice(1)));
          } else {
            positive.push(picomatch(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry) => positive.some((f) => f(entry.basename)) && !negative.some((f) => f(entry.basename));
          }
          return (entry) => !negative.some((f) => f(entry.basename));
        }
        return (entry) => positive.some((f) => f(entry.basename));
      }
    };
    var ReaddirpStream = class extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          /* eslint-disable no-unused-vars */
          fileFilter: (path) => true,
          directoryFilter: (path) => true,
          /* eslint-enable no-unused-vars */
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options.highWaterMark || 4096
        });
        const opts = { ...ReaddirpStream.defaultOptions, ...options };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat : stat;
        if (wantBigintFsStats) {
          this._stat = (path) => statMethod(path, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath.resolve(root);
        this._isDirent = "Dirent" in fs && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path, depth, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path));
              for (const entry of await Promise.all(slice)) {
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry);
                if (entryType === "directory" && this._directoryFilter(entry)) {
                  if (depth <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                  if (this._wantsFile) {
                    this.push(entry);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error) {
          this.destroy(error);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path, depth) {
        let files;
        try {
          files = await readdir(path, this._rdOptions);
        } catch (error) {
          this._onError(error);
        }
        return { files, depth, path };
      }
      async _formatEntry(dirent, path) {
        let entry;
        try {
          const basename = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath.resolve(sysPath.join(path, basename));
          entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };
          entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry) {
        const stats = entry && entry[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry.fullPath;
          try {
            const entryRealPath = await realpath(full);
            const entryRealPathStats = await lstat(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                const recursiveError = new Error(
                  `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                );
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error) {
            this._onError(error);
          }
        }
      }
      _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    var readdirp = (root, options = {}) => {
      let type = options.entryType || options.type;
      if (type === "both")
        type = FILE_DIR_TYPE;
      if (type)
        options.type = type;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options.root = root;
      return new ReaddirpStream(options);
    };
    var readdirpPromise = (root, options = {}) => {
      return new Promise((resolve, reject) => {
        const files = [];
        readdirp(root, options).on("data", (entry) => files.push(entry)).on("end", () => resolve(files)).on("error", (error) => reject(error));
      });
    };
    readdirp.promise = readdirpPromise;
    readdirp.ReaddirpStream = ReaddirpStream;
    readdirp.default = readdirp;
    module2.exports = readdirp;
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/normalize-path/index.js"(exports, module2) {
    module2.exports = function(path, stripTrailing) {
      if (typeof path !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path === "\\" || path === "/")
        return "/";
      var len = path.length;
      if (len <= 1)
        return path;
      var prefix = "";
      if (len > 4 && path[3] === "\\") {
        var ch = path[2];
        if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\") {
          path = path.slice(2);
          prefix = "//";
        }
      }
      var segs = path.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/anymatch/index.js
var require_anymatch = __commonJS({
  "node_modules/anymatch/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var picomatch = require_picomatch2();
    var normalizePath = require_normalize_path();
    var BANG = "!";
    var DEFAULT_OPTIONS = { returnIndex: false };
    var arrify = (item) => Array.isArray(item) ? item : [item];
    var createPattern = (matcher, options) => {
      if (typeof matcher === "function") {
        return matcher;
      }
      if (typeof matcher === "string") {
        const glob = picomatch(matcher, options);
        return (string) => matcher === string || glob(string);
      }
      if (matcher instanceof RegExp) {
        return (string) => matcher.test(string);
      }
      return (string) => false;
    };
    var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path = normalizePath(_path, false);
      for (let index = 0; index < negPatterns.length; index++) {
        const nglob = negPatterns[index];
        if (nglob(path)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path].concat(args.slice(1));
      for (let index = 0; index < patterns.length; index++) {
        const pattern = patterns[index];
        if (isList ? pattern(...applied) : pattern(path)) {
          return returnIndex ? index : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    var anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options === "boolean" ? { returnIndex: options } : options;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
      const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
    anymatch.default = anymatch;
    module2.exports = anymatch;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/chokidar/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/chokidar/node_modules/glob-parent/index.js"(exports, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils2();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils2();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS({
  "node_modules/binary-extensions/binary-extensions.json"(exports, module2) {
    module2.exports = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "afdesign",
      "afphoto",
      "afpub",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
  }
});

// node_modules/binary-extensions/index.js
var require_binary_extensions2 = __commonJS({
  "node_modules/binary-extensions/index.js"(exports, module2) {
    module2.exports = require_binary_extensions();
  }
});

// node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS({
  "node_modules/is-binary-path/index.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var binaryExtensions = require_binary_extensions2();
    var extensions = new Set(binaryExtensions);
    module2.exports = (filePath) => extensions.has(path.extname(filePath).slice(1).toLowerCase());
  }
});

// node_modules/chokidar/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/chokidar/lib/constants.js"(exports) {
    "use strict";
    var { sep } = require("path");
    var { platform } = process;
    var os = require("os");
    exports.EV_ALL = "all";
    exports.EV_READY = "ready";
    exports.EV_ADD = "add";
    exports.EV_CHANGE = "change";
    exports.EV_ADD_DIR = "addDir";
    exports.EV_UNLINK = "unlink";
    exports.EV_UNLINK_DIR = "unlinkDir";
    exports.EV_RAW = "raw";
    exports.EV_ERROR = "error";
    exports.STR_DATA = "data";
    exports.STR_END = "end";
    exports.STR_CLOSE = "close";
    exports.FSEVENT_CREATED = "created";
    exports.FSEVENT_MODIFIED = "modified";
    exports.FSEVENT_DELETED = "deleted";
    exports.FSEVENT_MOVED = "moved";
    exports.FSEVENT_CLONED = "cloned";
    exports.FSEVENT_UNKNOWN = "unknown";
    exports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
    exports.FSEVENT_TYPE_FILE = "file";
    exports.FSEVENT_TYPE_DIRECTORY = "directory";
    exports.FSEVENT_TYPE_SYMLINK = "symlink";
    exports.KEY_LISTENERS = "listeners";
    exports.KEY_ERR = "errHandlers";
    exports.KEY_RAW = "rawEmitters";
    exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
    exports.DOT_SLASH = `.${sep}`;
    exports.BACK_SLASH_RE = /\\/g;
    exports.DOUBLE_SLASH_RE = /\/\//;
    exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
    exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    exports.REPLACER_RE = /^\.[/\\]/;
    exports.SLASH = "/";
    exports.SLASH_SLASH = "//";
    exports.BRACE_START = "{";
    exports.BANG = "!";
    exports.ONE_DOT = ".";
    exports.TWO_DOTS = "..";
    exports.STAR = "*";
    exports.GLOBSTAR = "**";
    exports.ROOT_GLOBSTAR = "/**/*";
    exports.SLASH_GLOBSTAR = "/**";
    exports.DIR_SUFFIX = "Dir";
    exports.ANYMATCH_OPTS = { dot: true };
    exports.STRING_TYPE = "string";
    exports.FUNCTION_TYPE = "function";
    exports.EMPTY_STR = "";
    exports.EMPTY_FN = () => {
    };
    exports.IDENTITY_FN = (val) => val;
    exports.isWindows = platform === "win32";
    exports.isMacos = platform === "darwin";
    exports.isLinux = platform === "linux";
    exports.isIBMi = os.type() === "OS400";
  }
});

// node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = __commonJS({
  "node_modules/chokidar/lib/nodefs-handler.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var sysPath = require("path");
    var { promisify } = require("util");
    var isBinaryPath = require_is_binary_path();
    var {
      isWindows,
      isLinux,
      EMPTY_FN,
      EMPTY_STR,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE,
      EV_ADD,
      EV_ADD_DIR,
      EV_ERROR,
      STR_DATA,
      STR_END,
      BRACE_START,
      STAR
    } = require_constants3();
    var THROTTLE_MODE_WATCH = "watch";
    var open = promisify(fs.open);
    var stat = promisify(fs.stat);
    var lstat = promisify(fs.lstat);
    var close = promisify(fs.close);
    var fsrealpath = promisify(fs.realpath);
    var statMethods = { lstat, stat };
    var foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    var addAndConvert = (main, prop, item) => {
      let container = main[prop];
      if (!(container instanceof Set)) {
        main[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key) => {
      const set = cont[key];
      if (set instanceof Set) {
        set.clear();
      } else {
        delete cont[key];
      }
    };
    var delFromSet = (main, prop, item) => {
      const container = main[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = /* @__PURE__ */ new Map();
    function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener(path);
        emitRaw(rawEvent, evPath, { watchedPath: path });
        if (evPath && path !== evPath) {
          fsWatchBroadcast(
            sysPath.resolve(path, evPath),
            KEY_LISTENERS,
            sysPath.join(path, evPath)
          );
        }
      };
      try {
        return fs.watch(path, options, handleEvent);
      } catch (error) {
        errHandler(error);
      }
    }
    var fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[type], (listener) => {
        listener(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path, fullPath, options, handlers) => {
      const { listener, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options.persistent) {
        watcher = createFsWatchInstance(
          path,
          options,
          listener,
          errHandler,
          rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(
          path,
          options,
          fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
          errHandler,
          // no need to use broadcast here
          fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
        );
        if (!watcher)
          return;
        watcher.on(EV_ERROR, async (error) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows && error.code === "EPERM") {
            try {
              const fd = await open(path, "r");
              await close(fd);
              broadcastErr(error);
            } catch (err) {
            }
          } else {
            broadcastErr(error);
          }
        });
        cont = {
          listeners: listener,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = /* @__PURE__ */ new Map();
    var setFsWatchFileListener = (path, fullPath, options, handlers) => {
      const { listener, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      let listeners = /* @__PURE__ */ new Set();
      let rawEmitters = /* @__PURE__ */ new Set();
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
        listeners = cont.listeners;
        rawEmitters = cont.rawEmitters;
        fs.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener,
          rawEmitters: rawEmitter,
          options,
          watcher: fs.watchFile(fullPath, options, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener2) => listener2(path, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler = class {
      /**
       * @param {import("../index").FSWatcher} fsW
       */
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
      }
      /**
       * Watch file for changes with fs_watchFile or fs_watch.
       * @param {String} path to file or dir
       * @param {Function} listener on fs change
       * @returns {Function} closer for the watcher instance
       */
      _watchWithNodeFs(path, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path);
        const basename = sysPath.basename(path);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename);
        const absolutePath = sysPath.resolve(path);
        const options = { persistent: opts.persistent };
        if (!listener)
          listener = EMPTY_FN;
        let closer;
        if (opts.usePolling) {
          options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path, absolutePath, options, {
            listener,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path, absolutePath, options, {
            listener,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname = sysPath.dirname(file);
        const basename = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname);
        let prevStats = stats;
        if (parent.has(basename))
          return;
        const listener = async (path, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat(file);
              if (this.fsw.closed)
                return;
              const at = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path);
                prevStats = newStats2;
                this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));
              } else {
                prevStats = newStats2;
              }
            } catch (error) {
              this.fsw._remove(dirname, basename);
            }
          } else if (parent.has(basename)) {
            const at = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at || at <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD, file, 0))
            return;
          this.fsw._emit(EV_ADD, file, stats);
        }
        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */
      async _handleSymlink(entry, directory, path, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path);
          } catch (e) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE, path, entry.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD, path, entry.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        directory = sysPath.join(directory, EMPTY_STR);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = /* @__PURE__ */ new Set();
        let stream = this.fsw._readdirp(directory, {
          fileFilter: (entry) => wh.filterPath(entry),
          directoryFilter: (entry) => wh.filterDir(entry),
          depth: 0
        }).on(STR_DATA, async (entry) => {
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          const item = entry.path;
          let path = sysPath.join(directory, item);
          current.add(item);
          if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path = sysPath.join(dir, sysPath.relative(dir, path));
            this._addToNodeFs(path, initialAdd, wh, depth + 1);
          }
        }).on(EV_ERROR, this._boundHandleError);
        return new Promise(
          (resolve) => stream.once(STR_END, () => {
            if (this.fsw.closed) {
              stream = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve();
            previous.getChildren().filter((item) => {
              return item !== directory && !current.has(item) && // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath.resolve(directory, item)
              }));
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream = void 0;
            if (wasThrottled)
              this._handleRead(directory, false, wh, target, dir, depth, throttler);
          })
        );
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */
      async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir))
            this.fsw._emit(EV_ADD_DIR, dir, stats);
        }
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
          });
        }
        return closer;
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */
      async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path, depth);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry) => priorWh.filterPath(entry);
          wh.filterDir = (entry) => priorWh.filterDir(entry);
        }
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath.resolve(path);
            const targetPath = follow ? await fsrealpath(path) : path;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path) : path;
            if (this.fsw.closed)
              return;
            const parent = sysPath.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path, closer);
          return false;
        } catch (error) {
          if (this.fsw._handleError(error)) {
            ready();
            return path;
          }
        }
      }
    };
    module2.exports = NodeFsHandler;
  }
});

// node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = __commonJS({
  "node_modules/chokidar/lib/fsevents-handler.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var sysPath = require("path");
    var { promisify } = require("util");
    var fsevents;
    try {
      fsevents = require("fsevents");
    } catch (error) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj = Number.parseInt(mtch[1], 10);
        const min = Number.parseInt(mtch[2], 10);
        if (maj === 8 && min < 16) {
          fsevents = void 0;
        }
      }
    }
    var {
      EV_ADD,
      EV_CHANGE,
      EV_ADD_DIR,
      EV_UNLINK,
      EV_ERROR,
      STR_DATA,
      STR_END,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      // FSEVENT_CLONED,
      FSEVENT_UNKNOWN,
      FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE,
      EMPTY_FN,
      IDENTITY_FN
    } = require_constants3();
    var Depth = (value) => isNaN(value) ? {} : { depth: value };
    var stat = promisify(fs.stat);
    var lstat = promisify(fs.lstat);
    var realpath = promisify(fs.realpath);
    var statMethods = { stat, lstat };
    var FSEventsWatchers = /* @__PURE__ */ new Map();
    var consolidateThreshhold = 10;
    var wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    var createFSEventsInstance = (path, callback) => {
      const stop = fsevents.watch(path, callback);
      return { stop };
    };
    function setFSEventsListener(path, realPath, listener, rawEmitter) {
      let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
      const parentPath = sysPath.dirname(watchPath);
      let cont = FSEventsWatchers.get(watchPath);
      if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
      }
      const resolvedPath = sysPath.resolve(path);
      const hasSymlink = resolvedPath !== realPath;
      const filteredListener = (fullPath, flags, info) => {
        if (hasSymlink)
          fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
          listener(fullPath, flags, info);
      };
      let watchedParent = false;
      for (const watchedPath of FSEventsWatchers.keys()) {
        if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers.get(watchPath);
          watchedParent = true;
          break;
        }
      }
      if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
      } else {
        cont = {
          listeners: /* @__PURE__ */ new Set([filteredListener]),
          rawEmitter,
          watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
            if (!cont.listeners.size)
              return;
            if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS)
              return;
            const info = fsevents.getInfo(fullPath, flags);
            cont.listeners.forEach((list) => {
              list(fullPath, flags, info);
            });
            cont.rawEmitter(info.event, fullPath, info);
          })
        };
        FSEventsWatchers.set(watchPath, cont);
      }
      return () => {
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
          FSEventsWatchers.delete(watchPath);
          if (cont.watcher)
            return cont.watcher.stop().then(() => {
              cont.rawEmitter = cont.watcher = void 0;
              Object.freeze(cont);
            });
        }
      };
    }
    var couldConsolidate = (path) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    var canUse = () => fsevents && FSEventsWatchers.size < 128;
    var calcDepth = (path, root) => {
      let i = 0;
      while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root)
        i++;
      return i;
    };
    var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    var FsEventsHandler = class {
      /**
       * @param {import('../index').FSWatcher} fsw
       */
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path, stats)) {
          ipaths.add(path);
          if (stats && stats.isDirectory()) {
            ipaths.add(path + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path);
        ipaths.delete(path + ROOT_GLOBSTAR);
      }
      addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
        this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat(path);
          if (this.fsw.closed)
            return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error) {
          if (error.code === "EACCES") {
            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path))
          return;
        if (event === EV_UNLINK) {
          const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory);
          }
        } else {
          if (event === EV_ADD) {
            if (info.type === FSEVENT_TYPE_DIRECTORY)
              this.fsw._getWatchedDir(path);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path);
          if (eventName === EV_ADD_DIR)
            this._addToFsEvents(path, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */
      _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath))
          return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed)
            return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
            return;
          const path = transform(sysPath.join(
            watchPath,
            sysPath.relative(watchPath, fullPath)
          ));
          if (globFilter && !globFilter(path))
            return;
          const parent = sysPath.dirname(path);
          const item = sysPath.basename(path);
          const watchedDir = this.fsw._getWatchedDir(
            info.type === FSEVENT_TYPE_DIRECTORY ? path : parent
          );
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE) {
              let stats;
              try {
                stats = await stat(path);
              } catch (error) {
              }
              if (this.fsw.closed)
                return;
              if (this.checkIgnored(path, stats))
                return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(
          watchPath,
          realPath,
          watchCallback,
          this.fsw._emitRaw
        );
        this.fsw._emitReady();
        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */
      async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
          return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath(linkPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path.replace(linkTarget, linkPath);
            } else if (path !== DOT_SLASH) {
              aliasedPath = sysPath.join(linkPath, path);
            }
            return transform(aliasedPath);
          }, false, curDepth);
        } catch (error) {
          if (this.fsw._handleError(error)) {
            return this.fsw._emitReady();
          }
        }
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
        const base = sysPath.basename(pp);
        if (isDir)
          this.fsw._getWatchedDir(pp);
        if (dirObj.has(base))
          return;
        dirObj.add(base);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
        }
      }
      initWatch(realPath, path, wh, processPath) {
        if (this.fsw.closed)
          return;
        const closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        this.fsw._addPathCloser(path, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */
      async _addToFsEvents(path, transform, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path);
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter)
              this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth)
              return;
            this.fsw._readdirp(wh.watchPath, {
              fileFilter: (entry) => wh.filterPath(entry),
              directoryFilter: (entry) => wh.filterDir(entry),
              ...Depth(opts.depth - (priorDepth || 0))
            }).on(STR_DATA, (entry) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry.stats.isDirectory() && !wh.filterPath(entry))
                return;
              const joinedPath = sysPath.join(wh.watchPath, entry.path);
              const { fullPath } = entry;
              if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error) {
          if (!error || this.fsw._handleError(error)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform === FUNCTION_TYPE) {
            this.initWatch(void 0, path, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath(wh.watchPath);
            } catch (e) {
            }
            this.initWatch(realPath, path, wh, processPath);
          }
        }
      }
    };
    module2.exports = FsEventsHandler;
    module2.exports.canUse = canUse;
  }
});

// node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "node_modules/chokidar/index.js"(exports) {
    "use strict";
    var { EventEmitter } = require("events");
    var fs = require("fs");
    var sysPath = require("path");
    var { promisify } = require("util");
    var readdirp = require_readdirp();
    var anymatch = require_anymatch().default;
    var globParent = require_glob_parent();
    var isGlob = require_is_glob();
    var braces = require_braces();
    var normalizePath = require_normalize_path();
    var NodeFsHandler = require_nodefs_handler();
    var FsEventsHandler = require_fsevents_handler();
    var {
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows,
      isMacos,
      isIBMi
    } = require_constants3();
    var stat = promisify(fs.stat);
    var readdir = promisify(fs.readdir);
    var arrify = (value = []) => Array.isArray(value) ? value : [value];
    var flatten = (list, result = []) => {
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    var unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p) => typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string) => {
      let str = string.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    var normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));
    var normalizeIgnored = (cwd = EMPTY_STR) => (path) => {
      if (typeof path !== STRING_TYPE)
        return path;
      return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
    };
    var getAbsolutePath = (path, cwd) => {
      if (sysPath.isAbsolute(path)) {
        return path;
      }
      if (path.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path.slice(1));
      }
      return sysPath.join(cwd, path);
    };
    var undef = (opts, key) => opts[key] === void 0;
    var DirEntry = class {
      /**
       * @param {Path} dir
       * @param {Function} removeWatcher
       */
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await readdir(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */
      getChildren() {
        const { items } = this;
        if (!items)
          return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path;
        if (path === EMPTY_STR)
          this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry.fullPath;
      }
      entryPath(entry) {
        return sysPath.join(
          this.watchPath,
          sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
        );
      }
      filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path) {
        if (!this.hasGlob)
          return [];
        const parts = [];
        const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
        expandedPath.forEach((path2) => {
          parts.push(sysPath.relative(this.watchPath, path2).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i) => {
              if (part === GLOBSTAR)
                globstar = true;
              return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
      }
    };
    var FSWatcher = class extends EventEmitter {
      // Not indenting methods for history sake; for now.
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts)
          Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent"))
          opts.persistent = true;
        if (undef(opts, "ignoreInitial"))
          opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors"))
          opts.ignorePermissionErrors = false;
        if (undef(opts, "interval"))
          opts.interval = 100;
        if (undef(opts, "binaryInterval"))
          opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing"))
          opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents"))
          opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler.canUse();
        if (!canUseFsEvents)
          opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic"))
          opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic)
          this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks"))
          opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish"))
          opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true)
          opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold)
            awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval)
            awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored)
          opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler(this);
        }
        Object.freeze(opts);
      }
      // Public methods
      /**
       * Adds paths to be watched on an existing FSWatcher instance
       * @param {Path|Array<Path>} paths_
       * @param {String=} _origAdd private; for handling non-existent paths to be watched
       * @param {Boolean=} _internal private; indicates a non-user add
       * @returns {FSWatcher} for chaining
       */
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path) => {
            const absPath = getAbsolutePath(path, cwd);
            if (disableGlobbing || !isGlob(path)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path) => {
          if (path.startsWith(BANG)) {
            this._ignoredPaths.add(path.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path);
          this._ignoredPaths.delete(path + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount)
            this._readyCount = paths.length;
          if (this.options.persistent)
            this._readyCount += paths.length;
          paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));
        } else {
          if (!this._readyCount)
            this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(
            paths.map(async (path) => {
              const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
              if (res)
                this._emitReady();
              return res;
            })
          ).then((results) => {
            if (this.closed)
              return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path) => {
          if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
            if (cwd)
              path = sysPath.join(cwd, path);
            path = sysPath.resolve(path);
          }
          this._closePath(path);
          this._ignoredPaths.add(path);
          if (this._watched.has(path)) {
            this._ignoredPaths.add(path + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */
      close() {
        if (this.closed)
          return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise = closer();
          if (promise instanceof Promise)
            closers.push(promise);
        }));
        this._streams.forEach((stream) => stream.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR)
          this.emit(EV_ALL, ...args);
      }
      // Common helpers
      // --------------
      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      async _emit(event, path, val1, val2, val3) {
        if (this.closed)
          return;
        const opts = this.options;
        if (isWindows)
          path = sysPath.normalize(path);
        if (opts.cwd)
          path = sysPath.relative(opts.cwd, path);
        const args = [event, path];
        if (val3 !== void 0)
          args.push(val1, val2, val3);
        else if (val2 !== void 0)
          args.push(val1, val2);
        else if (val1 !== void 0)
          args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path))) {
          pw.lastChange = new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry, path2) => {
                this.emit(...entry);
                this.emit(EV_ALL, ...entry);
                this._pendingUnlinks.delete(path2);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
          let stats;
          try {
            stats = await stat(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed)
            return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      _handleError(error) {
        const code = error && error.code;
        if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error);
        }
        return error || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */
      _throttle(actionType, path, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path);
          const count = item ? item.count : 0;
          action.delete(path);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */
      _awaitWriteFinish(path, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path;
        if (this.options.cwd && !sysPath.isAbsolute(path)) {
          fullPath = sysPath.join(this.options.cwd, path);
        }
        const now = new Date();
        const awaitWriteFinish = (prevStat) => {
          fs.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(
                awaitWriteFinish,
                this.options.awaitWriteFinish.pollInterval,
                curStat
              );
            }
          });
        };
        if (!this._pendingWrites.has(path)) {
          this._pendingWrites.set(path, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval
          );
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */
      _isIgnored(path, stats) {
        if (this.options.atomic && DOT_RE.test(path))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path2) => typeof path2 === STRING_TYPE && !isGlob(path2)).map((path2) => path2 + SLASH_GLOBSTAR);
          const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path, stats]);
      }
      _isntIgnored(path, stat2) {
        return !this._isIgnored(path, stat2);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */
      _getWatchHelpers(path, depth) {
        const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path, watchPath, follow, this);
      }
      // Directory helpers
      // -----------------
      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */
      _getWatchedDir(directory) {
        if (!this._boundRemove)
          this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      // File helpers
      // ------------
      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */
      _remove(directory, item, isDirectory) {
        const path = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);
        if (!this._throttle("remove", path, 100))
          return;
        if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD)
            return;
        }
        this._watched.delete(path);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path))
          this._emit(eventName, path);
        if (!this.options.useFsEvents) {
          this._closePath(path);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */
      _closePath(path) {
        this._closeFile(path);
        const dir = sysPath.dirname(path);
        this._getWatchedDir(dir).remove(sysPath.basename(path));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */
      _closeFile(path) {
        const closers = this._closers.get(path);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */
      _addPathCloser(path, closer) {
        if (!closer)
          return;
        let list = this._closers.get(path);
        if (!list) {
          list = [];
          this._closers.set(path, list);
        }
        list.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed)
          return;
        const options = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
        let stream = readdirp(root, options);
        this._streams.add(stream);
        stream.once(STR_CLOSE, () => {
          stream = void 0;
        });
        stream.once(STR_END, () => {
          if (stream) {
            this._streams.delete(stream);
            stream = void 0;
          }
        });
        return stream;
      }
    };
    exports.FSWatcher = FSWatcher;
    var watch2 = (paths, options) => {
      const watcher = new FSWatcher(options);
      watcher.add(paths);
      return watcher;
    };
    exports.watch = watch2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FileWatcherPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var chokidar = __toESM(require_chokidar());
var DEFAULT_SETTINGS = {
  followSymlinks: true,
  disableGlobbing: false,
  usePolling: true,
  interval: 100,
  binaryInterval: 300,
  awaitWriteFinish: true,
  awaitWriteFinish_stabilityThreshold: 2e3,
  awaitWriteFinish_pollInterval: 100
};
var FileWatcherPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.root_path = this.app.vault.adapter.basePath;
    this.last_modified = /* @__PURE__ */ new Map();
  }
  async onload() {
    console.log("Loading file watcher plugin");
    await this.loadSettings();
    this.addSettingTab(new FileWatcherSettingTab(this.app, this));
    this.watcher = this.create_watcher();
    this.register(() => {
      this.watcher.close().then(() => console.log("Watcher closed"));
    });
    console.log("file watcher plugin loaded!");
  }
  create_watcher() {
    const watcher = chokidar.watch(this.root_path, {
      ignored: /(^|[\/\\])\../,
      // ignore dotfiles
      persistent: true,
      ignoreInitial: true,
      // usePolling: true,
      // awaitWriteFinish: true,
      cwd: this.root_path,
      // config
      followSymlinks: this.settings.followSymlinks,
      disableGlobbing: this.settings.disableGlobbing,
      usePolling: this.settings.usePolling,
      interval: this.settings.interval,
      binaryInterval: this.settings.binaryInterval,
      awaitWriteFinish: this.settings.awaitWriteFinish ? {
        stabilityThreshold: this.settings.awaitWriteFinish_stabilityThreshold,
        pollInterval: this.settings.awaitWriteFinish_pollInterval
      } : false
    });
    watcher.on("add", (path, stats) => this.file_modified("add", path, stats)).on("change", (path, stats) => this.file_modified("change", path, stats)).on("unlink", (path, stats) => this.file_modified("unlink", path, stats));
    return watcher;
  }
  onunload() {
    console.log("Unloading file watcher plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    const new_watcher = this.create_watcher();
    this.watcher.close().then(() => this.watcher = new_watcher);
  }
  async file_modified(event, path, stats) {
    try {
      if (this.last_modified.get(path) != stats.mtime) {
        this.last_modified.set(path, stats.mtime);
        const base_watcher = this.app.vault.adapter.watchers["/"];
        if (base_watcher) {
          try {
            base_watcher.watcher["_handle"].onchange(0, event, path);
          } catch (error) {
          }
        }
      }
    } catch (error) {
    }
  }
};
var FileWatcherSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Chokidar Settings" });
    new import_obsidian.Setting(containerEl).setName("followSymlinks").setDesc("followSymlinks").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.followSymlinks).onChange(async (value) => {
        this.plugin.settings.followSymlinks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("disableGlobbing").setDesc("disableGlobbing").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.disableGlobbing).onChange(async (value) => {
        this.plugin.settings.disableGlobbing = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("usePolling").setDesc("usePolling").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.usePolling).onChange(async (value) => {
        this.plugin.settings.usePolling = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("interval").setDesc("polling interval for non binary files").addSlider(
      (slider) => slider.setValue(this.plugin.settings.interval).setLimits(100, 6e4, 100).onChange(async (value) => {
        this.plugin.settings.interval = value;
        this.update_interval_value(value);
        await this.plugin.saveSettings();
      })
    );
    let interval_value = containerEl.createSpan(`Value: ${this.plugin.settings.interval}`);
    this.update_interval_value = (value) => {
      interval_value.setText(`Value: ${value}`);
    };
    this.update_interval_value(this.plugin.settings.interval);
    new import_obsidian.Setting(containerEl).setName("binaryInterval").setDesc("polling interval for binary files").addSlider(
      (slider) => slider.setValue(this.plugin.settings.binaryInterval).setLimits(100, 6e4, 100).onChange(async (value) => {
        this.plugin.settings.binaryInterval = value;
        this.update_binaryInterval_value(value);
        await this.plugin.saveSettings();
      })
    );
    let binaryInterval_value = containerEl.createSpan(`Value: ${this.plugin.settings.binaryInterval}`);
    this.update_binaryInterval_value = (value) => {
      binaryInterval_value.setText(`Value: ${value}`);
    };
    this.update_binaryInterval_value(this.plugin.settings.binaryInterval);
    new import_obsidian.Setting(containerEl).setName("awaitWriteFinish").setDesc("awaitWriteFinish").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.awaitWriteFinish).onChange(async (value) => {
        this.plugin.settings.awaitWriteFinish = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("awaitWriteFinish_stabilityThreshold").setDesc("stabilityThreshold for awaitWriteFinish").addSlider(
      (slider) => slider.setValue(this.plugin.settings.awaitWriteFinish_stabilityThreshold).setLimits(100, 1e5, 100).onChange(async (value) => {
        this.plugin.settings.awaitWriteFinish_stabilityThreshold = value;
        this.update_awaitWriteFinish_stabilityThreshold_value(value);
        await this.plugin.saveSettings();
      })
    );
    let awaitWriteFinish_stabilityThreshold_value = containerEl.createSpan(`Value: ${this.plugin.settings.awaitWriteFinish_stabilityThreshold}`);
    this.update_awaitWriteFinish_stabilityThreshold_value = (value) => {
      awaitWriteFinish_stabilityThreshold_value.setText(`Value: ${value}`);
    };
    this.update_awaitWriteFinish_stabilityThreshold_value(this.plugin.settings.awaitWriteFinish_stabilityThreshold);
    new import_obsidian.Setting(containerEl).setName("awaitWriteFinish_pollInterval").setDesc("polling interval for awaitWriteFinish").addSlider(
      (slider) => slider.setValue(this.plugin.settings.awaitWriteFinish_pollInterval).setLimits(100, 5e3, 100).onChange(async (value) => {
        this.plugin.settings.awaitWriteFinish_pollInterval = value;
        this.update_awaitWriteFinish_pollInterval_value(value);
        await this.plugin.saveSettings();
      })
    );
    let awaitWriteFinish_pollInterval_value = containerEl.createSpan(`Value: ${this.plugin.settings.awaitWriteFinish_pollInterval}`);
    this.update_awaitWriteFinish_pollInterval_value = (value) => {
      awaitWriteFinish_pollInterval_value.setText(`Value: ${value}`);
    };
    this.update_awaitWriteFinish_pollInterval_value(this.plugin.settings.awaitWriteFinish_pollInterval);
  }
};
/*! Bundled license information:

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3BpY29tYXRjaC9saWIvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3NjYW4uanMiLCAibm9kZV9tb2R1bGVzL3BpY29tYXRjaC9saWIvcGFyc2UuanMiLCAibm9kZV9tb2R1bGVzL3BpY29tYXRjaC9saWIvcGljb21hdGNoLmpzIiwgIm5vZGVfbW9kdWxlcy9waWNvbWF0Y2gvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3JlYWRkaXJwL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYW55bWF0Y2gvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2lzLWV4dGdsb2IvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2lzLWdsb2IvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2Nob2tpZGFyL25vZGVfbW9kdWxlcy9nbG9iLXBhcmVudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYnJhY2VzL2xpYi91dGlscy5qcyIsICJub2RlX21vZHVsZXMvYnJhY2VzL2xpYi9zdHJpbmdpZnkuanMiLCAibm9kZV9tb2R1bGVzL2lzLW51bWJlci9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvdG8tcmVnZXgtcmFuZ2UvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2ZpbGwtcmFuZ2UvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2JyYWNlcy9saWIvY29tcGlsZS5qcyIsICJub2RlX21vZHVsZXMvYnJhY2VzL2xpYi9leHBhbmQuanMiLCAibm9kZV9tb2R1bGVzL2JyYWNlcy9saWIvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL3BhcnNlLmpzIiwgIm5vZGVfbW9kdWxlcy9icmFjZXMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2JpbmFyeS1leHRlbnNpb25zL2JpbmFyeS1leHRlbnNpb25zLmpzb24iLCAibm9kZV9tb2R1bGVzL2JpbmFyeS1leHRlbnNpb25zL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9pcy1iaW5hcnktcGF0aC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvY2hva2lkYXIvbGliL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvY2hva2lkYXIvbGliL25vZGVmcy1oYW5kbGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaG9raWRhci9saWIvZnNldmVudHMtaGFuZGxlci5qcyIsICJub2RlX21vZHVsZXMvY2hva2lkYXIvaW5kZXguanMiLCAibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgV0lOX1NMQVNIID0gJ1xcXFxcXFxcLyc7XG5jb25zdCBXSU5fTk9fU0xBU0ggPSBgW14ke1dJTl9TTEFTSH1dYDtcblxuLyoqXG4gKiBQb3NpeCBnbG9iIHJlZ2V4XG4gKi9cblxuY29uc3QgRE9UX0xJVEVSQUwgPSAnXFxcXC4nO1xuY29uc3QgUExVU19MSVRFUkFMID0gJ1xcXFwrJztcbmNvbnN0IFFNQVJLX0xJVEVSQUwgPSAnXFxcXD8nO1xuY29uc3QgU0xBU0hfTElURVJBTCA9ICdcXFxcLyc7XG5jb25zdCBPTkVfQ0hBUiA9ICcoPz0uKSc7XG5jb25zdCBRTUFSSyA9ICdbXi9dJztcbmNvbnN0IEVORF9BTkNIT1IgPSBgKD86JHtTTEFTSF9MSVRFUkFMfXwkKWA7XG5jb25zdCBTVEFSVF9BTkNIT1IgPSBgKD86Xnwke1NMQVNIX0xJVEVSQUx9KWA7XG5jb25zdCBET1RTX1NMQVNIID0gYCR7RE9UX0xJVEVSQUx9ezEsMn0ke0VORF9BTkNIT1J9YDtcbmNvbnN0IE5PX0RPVCA9IGAoPyEke0RPVF9MSVRFUkFMfSlgO1xuY29uc3QgTk9fRE9UUyA9IGAoPyEke1NUQVJUX0FOQ0hPUn0ke0RPVFNfU0xBU0h9KWA7XG5jb25zdCBOT19ET1RfU0xBU0ggPSBgKD8hJHtET1RfTElURVJBTH17MCwxfSR7RU5EX0FOQ0hPUn0pYDtcbmNvbnN0IE5PX0RPVFNfU0xBU0ggPSBgKD8hJHtET1RTX1NMQVNIfSlgO1xuY29uc3QgUU1BUktfTk9fRE9UID0gYFteLiR7U0xBU0hfTElURVJBTH1dYDtcbmNvbnN0IFNUQVIgPSBgJHtRTUFSS30qP2A7XG5cbmNvbnN0IFBPU0lYX0NIQVJTID0ge1xuICBET1RfTElURVJBTCxcbiAgUExVU19MSVRFUkFMLFxuICBRTUFSS19MSVRFUkFMLFxuICBTTEFTSF9MSVRFUkFMLFxuICBPTkVfQ0hBUixcbiAgUU1BUkssXG4gIEVORF9BTkNIT1IsXG4gIERPVFNfU0xBU0gsXG4gIE5PX0RPVCxcbiAgTk9fRE9UUyxcbiAgTk9fRE9UX1NMQVNILFxuICBOT19ET1RTX1NMQVNILFxuICBRTUFSS19OT19ET1QsXG4gIFNUQVIsXG4gIFNUQVJUX0FOQ0hPUlxufTtcblxuLyoqXG4gKiBXaW5kb3dzIGdsb2IgcmVnZXhcbiAqL1xuXG5jb25zdCBXSU5ET1dTX0NIQVJTID0ge1xuICAuLi5QT1NJWF9DSEFSUyxcblxuICBTTEFTSF9MSVRFUkFMOiBgWyR7V0lOX1NMQVNIfV1gLFxuICBRTUFSSzogV0lOX05PX1NMQVNILFxuICBTVEFSOiBgJHtXSU5fTk9fU0xBU0h9Kj9gLFxuICBET1RTX1NMQVNIOiBgJHtET1RfTElURVJBTH17MSwyfSg/Olske1dJTl9TTEFTSH1dfCQpYCxcbiAgTk9fRE9UOiBgKD8hJHtET1RfTElURVJBTH0pYCxcbiAgTk9fRE9UUzogYCg/ISg/Ol58WyR7V0lOX1NMQVNIfV0pJHtET1RfTElURVJBTH17MSwyfSg/Olske1dJTl9TTEFTSH1dfCQpKWAsXG4gIE5PX0RPVF9TTEFTSDogYCg/ISR7RE9UX0xJVEVSQUx9ezAsMX0oPzpbJHtXSU5fU0xBU0h9XXwkKSlgLFxuICBOT19ET1RTX1NMQVNIOiBgKD8hJHtET1RfTElURVJBTH17MSwyfSg/Olske1dJTl9TTEFTSH1dfCQpKWAsXG4gIFFNQVJLX05PX0RPVDogYFteLiR7V0lOX1NMQVNIfV1gLFxuICBTVEFSVF9BTkNIT1I6IGAoPzpefFske1dJTl9TTEFTSH1dKWAsXG4gIEVORF9BTkNIT1I6IGAoPzpbJHtXSU5fU0xBU0h9XXwkKWBcbn07XG5cbi8qKlxuICogUE9TSVggQnJhY2tldCBSZWdleFxuICovXG5cbmNvbnN0IFBPU0lYX1JFR0VYX1NPVVJDRSA9IHtcbiAgYWxudW06ICdhLXpBLVowLTknLFxuICBhbHBoYTogJ2EtekEtWicsXG4gIGFzY2lpOiAnXFxcXHgwMC1cXFxceDdGJyxcbiAgYmxhbms6ICcgXFxcXHQnLFxuICBjbnRybDogJ1xcXFx4MDAtXFxcXHgxRlxcXFx4N0YnLFxuICBkaWdpdDogJzAtOScsXG4gIGdyYXBoOiAnXFxcXHgyMS1cXFxceDdFJyxcbiAgbG93ZXI6ICdhLXonLFxuICBwcmludDogJ1xcXFx4MjAtXFxcXHg3RSAnLFxuICBwdW5jdDogJ1xcXFwtIVwiIyQlJlxcJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX4nLFxuICBzcGFjZTogJyBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmJyxcbiAgdXBwZXI6ICdBLVonLFxuICB3b3JkOiAnQS1aYS16MC05XycsXG4gIHhkaWdpdDogJ0EtRmEtZjAtOSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNQVhfTEVOR1RIOiAxMDI0ICogNjQsXG4gIFBPU0lYX1JFR0VYX1NPVVJDRSxcblxuICAvLyByZWd1bGFyIGV4cHJlc3Npb25zXG4gIFJFR0VYX0JBQ0tTTEFTSDogL1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFxuICBSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzogL15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTOiAvWy0qKz8uXiR7fSh8KVtcXF1dLyxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOiAvKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6IC8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFxuICBSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOiAvKD86XFxbLio/W15cXFxcXVxcXXxcXFxcKD89LikpL2csXG5cbiAgLy8gUmVwbGFjZSBnbG9icyB3aXRoIGVxdWl2YWxlbnQgcGF0dGVybnMgdG8gcmVkdWNlIHBhcnNpbmcgdGltZS5cbiAgUkVQTEFDRU1FTlRTOiB7XG4gICAgJyoqKic6ICcqJyxcbiAgICAnKiovKionOiAnKionLFxuICAgICcqKi8qKi8qKic6ICcqKidcbiAgfSxcblxuICAvLyBEaWdpdHNcbiAgQ0hBUl8wOiA0OCwgLyogMCAqL1xuICBDSEFSXzk6IDU3LCAvKiA5ICovXG5cbiAgLy8gQWxwaGFiZXQgY2hhcnMuXG4gIENIQVJfVVBQRVJDQVNFX0E6IDY1LCAvKiBBICovXG4gIENIQVJfTE9XRVJDQVNFX0E6IDk3LCAvKiBhICovXG4gIENIQVJfVVBQRVJDQVNFX1o6IDkwLCAvKiBaICovXG4gIENIQVJfTE9XRVJDQVNFX1o6IDEyMiwgLyogeiAqL1xuXG4gIENIQVJfTEVGVF9QQVJFTlRIRVNFUzogNDAsIC8qICggKi9cbiAgQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzogNDEsIC8qICkgKi9cblxuICBDSEFSX0FTVEVSSVNLOiA0MiwgLyogKiAqL1xuXG4gIC8vIE5vbi1hbHBoYWJldGljIGNoYXJzLlxuICBDSEFSX0FNUEVSU0FORDogMzgsIC8qICYgKi9cbiAgQ0hBUl9BVDogNjQsIC8qIEAgKi9cbiAgQ0hBUl9CQUNLV0FSRF9TTEFTSDogOTIsIC8qIFxcICovXG4gIENIQVJfQ0FSUklBR0VfUkVUVVJOOiAxMywgLyogXFxyICovXG4gIENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6IDk0LCAvKiBeICovXG4gIENIQVJfQ09MT046IDU4LCAvKiA6ICovXG4gIENIQVJfQ09NTUE6IDQ0LCAvKiAsICovXG4gIENIQVJfRE9UOiA0NiwgLyogLiAqL1xuICBDSEFSX0RPVUJMRV9RVU9URTogMzQsIC8qIFwiICovXG4gIENIQVJfRVFVQUw6IDYxLCAvKiA9ICovXG4gIENIQVJfRVhDTEFNQVRJT05fTUFSSzogMzMsIC8qICEgKi9cbiAgQ0hBUl9GT1JNX0ZFRUQ6IDEyLCAvKiBcXGYgKi9cbiAgQ0hBUl9GT1JXQVJEX1NMQVNIOiA0NywgLyogLyAqL1xuICBDSEFSX0dSQVZFX0FDQ0VOVDogOTYsIC8qIGAgKi9cbiAgQ0hBUl9IQVNIOiAzNSwgLyogIyAqL1xuICBDSEFSX0hZUEhFTl9NSU5VUzogNDUsIC8qIC0gKi9cbiAgQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6IDYwLCAvKiA8ICovXG4gIENIQVJfTEVGVF9DVVJMWV9CUkFDRTogMTIzLCAvKiB7ICovXG4gIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDogOTEsIC8qIFsgKi9cbiAgQ0hBUl9MSU5FX0ZFRUQ6IDEwLCAvKiBcXG4gKi9cbiAgQ0hBUl9OT19CUkVBS19TUEFDRTogMTYwLCAvKiBcXHUwMEEwICovXG4gIENIQVJfUEVSQ0VOVDogMzcsIC8qICUgKi9cbiAgQ0hBUl9QTFVTOiA0MywgLyogKyAqL1xuICBDSEFSX1FVRVNUSU9OX01BUks6IDYzLCAvKiA/ICovXG4gIENIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVDogNjIsIC8qID4gKi9cbiAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTogMTI1LCAvKiB9ICovXG4gIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6IDkzLCAvKiBdICovXG4gIENIQVJfU0VNSUNPTE9OOiA1OSwgLyogOyAqL1xuICBDSEFSX1NJTkdMRV9RVU9URTogMzksIC8qICcgKi9cbiAgQ0hBUl9TUEFDRTogMzIsIC8qICAgKi9cbiAgQ0hBUl9UQUI6IDksIC8qIFxcdCAqL1xuICBDSEFSX1VOREVSU0NPUkU6IDk1LCAvKiBfICovXG4gIENIQVJfVkVSVElDQUxfTElORTogMTI0LCAvKiB8ICovXG4gIENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOiA2NTI3OSwgLyogXFx1RkVGRiAqL1xuXG4gIFNFUDogcGF0aC5zZXAsXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBFWFRHTE9CX0NIQVJTXG4gICAqL1xuXG4gIGV4dGdsb2JDaGFycyhjaGFycykge1xuICAgIHJldHVybiB7XG4gICAgICAnISc6IHsgdHlwZTogJ25lZ2F0ZScsIG9wZW46ICcoPzooPyEoPzonLCBjbG9zZTogYCkpJHtjaGFycy5TVEFSfSlgIH0sXG4gICAgICAnPyc6IHsgdHlwZTogJ3FtYXJrJywgb3BlbjogJyg/OicsIGNsb3NlOiAnKT8nIH0sXG4gICAgICAnKyc6IHsgdHlwZTogJ3BsdXMnLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpKycgfSxcbiAgICAgICcqJzogeyB0eXBlOiAnc3RhcicsIG9wZW46ICcoPzonLCBjbG9zZTogJykqJyB9LFxuICAgICAgJ0AnOiB7IHR5cGU6ICdhdCcsIG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgR0xPQl9DSEFSU1xuICAgKi9cblxuICBnbG9iQ2hhcnMod2luMzIpIHtcbiAgICByZXR1cm4gd2luMzIgPT09IHRydWUgPyBXSU5ET1dTX0NIQVJTIDogUE9TSVhfQ0hBUlM7XG4gIH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgd2luMzIgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xuY29uc3Qge1xuICBSRUdFWF9CQUNLU0xBU0gsXG4gIFJFR0VYX1JFTU9WRV9CQUNLU0xBU0gsXG4gIFJFR0VYX1NQRUNJQUxfQ0hBUlMsXG4gIFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuZXhwb3J0cy5pc09iamVjdCA9IHZhbCA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcbmV4cG9ydHMuaGFzUmVnZXhDaGFycyA9IHN0ciA9PiBSRUdFWF9TUEVDSUFMX0NIQVJTLnRlc3Qoc3RyKTtcbmV4cG9ydHMuaXNSZWdleENoYXIgPSBzdHIgPT4gc3RyLmxlbmd0aCA9PT0gMSAmJiBleHBvcnRzLmhhc1JlZ2V4Q2hhcnMoc3RyKTtcbmV4cG9ydHMuZXNjYXBlUmVnZXggPSBzdHIgPT4gc3RyLnJlcGxhY2UoUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUwsICdcXFxcJDEnKTtcbmV4cG9ydHMudG9Qb3NpeFNsYXNoZXMgPSBzdHIgPT4gc3RyLnJlcGxhY2UoUkVHRVhfQkFDS1NMQVNILCAnLycpO1xuXG5leHBvcnRzLnJlbW92ZUJhY2tzbGFzaGVzID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYX1JFTU9WRV9CQUNLU0xBU0gsIG1hdGNoID0+IHtcbiAgICByZXR1cm4gbWF0Y2ggPT09ICdcXFxcJyA/ICcnIDogbWF0Y2g7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5zdXBwb3J0c0xvb2tiZWhpbmRzID0gKCkgPT4ge1xuICBjb25zdCBzZWdzID0gcHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpLnNwbGl0KCcuJykubWFwKE51bWJlcik7XG4gIGlmIChzZWdzLmxlbmd0aCA9PT0gMyAmJiBzZWdzWzBdID49IDkgfHwgKHNlZ3NbMF0gPT09IDggJiYgc2Vnc1sxXSA+PSAxMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnRzLmlzV2luZG93cyA9IG9wdGlvbnMgPT4ge1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy53aW5kb3dzID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy53aW5kb3dzO1xuICB9XG4gIHJldHVybiB3aW4zMiA9PT0gdHJ1ZSB8fCBwYXRoLnNlcCA9PT0gJ1xcXFwnO1xufTtcblxuZXhwb3J0cy5lc2NhcGVMYXN0ID0gKGlucHV0LCBjaGFyLCBsYXN0SWR4KSA9PiB7XG4gIGNvbnN0IGlkeCA9IGlucHV0Lmxhc3RJbmRleE9mKGNoYXIsIGxhc3RJZHgpO1xuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIGlucHV0O1xuICBpZiAoaW5wdXRbaWR4IC0gMV0gPT09ICdcXFxcJykgcmV0dXJuIGV4cG9ydHMuZXNjYXBlTGFzdChpbnB1dCwgY2hhciwgaWR4IC0gMSk7XG4gIHJldHVybiBgJHtpbnB1dC5zbGljZSgwLCBpZHgpfVxcXFwke2lucHV0LnNsaWNlKGlkeCl9YDtcbn07XG5cbmV4cG9ydHMucmVtb3ZlUHJlZml4ID0gKGlucHV0LCBzdGF0ZSA9IHt9KSA9PiB7XG4gIGxldCBvdXRwdXQgPSBpbnB1dDtcbiAgaWYgKG91dHB1dC5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0LnNsaWNlKDIpO1xuICAgIHN0YXRlLnByZWZpeCA9ICcuLyc7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmV4cG9ydHMud3JhcE91dHB1dCA9IChpbnB1dCwgc3RhdGUgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHByZXBlbmQgPSBvcHRpb25zLmNvbnRhaW5zID8gJycgOiAnXic7XG4gIGNvbnN0IGFwcGVuZCA9IG9wdGlvbnMuY29udGFpbnMgPyAnJyA6ICckJztcblxuICBsZXQgb3V0cHV0ID0gYCR7cHJlcGVuZH0oPzoke2lucHV0fSkke2FwcGVuZH1gO1xuICBpZiAoc3RhdGUubmVnYXRlZCA9PT0gdHJ1ZSkge1xuICAgIG91dHB1dCA9IGAoPzpeKD8hJHtvdXRwdXR9KS4qJClgO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7XG4gIENIQVJfQVNURVJJU0ssICAgICAgICAgICAgIC8qICogKi9cbiAgQ0hBUl9BVCwgICAgICAgICAgICAgICAgICAgLyogQCAqL1xuICBDSEFSX0JBQ0tXQVJEX1NMQVNILCAgICAgICAvKiBcXCAqL1xuICBDSEFSX0NPTU1BLCAgICAgICAgICAgICAgICAvKiAsICovXG4gIENIQVJfRE9ULCAgICAgICAgICAgICAgICAgIC8qIC4gKi9cbiAgQ0hBUl9FWENMQU1BVElPTl9NQVJLLCAgICAgLyogISAqL1xuICBDSEFSX0ZPUldBUkRfU0xBU0gsICAgICAgICAvKiAvICovXG4gIENIQVJfTEVGVF9DVVJMWV9CUkFDRSwgICAgIC8qIHsgKi9cbiAgQ0hBUl9MRUZUX1BBUkVOVEhFU0VTLCAgICAgLyogKCAqL1xuICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQsICAvKiBbICovXG4gIENIQVJfUExVUywgICAgICAgICAgICAgICAgIC8qICsgKi9cbiAgQ0hBUl9RVUVTVElPTl9NQVJLLCAgICAgICAgLyogPyAqL1xuICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFLCAgICAvKiB9ICovXG4gIENIQVJfUklHSFRfUEFSRU5USEVTRVMsICAgIC8qICkgKi9cbiAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCAgLyogXSAqL1xufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGlzUGF0aFNlcGFyYXRvciA9IGNvZGUgPT4ge1xuICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIIHx8IGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0g7XG59O1xuXG5jb25zdCBkZXB0aCA9IHRva2VuID0+IHtcbiAgaWYgKHRva2VuLmlzUHJlZml4ICE9PSB0cnVlKSB7XG4gICAgdG9rZW4uZGVwdGggPSB0b2tlbi5pc0dsb2JzdGFyID8gSW5maW5pdHkgOiAxO1xuICB9XG59O1xuXG4vKipcbiAqIFF1aWNrbHkgc2NhbnMgYSBnbG9iIHBhdHRlcm4gYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBoYW5kZnVsIG9mXG4gKiB1c2VmdWwgcHJvcGVydGllcywgbGlrZSBgaXNHbG9iYCwgYHBhdGhgICh0aGUgbGVhZGluZyBub24tZ2xvYiwgaWYgaXQgZXhpc3RzKSxcbiAqIGBnbG9iYCAodGhlIGFjdHVhbCBwYXR0ZXJuKSwgYG5lZ2F0ZWRgICh0cnVlIGlmIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGAhYCBidXQgbm90XG4gKiB3aXRoIGAhKGApIGFuZCBgbmVnYXRlZEV4dGdsb2JgICh0cnVlIGlmIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGAhKGApLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwbSA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc29sZS5sb2cocG0uc2NhbignZm9vL2Jhci8qLmpzJykpO1xuICogeyBpc0dsb2I6IHRydWUsIGlucHV0OiAnZm9vL2Jhci8qLmpzJywgYmFzZTogJ2Zvby9iYXInLCBnbG9iOiAnKi5qcycgfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0b2tlbnMgYW5kIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmNvbnN0IHNjYW4gPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoIC0gMTtcbiAgY29uc3Qgc2NhblRvRW5kID0gb3B0cy5wYXJ0cyA9PT0gdHJ1ZSB8fCBvcHRzLnNjYW5Ub0VuZCA9PT0gdHJ1ZTtcbiAgY29uc3Qgc2xhc2hlcyA9IFtdO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgcGFydHMgPSBbXTtcblxuICBsZXQgc3RyID0gaW5wdXQ7XG4gIGxldCBpbmRleCA9IC0xO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgbGV0IGlzQnJhY2UgPSBmYWxzZTtcbiAgbGV0IGlzQnJhY2tldCA9IGZhbHNlO1xuICBsZXQgaXNHbG9iID0gZmFsc2U7XG4gIGxldCBpc0V4dGdsb2IgPSBmYWxzZTtcbiAgbGV0IGlzR2xvYnN0YXIgPSBmYWxzZTtcbiAgbGV0IGJyYWNlRXNjYXBlZCA9IGZhbHNlO1xuICBsZXQgYmFja3NsYXNoZXMgPSBmYWxzZTtcbiAgbGV0IG5lZ2F0ZWQgPSBmYWxzZTtcbiAgbGV0IG5lZ2F0ZWRFeHRnbG9iID0gZmFsc2U7XG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICBsZXQgYnJhY2VzID0gMDtcbiAgbGV0IHByZXY7XG4gIGxldCBjb2RlO1xuICBsZXQgdG9rZW4gPSB7IHZhbHVlOiAnJywgZGVwdGg6IDAsIGlzR2xvYjogZmFsc2UgfTtcblxuICBjb25zdCBlb3MgPSAoKSA9PiBpbmRleCA+PSBsZW5ndGg7XG4gIGNvbnN0IHBlZWsgPSAoKSA9PiBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICBjb25zdCBhZHZhbmNlID0gKCkgPT4ge1xuICAgIHByZXYgPSBjb2RlO1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcbiAgfTtcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjb2RlID0gYWR2YW5jZSgpO1xuICAgIGxldCBuZXh0O1xuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgY29kZSA9IGFkdmFuY2UoKTtcblxuICAgICAgaWYgKGNvZGUgPT09IENIQVJfTEVGVF9DVVJMWV9CUkFDRSkge1xuICAgICAgICBicmFjZUVzY2FwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGJyYWNlRXNjYXBlZCA9PT0gdHJ1ZSB8fCBjb2RlID09PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UpIHtcbiAgICAgIGJyYWNlcysrO1xuXG4gICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKGNvZGUgPSBhZHZhbmNlKCkpKSB7XG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfTEVGVF9DVVJMWV9CUkFDRSkge1xuICAgICAgICAgIGJyYWNlcysrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJyYWNlRXNjYXBlZCAhPT0gdHJ1ZSAmJiBjb2RlID09PSBDSEFSX0RPVCAmJiAoY29kZSA9IGFkdmFuY2UoKSkgPT09IENIQVJfRE9UKSB7XG4gICAgICAgICAgaXNCcmFjZSA9IHRva2VuLmlzQnJhY2UgPSB0cnVlO1xuICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnJhY2VFc2NhcGVkICE9PSB0cnVlICYmIGNvZGUgPT09IENIQVJfQ09NTUEpIHtcbiAgICAgICAgICBpc0JyYWNlID0gdG9rZW4uaXNCcmFjZSA9IHRydWU7XG4gICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFKSB7XG4gICAgICAgICAgYnJhY2VzLS07XG5cbiAgICAgICAgICBpZiAoYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICBicmFjZUVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlzQnJhY2UgPSB0b2tlbi5pc0JyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICBzbGFzaGVzLnB1c2goaW5kZXgpO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgdG9rZW4gPSB7IHZhbHVlOiAnJywgZGVwdGg6IDAsIGlzR2xvYjogZmFsc2UgfTtcblxuICAgICAgaWYgKGZpbmlzaGVkID09PSB0cnVlKSBjb250aW51ZTtcbiAgICAgIGlmIChwcmV2ID09PSBDSEFSX0RPVCAmJiBpbmRleCA9PT0gKHN0YXJ0ICsgMSkpIHtcbiAgICAgICAgc3RhcnQgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm5vZXh0ICE9PSB0cnVlKSB7XG4gICAgICBjb25zdCBpc0V4dGdsb2JDaGFyID0gY29kZSA9PT0gQ0hBUl9QTFVTXG4gICAgICAgIHx8IGNvZGUgPT09IENIQVJfQVRcbiAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9BU1RFUklTS1xuICAgICAgICB8fCBjb2RlID09PSBDSEFSX1FVRVNUSU9OX01BUktcbiAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9FWENMQU1BVElPTl9NQVJLO1xuXG4gICAgICBpZiAoaXNFeHRnbG9iQ2hhciA9PT0gdHJ1ZSAmJiBwZWVrKCkgPT09IENIQVJfTEVGVF9QQVJFTlRIRVNFUykge1xuICAgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgICBpc0V4dGdsb2IgPSB0b2tlbi5pc0V4dGdsb2IgPSB0cnVlO1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX0VYQ0xBTUFUSU9OX01BUksgJiYgaW5kZXggPT09IHN0YXJ0KSB7XG4gICAgICAgICAgbmVnYXRlZEV4dGdsb2IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAoY29kZSA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICBjb2RlID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfUklHSFRfUEFSRU5USEVTRVMpIHtcbiAgICAgICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfQVNURVJJU0spIHtcbiAgICAgIGlmIChwcmV2ID09PSBDSEFSX0FTVEVSSVNLKSBpc0dsb2JzdGFyID0gdG9rZW4uaXNHbG9ic3RhciA9IHRydWU7XG4gICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfUVVFU1RJT05fTUFSSykge1xuICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQpIHtcbiAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAobmV4dCA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgaWYgKG5leHQgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCA9PT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCkge1xuICAgICAgICAgIGlzQnJhY2tldCA9IHRva2VuLmlzQnJhY2tldCA9IHRydWU7XG4gICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubm9uZWdhdGUgIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9FWENMQU1BVElPTl9NQVJLICYmIGluZGV4ID09PSBzdGFydCkge1xuICAgICAgbmVnYXRlZCA9IHRva2VuLm5lZ2F0ZWQgPSB0cnVlO1xuICAgICAgc3RhcnQrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm5vcGFyZW4gIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG4gICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAoY29kZSA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG4gICAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUykge1xuICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlzR2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5ub2V4dCA9PT0gdHJ1ZSkge1xuICAgIGlzRXh0Z2xvYiA9IGZhbHNlO1xuICAgIGlzR2xvYiA9IGZhbHNlO1xuICB9XG5cbiAgbGV0IGJhc2UgPSBzdHI7XG4gIGxldCBwcmVmaXggPSAnJztcbiAgbGV0IGdsb2IgPSAnJztcblxuICBpZiAoc3RhcnQgPiAwKSB7XG4gICAgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHN0YXJ0KTtcbiAgICBzdHIgPSBzdHIuc2xpY2Uoc3RhcnQpO1xuICAgIGxhc3RJbmRleCAtPSBzdGFydDtcbiAgfVxuXG4gIGlmIChiYXNlICYmIGlzR2xvYiA9PT0gdHJ1ZSAmJiBsYXN0SW5kZXggPiAwKSB7XG4gICAgYmFzZSA9IHN0ci5zbGljZSgwLCBsYXN0SW5kZXgpO1xuICAgIGdsb2IgPSBzdHIuc2xpY2UobGFzdEluZGV4KTtcbiAgfSBlbHNlIGlmIChpc0dsb2IgPT09IHRydWUpIHtcbiAgICBiYXNlID0gJyc7XG4gICAgZ2xvYiA9IHN0cjtcbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gc3RyO1xuICB9XG5cbiAgaWYgKGJhc2UgJiYgYmFzZSAhPT0gJycgJiYgYmFzZSAhPT0gJy8nICYmIGJhc2UgIT09IHN0cikge1xuICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoYmFzZS5jaGFyQ29kZUF0KGJhc2UubGVuZ3RoIC0gMSkpKSB7XG4gICAgICBiYXNlID0gYmFzZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICBpZiAoZ2xvYikgZ2xvYiA9IHV0aWxzLnJlbW92ZUJhY2tzbGFzaGVzKGdsb2IpO1xuXG4gICAgaWYgKGJhc2UgJiYgYmFja3NsYXNoZXMgPT09IHRydWUpIHtcbiAgICAgIGJhc2UgPSB1dGlscy5yZW1vdmVCYWNrc2xhc2hlcyhiYXNlKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBwcmVmaXgsXG4gICAgaW5wdXQsXG4gICAgc3RhcnQsXG4gICAgYmFzZSxcbiAgICBnbG9iLFxuICAgIGlzQnJhY2UsXG4gICAgaXNCcmFja2V0LFxuICAgIGlzR2xvYixcbiAgICBpc0V4dGdsb2IsXG4gICAgaXNHbG9ic3RhcixcbiAgICBuZWdhdGVkLFxuICAgIG5lZ2F0ZWRFeHRnbG9iXG4gIH07XG5cbiAgaWYgKG9wdHMudG9rZW5zID09PSB0cnVlKSB7XG4gICAgc3RhdGUubWF4RGVwdGggPSAwO1xuICAgIGlmICghaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfVxuICAgIHN0YXRlLnRva2VucyA9IHRva2VucztcbiAgfVxuXG4gIGlmIChvcHRzLnBhcnRzID09PSB0cnVlIHx8IG9wdHMudG9rZW5zID09PSB0cnVlKSB7XG4gICAgbGV0IHByZXZJbmRleDtcblxuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNsYXNoZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgY29uc3QgbiA9IHByZXZJbmRleCA/IHByZXZJbmRleCArIDEgOiBzdGFydDtcbiAgICAgIGNvbnN0IGkgPSBzbGFzaGVzW2lkeF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnNsaWNlKG4sIGkpO1xuICAgICAgaWYgKG9wdHMudG9rZW5zKSB7XG4gICAgICAgIGlmIChpZHggPT09IDAgJiYgc3RhcnQgIT09IDApIHtcbiAgICAgICAgICB0b2tlbnNbaWR4XS5pc1ByZWZpeCA9IHRydWU7XG4gICAgICAgICAgdG9rZW5zW2lkeF0udmFsdWUgPSBwcmVmaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zW2lkeF0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCh0b2tlbnNbaWR4XSk7XG4gICAgICAgIHN0YXRlLm1heERlcHRoICs9IHRva2Vuc1tpZHhdLmRlcHRoO1xuICAgICAgfVxuICAgICAgaWYgKGlkeCAhPT0gMCB8fCB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgcGFydHMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBwcmV2SW5kZXggPSBpO1xuICAgIH1cblxuICAgIGlmIChwcmV2SW5kZXggJiYgcHJldkluZGV4ICsgMSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC5zbGljZShwcmV2SW5kZXggKyAxKTtcbiAgICAgIHBhcnRzLnB1c2godmFsdWUpO1xuXG4gICAgICBpZiAob3B0cy50b2tlbnMpIHtcbiAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBkZXB0aCh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgc3RhdGUubWF4RGVwdGggKz0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5kZXB0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5zbGFzaGVzID0gc2xhc2hlcztcbiAgICBzdGF0ZS5wYXJ0cyA9IHBhcnRzO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzY2FuO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IHtcbiAgTUFYX0xFTkdUSCxcbiAgUE9TSVhfUkVHRVhfU09VUkNFLFxuICBSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUyxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGLFxuICBSRVBMQUNFTUVOVFNcbn0gPSBjb25zdGFudHM7XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5cbmNvbnN0IGV4cGFuZFJhbmdlID0gKGFyZ3MsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmV4cGFuZFJhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZXhwYW5kUmFuZ2UoLi4uYXJncywgb3B0aW9ucyk7XG4gIH1cblxuICBhcmdzLnNvcnQoKTtcbiAgY29uc3QgdmFsdWUgPSBgWyR7YXJncy5qb2luKCctJyl9XWA7XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3ICovXG4gICAgbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIGFyZ3MubWFwKHYgPT4gdXRpbHMuZXNjYXBlUmVnZXgodikpLmpvaW4oJy4uJyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgbWVzc2FnZSBmb3IgYSBzeW50YXggZXJyb3JcbiAqL1xuXG5jb25zdCBzeW50YXhFcnJvciA9ICh0eXBlLCBjaGFyKSA9PiB7XG4gIHJldHVybiBgTWlzc2luZyAke3R5cGV9OiBcIiR7Y2hhcn1cIiAtIHVzZSBcIlxcXFxcXFxcJHtjaGFyfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBpbnB1dCBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuY29uc3QgcGFyc2UgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgaW5wdXQgPSBSRVBMQUNFTUVOVFNbaW5wdXRdIHx8IGlucHV0O1xuXG4gIGNvbnN0IG9wdHMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgY29uc3QgbWF4ID0gdHlwZW9mIG9wdHMubWF4TGVuZ3RoID09PSAnbnVtYmVyJyA/IE1hdGgubWluKE1BWF9MRU5HVEgsIG9wdHMubWF4TGVuZ3RoKSA6IE1BWF9MRU5HVEg7XG5cbiAgbGV0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IG1heCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2xlbn0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHttYXh9YCk7XG4gIH1cblxuICBjb25zdCBib3MgPSB7IHR5cGU6ICdib3MnLCB2YWx1ZTogJycsIG91dHB1dDogb3B0cy5wcmVwZW5kIHx8ICcnIH07XG4gIGNvbnN0IHRva2VucyA9IFtib3NdO1xuXG4gIGNvbnN0IGNhcHR1cmUgPSBvcHRzLmNhcHR1cmUgPyAnJyA6ICc/Oic7XG4gIGNvbnN0IHdpbjMyID0gdXRpbHMuaXNXaW5kb3dzKG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSBjb25zdGFudHMgYmFzZWQgb24gcGxhdGZvcm0sIGZvciB3aW5kb3dzIG9yIHBvc2l4XG4gIGNvbnN0IFBMQVRGT1JNX0NIQVJTID0gY29uc3RhbnRzLmdsb2JDaGFycyh3aW4zMik7XG4gIGNvbnN0IEVYVEdMT0JfQ0hBUlMgPSBjb25zdGFudHMuZXh0Z2xvYkNoYXJzKFBMQVRGT1JNX0NIQVJTKTtcblxuICBjb25zdCB7XG4gICAgRE9UX0xJVEVSQUwsXG4gICAgUExVU19MSVRFUkFMLFxuICAgIFNMQVNIX0xJVEVSQUwsXG4gICAgT05FX0NIQVIsXG4gICAgRE9UU19TTEFTSCxcbiAgICBOT19ET1QsXG4gICAgTk9fRE9UX1NMQVNILFxuICAgIE5PX0RPVFNfU0xBU0gsXG4gICAgUU1BUkssXG4gICAgUU1BUktfTk9fRE9ULFxuICAgIFNUQVIsXG4gICAgU1RBUlRfQU5DSE9SXG4gIH0gPSBQTEFURk9STV9DSEFSUztcblxuICBjb25zdCBnbG9ic3RhciA9IG9wdHMgPT4ge1xuICAgIHJldHVybiBgKCR7Y2FwdHVyZX0oPzooPyEke1NUQVJUX0FOQ0hPUn0ke29wdHMuZG90ID8gRE9UU19TTEFTSCA6IERPVF9MSVRFUkFMfSkuKSo/KWA7XG4gIH07XG5cbiAgY29uc3Qgbm9kb3QgPSBvcHRzLmRvdCA/ICcnIDogTk9fRE9UO1xuICBjb25zdCBxbWFya05vRG90ID0gb3B0cy5kb3QgPyBRTUFSSyA6IFFNQVJLX05PX0RPVDtcbiAgbGV0IHN0YXIgPSBvcHRzLmJhc2ggPT09IHRydWUgPyBnbG9ic3RhcihvcHRzKSA6IFNUQVI7XG5cbiAgaWYgKG9wdHMuY2FwdHVyZSkge1xuICAgIHN0YXIgPSBgKCR7c3Rhcn0pYDtcbiAgfVxuXG4gIC8vIG1pbmltYXRjaCBvcHRpb25zIHN1cHBvcnRcbiAgaWYgKHR5cGVvZiBvcHRzLm5vZXh0ID09PSAnYm9vbGVhbicpIHtcbiAgICBvcHRzLm5vZXh0Z2xvYiA9IG9wdHMubm9leHQ7XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBpbnB1dCxcbiAgICBpbmRleDogLTEsXG4gICAgc3RhcnQ6IDAsXG4gICAgZG90OiBvcHRzLmRvdCA9PT0gdHJ1ZSxcbiAgICBjb25zdW1lZDogJycsXG4gICAgb3V0cHV0OiAnJyxcbiAgICBwcmVmaXg6ICcnLFxuICAgIGJhY2t0cmFjazogZmFsc2UsXG4gICAgbmVnYXRlZDogZmFsc2UsXG4gICAgYnJhY2tldHM6IDAsXG4gICAgYnJhY2VzOiAwLFxuICAgIHBhcmVuczogMCxcbiAgICBxdW90ZXM6IDAsXG4gICAgZ2xvYnN0YXI6IGZhbHNlLFxuICAgIHRva2Vuc1xuICB9O1xuXG4gIGlucHV0ID0gdXRpbHMucmVtb3ZlUHJlZml4KGlucHV0LCBzdGF0ZSk7XG4gIGxlbiA9IGlucHV0Lmxlbmd0aDtcblxuICBjb25zdCBleHRnbG9icyA9IFtdO1xuICBjb25zdCBicmFjZXMgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgbGV0IHByZXYgPSBib3M7XG4gIGxldCB2YWx1ZTtcblxuICAvKipcbiAgICogVG9rZW5pemluZyBoZWxwZXJzXG4gICAqL1xuXG4gIGNvbnN0IGVvcyA9ICgpID0+IHN0YXRlLmluZGV4ID09PSBsZW4gLSAxO1xuICBjb25zdCBwZWVrID0gc3RhdGUucGVlayA9IChuID0gMSkgPT4gaW5wdXRbc3RhdGUuaW5kZXggKyBuXTtcbiAgY29uc3QgYWR2YW5jZSA9IHN0YXRlLmFkdmFuY2UgPSAoKSA9PiBpbnB1dFsrK3N0YXRlLmluZGV4XSB8fCAnJztcbiAgY29uc3QgcmVtYWluaW5nID0gKCkgPT4gaW5wdXQuc2xpY2Uoc3RhdGUuaW5kZXggKyAxKTtcbiAgY29uc3QgY29uc3VtZSA9ICh2YWx1ZSA9ICcnLCBudW0gPSAwKSA9PiB7XG4gICAgc3RhdGUuY29uc3VtZWQgKz0gdmFsdWU7XG4gICAgc3RhdGUuaW5kZXggKz0gbnVtO1xuICB9O1xuXG4gIGNvbnN0IGFwcGVuZCA9IHRva2VuID0+IHtcbiAgICBzdGF0ZS5vdXRwdXQgKz0gdG9rZW4ub3V0cHV0ICE9IG51bGwgPyB0b2tlbi5vdXRwdXQgOiB0b2tlbi52YWx1ZTtcbiAgICBjb25zdW1lKHRva2VuLnZhbHVlKTtcbiAgfTtcblxuICBjb25zdCBuZWdhdGUgPSAoKSA9PiB7XG4gICAgbGV0IGNvdW50ID0gMTtcblxuICAgIHdoaWxlIChwZWVrKCkgPT09ICchJyAmJiAocGVlaygyKSAhPT0gJygnIHx8IHBlZWsoMykgPT09ICc/JykpIHtcbiAgICAgIGFkdmFuY2UoKTtcbiAgICAgIHN0YXRlLnN0YXJ0Kys7XG4gICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIGlmIChjb3VudCAlIDIgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5uZWdhdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5zdGFydCsrO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGNvbnN0IGluY3JlbWVudCA9IHR5cGUgPT4ge1xuICAgIHN0YXRlW3R5cGVdKys7XG4gICAgc3RhY2sucHVzaCh0eXBlKTtcbiAgfTtcblxuICBjb25zdCBkZWNyZW1lbnQgPSB0eXBlID0+IHtcbiAgICBzdGF0ZVt0eXBlXS0tO1xuICAgIHN0YWNrLnBvcCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIHRva2VucyBvbnRvIHRoZSB0b2tlbnMgYXJyYXkuIFRoaXMgaGVscGVyIHNwZWVkcyB1cFxuICAgKiB0b2tlbml6aW5nIGJ5IDEpIGhlbHBpbmcgdXMgYXZvaWQgYmFja3RyYWNraW5nIGFzIG11Y2ggYXMgcG9zc2libGUsXG4gICAqIGFuZCAyKSBoZWxwaW5nIHVzIGF2b2lkIGNyZWF0aW5nIGV4dHJhIHRva2VucyB3aGVuIGNvbnNlY3V0aXZlXG4gICAqIGNoYXJhY3RlcnMgYXJlIHBsYWluIHRleHQuIFRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgYW5kIHNpbXBsaWZpZXNcbiAgICogbG9va2JlaGluZHMuXG4gICAqL1xuXG4gIGNvbnN0IHB1c2ggPSB0b2sgPT4ge1xuICAgIGlmIChwcmV2LnR5cGUgPT09ICdnbG9ic3RhcicpIHtcbiAgICAgIGNvbnN0IGlzQnJhY2UgPSBzdGF0ZS5icmFjZXMgPiAwICYmICh0b2sudHlwZSA9PT0gJ2NvbW1hJyB8fCB0b2sudHlwZSA9PT0gJ2JyYWNlJyk7XG4gICAgICBjb25zdCBpc0V4dGdsb2IgPSB0b2suZXh0Z2xvYiA9PT0gdHJ1ZSB8fCAoZXh0Z2xvYnMubGVuZ3RoICYmICh0b2sudHlwZSA9PT0gJ3BpcGUnIHx8IHRvay50eXBlID09PSAncGFyZW4nKSk7XG5cbiAgICAgIGlmICh0b2sudHlwZSAhPT0gJ3NsYXNoJyAmJiB0b2sudHlwZSAhPT0gJ3BhcmVuJyAmJiAhaXNCcmFjZSAmJiAhaXNFeHRnbG9iKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtcHJldi5vdXRwdXQubGVuZ3RoKTtcbiAgICAgICAgcHJldi50eXBlID0gJ3N0YXInO1xuICAgICAgICBwcmV2LnZhbHVlID0gJyonO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IHN0YXI7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBwcmV2Lm91dHB1dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0Z2xvYnMubGVuZ3RoICYmIHRvay50eXBlICE9PSAncGFyZW4nKSB7XG4gICAgICBleHRnbG9ic1tleHRnbG9icy5sZW5ndGggLSAxXS5pbm5lciArPSB0b2sudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHRvay52YWx1ZSB8fCB0b2sub3V0cHV0KSBhcHBlbmQodG9rKTtcbiAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICd0ZXh0JyAmJiB0b2sudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBwcmV2LnZhbHVlICs9IHRvay52YWx1ZTtcbiAgICAgIHByZXYub3V0cHV0ID0gKHByZXYub3V0cHV0IHx8ICcnKSArIHRvay52YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2sucHJldiA9IHByZXY7XG4gICAgdG9rZW5zLnB1c2godG9rKTtcbiAgICBwcmV2ID0gdG9rO1xuICB9O1xuXG4gIGNvbnN0IGV4dGdsb2JPcGVuID0gKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdG9rZW4gPSB7IC4uLkVYVEdMT0JfQ0hBUlNbdmFsdWVdLCBjb25kaXRpb25zOiAxLCBpbm5lcjogJycgfTtcblxuICAgIHRva2VuLnByZXYgPSBwcmV2O1xuICAgIHRva2VuLnBhcmVucyA9IHN0YXRlLnBhcmVucztcbiAgICB0b2tlbi5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQ7XG4gICAgY29uc3Qgb3V0cHV0ID0gKG9wdHMuY2FwdHVyZSA/ICcoJyA6ICcnKSArIHRva2VuLm9wZW47XG5cbiAgICBpbmNyZW1lbnQoJ3BhcmVucycpO1xuICAgIHB1c2goeyB0eXBlLCB2YWx1ZSwgb3V0cHV0OiBzdGF0ZS5vdXRwdXQgPyAnJyA6IE9ORV9DSEFSIH0pO1xuICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCBleHRnbG9iOiB0cnVlLCB2YWx1ZTogYWR2YW5jZSgpLCBvdXRwdXQgfSk7XG4gICAgZXh0Z2xvYnMucHVzaCh0b2tlbik7XG4gIH07XG5cbiAgY29uc3QgZXh0Z2xvYkNsb3NlID0gdG9rZW4gPT4ge1xuICAgIGxldCBvdXRwdXQgPSB0b2tlbi5jbG9zZSArIChvcHRzLmNhcHR1cmUgPyAnKScgOiAnJyk7XG4gICAgbGV0IHJlc3Q7XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ25lZ2F0ZScpIHtcbiAgICAgIGxldCBleHRnbG9iU3RhciA9IHN0YXI7XG5cbiAgICAgIGlmICh0b2tlbi5pbm5lciAmJiB0b2tlbi5pbm5lci5sZW5ndGggPiAxICYmIHRva2VuLmlubmVyLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgICAgZXh0Z2xvYlN0YXIgPSBnbG9ic3RhcihvcHRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dGdsb2JTdGFyICE9PSBzdGFyIHx8IGVvcygpIHx8IC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKSB7XG4gICAgICAgIG91dHB1dCA9IHRva2VuLmNsb3NlID0gYCkkKSkke2V4dGdsb2JTdGFyfWA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5pbm5lci5pbmNsdWRlcygnKicpICYmIChyZXN0ID0gcmVtYWluaW5nKCkpICYmIC9eXFwuW15cXFxcLy5dKyQvLnRlc3QocmVzdCkpIHtcbiAgICAgICAgLy8gQW55IG5vbi1tYWdpY2FsIHN0cmluZyAoYC50c2ApIG9yIGV2ZW4gbmVzdGVkIGV4cHJlc3Npb24gKGAue3RzLHRzeH1gKSBjYW4gZm9sbG93IGFmdGVyIHRoZSBjbG9zaW5nIHBhcmVudGhlc2lzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gcGFyc2UgdGhlIHN0cmluZyBhbmQgdXNlIGl0IGluIHRoZSBvdXRwdXQgb2YgdGhlIG9yaWdpbmFsIHBhdHRlcm4uXG4gICAgICAgIC8vIFN1aXRhYmxlIHBhdHRlcm5zOiBgLyEoKi5kKS50c2AsIGAvISgqLmQpLnt0cyx0c3h9YCwgYCoqLyEoKi1kYmcpLkAoanMpYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGlzYWJsaW5nIHRoZSBgZmFzdHBhdGhzYCBvcHRpb24gZHVlIHRvIGEgcHJvYmxlbSB3aXRoIHBhcnNpbmcgc3RyaW5ncyBhcyBgLnRzYCBpbiB0aGUgcGF0dGVybiBsaWtlIGAqKi8hKCouZCkudHNgLlxuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UocmVzdCwgeyAuLi5vcHRpb25zLCBmYXN0cGF0aHM6IGZhbHNlIH0pLm91dHB1dDtcblxuICAgICAgICBvdXRwdXQgPSB0b2tlbi5jbG9zZSA9IGApJHtleHByZXNzaW9ufSkke2V4dGdsb2JTdGFyfSlgO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ucHJldi50eXBlID09PSAnYm9zJykge1xuICAgICAgICBzdGF0ZS5uZWdhdGVkRXh0Z2xvYiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVzaCh7IHR5cGU6ICdwYXJlbicsIGV4dGdsb2I6IHRydWUsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgZGVjcmVtZW50KCdwYXJlbnMnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmFzdCBwYXRoc1xuICAgKi9cblxuICBpZiAob3B0cy5mYXN0cGF0aHMgIT09IGZhbHNlICYmICEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KGlucHV0KSkge1xuICAgIGxldCBiYWNrc2xhc2hlcyA9IGZhbHNlO1xuXG4gICAgbGV0IG91dHB1dCA9IGlucHV0LnJlcGxhY2UoUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGLCAobSwgZXNjLCBjaGFycywgZmlyc3QsIHJlc3QsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZmlyc3QgPT09ICdcXFxcJykge1xuICAgICAgICBiYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3QgPT09ICc/Jykge1xuICAgICAgICBpZiAoZXNjKSB7XG4gICAgICAgICAgcmV0dXJuIGVzYyArIGZpcnN0ICsgKHJlc3QgPyBRTUFSSy5yZXBlYXQocmVzdC5sZW5ndGgpIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBxbWFya05vRG90ICsgKHJlc3QgPyBRTUFSSy5yZXBlYXQocmVzdC5sZW5ndGgpIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRTUFSSy5yZXBlYXQoY2hhcnMubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0ID09PSAnLicpIHtcbiAgICAgICAgcmV0dXJuIERPVF9MSVRFUkFMLnJlcGVhdChjaGFycy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3QgPT09ICcqJykge1xuICAgICAgICBpZiAoZXNjKSB7XG4gICAgICAgICAgcmV0dXJuIGVzYyArIGZpcnN0ICsgKHJlc3QgPyBzdGFyIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVzYyA/IG0gOiBgXFxcXCR7bX1gO1xuICAgIH0pO1xuXG4gICAgaWYgKGJhY2tzbGFzaGVzID09PSB0cnVlKSB7XG4gICAgICBpZiAob3B0cy51bmVzY2FwZSA9PT0gdHJ1ZSkge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvXFxcXCsvZywgbSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG0ubGVuZ3RoICUgMiA9PT0gMCA/ICdcXFxcXFxcXCcgOiAobSA/ICdcXFxcJyA6ICcnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dCA9PT0gaW5wdXQgJiYgb3B0cy5jb250YWlucyA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdGUub3V0cHV0ID0gaW5wdXQ7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMud3JhcE91dHB1dChvdXRwdXQsIHN0YXRlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogVG9rZW5pemUgaW5wdXQgdW50aWwgd2UgcmVhY2ggZW5kLW9mLXN0cmluZ1xuICAgKi9cblxuICB3aGlsZSAoIWVvcygpKSB7XG4gICAgdmFsdWUgPSBhZHZhbmNlKCk7XG5cbiAgICBpZiAodmFsdWUgPT09ICdcXHUwMDAwJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlZCBjaGFyYWN0ZXJzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICdcXFxcJykge1xuICAgICAgY29uc3QgbmV4dCA9IHBlZWsoKTtcblxuICAgICAgaWYgKG5leHQgPT09ICcvJyAmJiBvcHRzLmJhc2ggIT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0ID09PSAnLicgfHwgbmV4dCA9PT0gJzsnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgdmFsdWUgKz0gJ1xcXFwnO1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbGxhcHNlIHNsYXNoZXMgdG8gcmVkdWNlIHBvdGVudGlhbCBmb3IgZXhwbG9pdHNcbiAgICAgIGNvbnN0IG1hdGNoID0gL15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7XG4gICAgICBsZXQgc2xhc2hlcyA9IDA7XG5cbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFswXS5sZW5ndGggPiAyKSB7XG4gICAgICAgIHNsYXNoZXMgPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLmluZGV4ICs9IHNsYXNoZXM7XG4gICAgICAgIGlmIChzbGFzaGVzICUgMiAhPT0gMCkge1xuICAgICAgICAgIHZhbHVlICs9ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy51bmVzY2FwZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YWx1ZSA9IGFkdmFuY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlICs9IGFkdmFuY2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmJyYWNrZXRzID09PSAwKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSBpbnNpZGUgYSByZWdleCBjaGFyYWN0ZXIgY2xhc3MsIGNvbnRpbnVlXG4gICAgICogdW50aWwgd2UgcmVhY2ggdGhlIGNsb3NpbmcgYnJhY2tldC5cbiAgICAgKi9cblxuICAgIGlmIChzdGF0ZS5icmFja2V0cyA+IDAgJiYgKHZhbHVlICE9PSAnXScgfHwgcHJldi52YWx1ZSA9PT0gJ1snIHx8IHByZXYudmFsdWUgPT09ICdbXicpKSB7XG4gICAgICBpZiAob3B0cy5wb3NpeCAhPT0gZmFsc2UgJiYgdmFsdWUgPT09ICc6Jykge1xuICAgICAgICBjb25zdCBpbm5lciA9IHByZXYudmFsdWUuc2xpY2UoMSk7XG4gICAgICAgIGlmIChpbm5lci5pbmNsdWRlcygnWycpKSB7XG4gICAgICAgICAgcHJldi5wb3NpeCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoaW5uZXIuaW5jbHVkZXMoJzonKSkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gcHJldi52YWx1ZS5sYXN0SW5kZXhPZignWycpO1xuICAgICAgICAgICAgY29uc3QgcHJlID0gcHJldi52YWx1ZS5zbGljZSgwLCBpZHgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHByZXYudmFsdWUuc2xpY2UoaWR4ICsgMik7XG4gICAgICAgICAgICBjb25zdCBwb3NpeCA9IFBPU0lYX1JFR0VYX1NPVVJDRVtyZXN0XTtcbiAgICAgICAgICAgIGlmIChwb3NpeCkge1xuICAgICAgICAgICAgICBwcmV2LnZhbHVlID0gcHJlICsgcG9zaXg7XG4gICAgICAgICAgICAgIHN0YXRlLmJhY2t0cmFjayA9IHRydWU7XG4gICAgICAgICAgICAgIGFkdmFuY2UoKTtcblxuICAgICAgICAgICAgICBpZiAoIWJvcy5vdXRwdXQgJiYgdG9rZW5zLmluZGV4T2YocHJldikgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBib3Mub3V0cHV0ID0gT05FX0NIQVI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgodmFsdWUgPT09ICdbJyAmJiBwZWVrKCkgIT09ICc6JykgfHwgKHZhbHVlID09PSAnLScgJiYgcGVlaygpID09PSAnXScpKSB7XG4gICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gJ10nICYmIChwcmV2LnZhbHVlID09PSAnWycgfHwgcHJldi52YWx1ZSA9PT0gJ1teJykpIHtcbiAgICAgICAgdmFsdWUgPSBgXFxcXCR7dmFsdWV9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMucG9zaXggPT09IHRydWUgJiYgdmFsdWUgPT09ICchJyAmJiBwcmV2LnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgdmFsdWUgPSAnXic7XG4gICAgICB9XG5cbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICBhcHBlbmQoeyB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHdlJ3JlIGluc2lkZSBhIHF1b3RlZCBzdHJpbmcsIGNvbnRpbnVlXG4gICAgICogdW50aWwgd2UgcmVhY2ggdGhlIGNsb3NpbmcgZG91YmxlIHF1b3RlLlxuICAgICAqL1xuXG4gICAgaWYgKHN0YXRlLnF1b3RlcyA9PT0gMSAmJiB2YWx1ZSAhPT0gJ1wiJykge1xuICAgICAgdmFsdWUgPSB1dGlscy5lc2NhcGVSZWdleCh2YWx1ZSk7XG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgYXBwZW5kKHsgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3VibGUgcXVvdGVzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICdcIicpIHtcbiAgICAgIHN0YXRlLnF1b3RlcyA9IHN0YXRlLnF1b3RlcyA9PT0gMSA/IDAgOiAxO1xuICAgICAgaWYgKG9wdHMua2VlcFF1b3RlcyA9PT0gdHJ1ZSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcmVudGhlc2VzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcoJykge1xuICAgICAgaW5jcmVtZW50KCdwYXJlbnMnKTtcbiAgICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gJyknKSB7XG4gICAgICBpZiAoc3RhdGUucGFyZW5zID09PSAwICYmIG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdvcGVuaW5nJywgJygnKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGdsb2IgPSBleHRnbG9ic1tleHRnbG9icy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChleHRnbG9iICYmIHN0YXRlLnBhcmVucyA9PT0gZXh0Z2xvYi5wYXJlbnMgKyAxKSB7XG4gICAgICAgIGV4dGdsb2JDbG9zZShleHRnbG9icy5wb3AoKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgdmFsdWUsIG91dHB1dDogc3RhdGUucGFyZW5zID8gJyknIDogJ1xcXFwpJyB9KTtcbiAgICAgIGRlY3JlbWVudCgncGFyZW5zJyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcXVhcmUgYnJhY2tldHNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ1snKSB7XG4gICAgICBpZiAob3B0cy5ub2JyYWNrZXQgPT09IHRydWUgfHwgIXJlbWFpbmluZygpLmluY2x1ZGVzKCddJykpIHtcbiAgICAgICAgaWYgKG9wdHMubm9icmFja2V0ICE9PSB0cnVlICYmIG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ2Nsb3NpbmcnLCAnXScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmNyZW1lbnQoJ2JyYWNrZXRzJyk7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnYnJhY2tldCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnXScpIHtcbiAgICAgIGlmIChvcHRzLm5vYnJhY2tldCA9PT0gdHJ1ZSB8fCAocHJldiAmJiBwcmV2LnR5cGUgPT09ICdicmFja2V0JyAmJiBwcmV2LnZhbHVlLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogYFxcXFwke3ZhbHVlfWAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuYnJhY2tldHMgPT09IDApIHtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ29wZW5pbmcnLCAnWycpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQ6IGBcXFxcJHt2YWx1ZX1gIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGVjcmVtZW50KCdicmFja2V0cycpO1xuXG4gICAgICBjb25zdCBwcmV2VmFsdWUgPSBwcmV2LnZhbHVlLnNsaWNlKDEpO1xuICAgICAgaWYgKHByZXYucG9zaXggIT09IHRydWUgJiYgcHJldlZhbHVlWzBdID09PSAnXicgJiYgIXByZXZWYWx1ZS5pbmNsdWRlcygnLycpKSB7XG4gICAgICAgIHZhbHVlID0gYC8ke3ZhbHVlfWA7XG4gICAgICB9XG5cbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICBhcHBlbmQoeyB2YWx1ZSB9KTtcblxuICAgICAgLy8gd2hlbiBsaXRlcmFsIGJyYWNrZXRzIGFyZSBleHBsaWNpdGx5IGRpc2FibGVkXG4gICAgICAvLyBhc3N1bWUgd2Ugc2hvdWxkIG1hdGNoIHdpdGggYSByZWdleCBjaGFyYWN0ZXIgY2xhc3NcbiAgICAgIGlmIChvcHRzLmxpdGVyYWxCcmFja2V0cyA9PT0gZmFsc2UgfHwgdXRpbHMuaGFzUmVnZXhDaGFycyhwcmV2VmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlc2NhcGVkID0gdXRpbHMuZXNjYXBlUmVnZXgocHJldi52YWx1ZSk7XG4gICAgICBzdGF0ZS5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQuc2xpY2UoMCwgLXByZXYudmFsdWUubGVuZ3RoKTtcblxuICAgICAgLy8gd2hlbiBsaXRlcmFsIGJyYWNrZXRzIGFyZSBleHBsaWNpdGx5IGVuYWJsZWRcbiAgICAgIC8vIGFzc3VtZSB3ZSBzaG91bGQgZXNjYXBlIHRoZSBicmFja2V0cyB0byBtYXRjaCBsaXRlcmFsIGNoYXJhY3RlcnNcbiAgICAgIGlmIChvcHRzLmxpdGVyYWxCcmFja2V0cyA9PT0gdHJ1ZSkge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gZXNjYXBlZDtcbiAgICAgICAgcHJldi52YWx1ZSA9IGVzY2FwZWQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIHRoZSB1c2VyIHNwZWNpZmllcyBub3RoaW5nLCB0cnkgdG8gbWF0Y2ggYm90aFxuICAgICAgcHJldi52YWx1ZSA9IGAoJHtjYXB0dXJlfSR7ZXNjYXBlZH18JHtwcmV2LnZhbHVlfSlgO1xuICAgICAgc3RhdGUub3V0cHV0ICs9IHByZXYudmFsdWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCcmFjZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ3snICYmIG9wdHMubm9icmFjZSAhPT0gdHJ1ZSkge1xuICAgICAgaW5jcmVtZW50KCdicmFjZXMnKTtcblxuICAgICAgY29uc3Qgb3BlbiA9IHtcbiAgICAgICAgdHlwZTogJ2JyYWNlJyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG91dHB1dDogJygnLFxuICAgICAgICBvdXRwdXRJbmRleDogc3RhdGUub3V0cHV0Lmxlbmd0aCxcbiAgICAgICAgdG9rZW5zSW5kZXg6IHN0YXRlLnRva2Vucy5sZW5ndGhcbiAgICAgIH07XG5cbiAgICAgIGJyYWNlcy5wdXNoKG9wZW4pO1xuICAgICAgcHVzaChvcGVuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gJ30nKSB7XG4gICAgICBjb25zdCBicmFjZSA9IGJyYWNlc1ticmFjZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChvcHRzLm5vYnJhY2UgPT09IHRydWUgfHwgIWJyYWNlKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQ6IHZhbHVlIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dHB1dCA9ICcpJztcblxuICAgICAgaWYgKGJyYWNlLmRvdHMgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgYXJyID0gdG9rZW5zLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgICBpZiAoYXJyW2ldLnR5cGUgPT09ICdicmFjZScpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXJyW2ldLnR5cGUgIT09ICdkb3RzJykge1xuICAgICAgICAgICAgcmFuZ2UudW5zaGlmdChhcnJbaV0udmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCA9IGV4cGFuZFJhbmdlKHJhbmdlLCBvcHRzKTtcbiAgICAgICAgc3RhdGUuYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJyYWNlLmNvbW1hICE9PSB0cnVlICYmIGJyYWNlLmRvdHMgIT09IHRydWUpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIGJyYWNlLm91dHB1dEluZGV4KTtcbiAgICAgICAgY29uc3QgdG9rcyA9IHN0YXRlLnRva2Vucy5zbGljZShicmFjZS50b2tlbnNJbmRleCk7XG4gICAgICAgIGJyYWNlLnZhbHVlID0gYnJhY2Uub3V0cHV0ID0gJ1xcXFx7JztcbiAgICAgICAgdmFsdWUgPSBvdXRwdXQgPSAnXFxcXH0nO1xuICAgICAgICBzdGF0ZS5vdXRwdXQgPSBvdXQ7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0b2tzKSB7XG4gICAgICAgICAgc3RhdGUub3V0cHV0ICs9ICh0Lm91dHB1dCB8fCB0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ2JyYWNlJywgdmFsdWUsIG91dHB1dCB9KTtcbiAgICAgIGRlY3JlbWVudCgnYnJhY2VzJyk7XG4gICAgICBicmFjZXMucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQaXBlc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnfCcpIHtcbiAgICAgIGlmIChleHRnbG9icy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV4dGdsb2JzW2V4dGdsb2JzLmxlbmd0aCAtIDFdLmNvbmRpdGlvbnMrKztcbiAgICAgIH1cbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tbWFzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcsJykge1xuICAgICAgbGV0IG91dHB1dCA9IHZhbHVlO1xuXG4gICAgICBjb25zdCBicmFjZSA9IGJyYWNlc1ticmFjZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYnJhY2UgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09ICdicmFjZXMnKSB7XG4gICAgICAgIGJyYWNlLmNvbW1hID0gdHJ1ZTtcbiAgICAgICAgb3V0cHV0ID0gJ3wnO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ2NvbW1hJywgdmFsdWUsIG91dHB1dCB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNsYXNoZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJy8nKSB7XG4gICAgICAvLyBpZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbG9iIGlzIFwiLi9cIiwgYWR2YW5jZSB0aGUgc3RhcnRcbiAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGluZGV4LCBhbmQgZG9uJ3QgYWRkIHRoZSBcIi4vXCIgY2hhcmFjdGVyc1xuICAgICAgLy8gdG8gdGhlIHN0YXRlLiBUaGlzIGdyZWF0bHkgc2ltcGxpZmllcyBsb29rYmVoaW5kcyB3aGVuXG4gICAgICAvLyBjaGVja2luZyBmb3IgQk9TIGNoYXJhY3RlcnMgbGlrZSBcIiFcIiBhbmQgXCIuXCIgKG5vdCBcIi4vXCIpXG4gICAgICBpZiAocHJldi50eXBlID09PSAnZG90JyAmJiBzdGF0ZS5pbmRleCA9PT0gc3RhdGUuc3RhcnQgKyAxKSB7XG4gICAgICAgIHN0YXRlLnN0YXJ0ID0gc3RhdGUuaW5kZXggKyAxO1xuICAgICAgICBzdGF0ZS5jb25zdW1lZCA9ICcnO1xuICAgICAgICBzdGF0ZS5vdXRwdXQgPSAnJztcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBwcmV2ID0gYm9zOyAvLyByZXNldCBcInByZXZcIiB0byB0aGUgZmlyc3QgdG9rZW5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnc2xhc2gnLCB2YWx1ZSwgb3V0cHV0OiBTTEFTSF9MSVRFUkFMIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG90c1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnLicpIHtcbiAgICAgIGlmIChzdGF0ZS5icmFjZXMgPiAwICYmIHByZXYudHlwZSA9PT0gJ2RvdCcpIHtcbiAgICAgICAgaWYgKHByZXYudmFsdWUgPT09ICcuJykgcHJldi5vdXRwdXQgPSBET1RfTElURVJBTDtcbiAgICAgICAgY29uc3QgYnJhY2UgPSBicmFjZXNbYnJhY2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICBwcmV2LnR5cGUgPSAnZG90cyc7XG4gICAgICAgIHByZXYub3V0cHV0ICs9IHZhbHVlO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICBicmFjZS5kb3RzID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoc3RhdGUuYnJhY2VzICsgc3RhdGUucGFyZW5zKSA9PT0gMCAmJiBwcmV2LnR5cGUgIT09ICdib3MnICYmIHByZXYudHlwZSAhPT0gJ3NsYXNoJykge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0OiBET1RfTElURVJBTCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnZG90JywgdmFsdWUsIG91dHB1dDogRE9UX0xJVEVSQUwgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWVzdGlvbiBtYXJrc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnPycpIHtcbiAgICAgIGNvbnN0IGlzR3JvdXAgPSBwcmV2ICYmIHByZXYudmFsdWUgPT09ICcoJztcbiAgICAgIGlmICghaXNHcm91cCAmJiBvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiBwZWVrKCkgPT09ICcoJyAmJiBwZWVrKDIpICE9PSAnPycpIHtcbiAgICAgICAgZXh0Z2xvYk9wZW4oJ3FtYXJrJywgdmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSAncGFyZW4nKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBwZWVrKCk7XG4gICAgICAgIGxldCBvdXRwdXQgPSB2YWx1ZTtcblxuICAgICAgICBpZiAobmV4dCA9PT0gJzwnICYmICF1dGlscy5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUuanMgdjEwIG9yIGhpZ2hlciBpcyByZXF1aXJlZCBmb3IgcmVnZXggbG9va2JlaGluZHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgocHJldi52YWx1ZSA9PT0gJygnICYmICEvWyE9PDpdLy50ZXN0KG5leHQpKSB8fCAobmV4dCA9PT0gJzwnICYmICEvPChbIT1dfFxcdys+KS8udGVzdChyZW1haW5pbmcoKSkpKSB7XG4gICAgICAgICAgb3V0cHV0ID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0IH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuZG90ICE9PSB0cnVlICYmIChwcmV2LnR5cGUgPT09ICdzbGFzaCcgfHwgcHJldi50eXBlID09PSAnYm9zJykpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdxbWFyaycsIHZhbHVlLCBvdXRwdXQ6IFFNQVJLX05PX0RPVCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAncW1hcmsnLCB2YWx1ZSwgb3V0cHV0OiBRTUFSSyB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4Y2xhbWF0aW9uXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICchJykge1xuICAgICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIHBlZWsoKSA9PT0gJygnKSB7XG4gICAgICAgIGlmIChwZWVrKDIpICE9PSAnPycgfHwgIS9bIT08Ol0vLnRlc3QocGVlaygzKSkpIHtcbiAgICAgICAgICBleHRnbG9iT3BlbignbmVnYXRlJywgdmFsdWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLm5vbmVnYXRlICE9PSB0cnVlICYmIHN0YXRlLmluZGV4ID09PSAwKSB7XG4gICAgICAgIG5lZ2F0ZSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbHVzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcrJykge1xuICAgICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIHBlZWsoKSA9PT0gJygnICYmIHBlZWsoMikgIT09ICc/Jykge1xuICAgICAgICBleHRnbG9iT3BlbigncGx1cycsIHZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgocHJldiAmJiBwcmV2LnZhbHVlID09PSAnKCcpIHx8IG9wdHMucmVnZXggPT09IGZhbHNlKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAncGx1cycsIHZhbHVlLCBvdXRwdXQ6IFBMVVNfTElURVJBTCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgocHJldiAmJiAocHJldi50eXBlID09PSAnYnJhY2tldCcgfHwgcHJldi50eXBlID09PSAncGFyZW4nIHx8IHByZXYudHlwZSA9PT0gJ2JyYWNlJykpIHx8IHN0YXRlLnBhcmVucyA+IDApIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdwbHVzJywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3BsdXMnLCB2YWx1ZTogUExVU19MSVRFUkFMIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhaW4gdGV4dFxuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnQCcpIHtcbiAgICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiBwZWVrKCkgPT09ICcoJyAmJiBwZWVrKDIpICE9PSAnPycpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdhdCcsIGV4dGdsb2I6IHRydWUsIHZhbHVlLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0XG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgIT09ICcqJykge1xuICAgICAgaWYgKHZhbHVlID09PSAnJCcgfHwgdmFsdWUgPT09ICdeJykge1xuICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaCA9IFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTLmV4ZWMocmVtYWluaW5nKCkpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhbHVlICs9IG1hdGNoWzBdO1xuICAgICAgICBzdGF0ZS5pbmRleCArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnNcbiAgICAgKi9cblxuICAgIGlmIChwcmV2ICYmIChwcmV2LnR5cGUgPT09ICdnbG9ic3RhcicgfHwgcHJldi5zdGFyID09PSB0cnVlKSkge1xuICAgICAgcHJldi50eXBlID0gJ3N0YXInO1xuICAgICAgcHJldi5zdGFyID0gdHJ1ZTtcbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICBwcmV2Lm91dHB1dCA9IHN0YXI7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdCA9IHJlbWFpbmluZygpO1xuICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiAvXlxcKFteP10vLnRlc3QocmVzdCkpIHtcbiAgICAgIGV4dGdsb2JPcGVuKCdzdGFyJywgdmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXYudHlwZSA9PT0gJ3N0YXInKSB7XG4gICAgICBpZiAob3B0cy5ub2dsb2JzdGFyID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN1bWUodmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJpb3IgPSBwcmV2LnByZXY7XG4gICAgICBjb25zdCBiZWZvcmUgPSBwcmlvci5wcmV2O1xuICAgICAgY29uc3QgaXNTdGFydCA9IHByaW9yLnR5cGUgPT09ICdzbGFzaCcgfHwgcHJpb3IudHlwZSA9PT0gJ2Jvcyc7XG4gICAgICBjb25zdCBhZnRlclN0YXIgPSBiZWZvcmUgJiYgKGJlZm9yZS50eXBlID09PSAnc3RhcicgfHwgYmVmb3JlLnR5cGUgPT09ICdnbG9ic3RhcicpO1xuXG4gICAgICBpZiAob3B0cy5iYXNoID09PSB0cnVlICYmICghaXNTdGFydCB8fCAocmVzdFswXSAmJiByZXN0WzBdICE9PSAnLycpKSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3N0YXInLCB2YWx1ZSwgb3V0cHV0OiAnJyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzQnJhY2UgPSBzdGF0ZS5icmFjZXMgPiAwICYmIChwcmlvci50eXBlID09PSAnY29tbWEnIHx8IHByaW9yLnR5cGUgPT09ICdicmFjZScpO1xuICAgICAgY29uc3QgaXNFeHRnbG9iID0gZXh0Z2xvYnMubGVuZ3RoICYmIChwcmlvci50eXBlID09PSAncGlwZScgfHwgcHJpb3IudHlwZSA9PT0gJ3BhcmVuJyk7XG4gICAgICBpZiAoIWlzU3RhcnQgJiYgcHJpb3IudHlwZSAhPT0gJ3BhcmVuJyAmJiAhaXNCcmFjZSAmJiAhaXNFeHRnbG9iKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAnc3RhcicsIHZhbHVlLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RyaXAgY29uc2VjdXRpdmUgYC8qKi9gXG4gICAgICB3aGlsZSAocmVzdC5zbGljZSgwLCAzKSA9PT0gJy8qKicpIHtcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSBpbnB1dFtzdGF0ZS5pbmRleCArIDRdO1xuICAgICAgICBpZiAoYWZ0ZXIgJiYgYWZ0ZXIgIT09ICcvJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDMpO1xuICAgICAgICBjb25zdW1lKCcvKionLCAzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW9yLnR5cGUgPT09ICdib3MnICYmIGVvcygpKSB7XG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIHByZXYub3V0cHV0ID0gZ2xvYnN0YXIob3B0cyk7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHByZXYub3V0cHV0O1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICAgIGNvbnN1bWUodmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW9yLnR5cGUgPT09ICdzbGFzaCcgJiYgcHJpb3IucHJldi50eXBlICE9PSAnYm9zJyAmJiAhYWZ0ZXJTdGFyICYmIGVvcygpKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtKHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0KS5sZW5ndGgpO1xuICAgICAgICBwcmlvci5vdXRwdXQgPSBgKD86JHtwcmlvci5vdXRwdXR9YDtcblxuICAgICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IGdsb2JzdGFyKG9wdHMpICsgKG9wdHMuc3RyaWN0U2xhc2hlcyA/ICcpJyA6ICd8JCknKTtcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQ7XG4gICAgICAgIGNvbnN1bWUodmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW9yLnR5cGUgPT09ICdzbGFzaCcgJiYgcHJpb3IucHJldi50eXBlICE9PSAnYm9zJyAmJiByZXN0WzBdID09PSAnLycpIHtcbiAgICAgICAgY29uc3QgZW5kID0gcmVzdFsxXSAhPT0gdm9pZCAwID8gJ3wkJyA6ICcnO1xuXG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtKHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0KS5sZW5ndGgpO1xuICAgICAgICBwcmlvci5vdXRwdXQgPSBgKD86JHtwcmlvci5vdXRwdXR9YDtcblxuICAgICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IGAke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH18JHtTTEFTSF9MSVRFUkFMfSR7ZW5kfSlgO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuXG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBwcmlvci5vdXRwdXQgKyBwcmV2Lm91dHB1dDtcbiAgICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN1bWUodmFsdWUgKyBhZHZhbmNlKCkpO1xuXG4gICAgICAgIHB1c2goeyB0eXBlOiAnc2xhc2gnLCB2YWx1ZTogJy8nLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW9yLnR5cGUgPT09ICdib3MnICYmIHJlc3RbMF0gPT09ICcvJykge1xuICAgICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IGAoPzpefCR7U0xBU0hfTElURVJBTH18JHtnbG9ic3RhcihvcHRzKX0ke1NMQVNIX0xJVEVSQUx9KWA7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHByZXYub3V0cHV0O1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICAgIGNvbnN1bWUodmFsdWUgKyBhZHZhbmNlKCkpO1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3NsYXNoJywgdmFsdWU6ICcvJywgb3V0cHV0OiAnJyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBzaW5nbGUgc3RhciBmcm9tIG91dHB1dFxuICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC1wcmV2Lm91dHB1dC5sZW5ndGgpO1xuXG4gICAgICAvLyByZXNldCBwcmV2aW91cyB0b2tlbiB0byBnbG9ic3RhclxuICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcbiAgICAgIHByZXYub3V0cHV0ID0gZ2xvYnN0YXIob3B0cyk7XG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuXG4gICAgICAvLyByZXNldCBvdXRwdXQgd2l0aCBnbG9ic3RhclxuICAgICAgc3RhdGUub3V0cHV0ICs9IHByZXYub3V0cHV0O1xuICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbiA9IHsgdHlwZTogJ3N0YXInLCB2YWx1ZSwgb3V0cHV0OiBzdGFyIH07XG5cbiAgICBpZiAob3B0cy5iYXNoID09PSB0cnVlKSB7XG4gICAgICB0b2tlbi5vdXRwdXQgPSAnLio/JztcbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdib3MnIHx8IHByZXYudHlwZSA9PT0gJ3NsYXNoJykge1xuICAgICAgICB0b2tlbi5vdXRwdXQgPSBub2RvdCArIHRva2VuLm91dHB1dDtcbiAgICAgIH1cbiAgICAgIHB1c2godG9rZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXYgJiYgKHByZXYudHlwZSA9PT0gJ2JyYWNrZXQnIHx8IHByZXYudHlwZSA9PT0gJ3BhcmVuJykgJiYgb3B0cy5yZWdleCA9PT0gdHJ1ZSkge1xuICAgICAgdG9rZW4ub3V0cHV0ID0gdmFsdWU7XG4gICAgICBwdXNoKHRva2VuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5pbmRleCA9PT0gc3RhdGUuc3RhcnQgfHwgcHJldi50eXBlID09PSAnc2xhc2gnIHx8IHByZXYudHlwZSA9PT0gJ2RvdCcpIHtcbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBOT19ET1RfU0xBU0g7XG4gICAgICAgIHByZXYub3V0cHV0ICs9IE5PX0RPVF9TTEFTSDtcblxuICAgICAgfSBlbHNlIGlmIChvcHRzLmRvdCA9PT0gdHJ1ZSkge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gTk9fRE9UU19TTEFTSDtcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gTk9fRE9UU19TTEFTSDtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IG5vZG90O1xuICAgICAgICBwcmV2Lm91dHB1dCArPSBub2RvdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBlZWsoKSAhPT0gJyonKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBPTkVfQ0hBUjtcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gT05FX0NIQVI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVzaCh0b2tlbik7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUuYnJhY2tldHMgPiAwKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICddJykpO1xuICAgIHN0YXRlLm91dHB1dCA9IHV0aWxzLmVzY2FwZUxhc3Qoc3RhdGUub3V0cHV0LCAnWycpO1xuICAgIGRlY3JlbWVudCgnYnJhY2tldHMnKTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5wYXJlbnMgPiAwKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICcpJykpO1xuICAgIHN0YXRlLm91dHB1dCA9IHV0aWxzLmVzY2FwZUxhc3Qoc3RhdGUub3V0cHV0LCAnKCcpO1xuICAgIGRlY3JlbWVudCgncGFyZW5zJyk7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUuYnJhY2VzID4gMCkge1xuICAgIGlmIChvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ2Nsb3NpbmcnLCAnfScpKTtcbiAgICBzdGF0ZS5vdXRwdXQgPSB1dGlscy5lc2NhcGVMYXN0KHN0YXRlLm91dHB1dCwgJ3snKTtcbiAgICBkZWNyZW1lbnQoJ2JyYWNlcycpO1xuICB9XG5cbiAgaWYgKG9wdHMuc3RyaWN0U2xhc2hlcyAhPT0gdHJ1ZSAmJiAocHJldi50eXBlID09PSAnc3RhcicgfHwgcHJldi50eXBlID09PSAnYnJhY2tldCcpKSB7XG4gICAgcHVzaCh7IHR5cGU6ICdtYXliZV9zbGFzaCcsIHZhbHVlOiAnJywgb3V0cHV0OiBgJHtTTEFTSF9MSVRFUkFMfT9gIH0pO1xuICB9XG5cbiAgLy8gcmVidWlsZCB0aGUgb3V0cHV0IGlmIHdlIGhhZCB0byBiYWNrdHJhY2sgYXQgYW55IHBvaW50XG4gIGlmIChzdGF0ZS5iYWNrdHJhY2sgPT09IHRydWUpIHtcbiAgICBzdGF0ZS5vdXRwdXQgPSAnJztcblxuICAgIGZvciAoY29uc3QgdG9rZW4gb2Ygc3RhdGUudG9rZW5zKSB7XG4gICAgICBzdGF0ZS5vdXRwdXQgKz0gdG9rZW4ub3V0cHV0ICE9IG51bGwgPyB0b2tlbi5vdXRwdXQgOiB0b2tlbi52YWx1ZTtcblxuICAgICAgaWYgKHRva2VuLnN1ZmZpeCkge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gdG9rZW4uc3VmZml4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn07XG5cbi8qKlxuICogRmFzdCBwYXRocyBmb3IgY3JlYXRpbmcgcmVndWxhciBleHByZXNzaW9ucyBmb3IgY29tbW9uIGdsb2IgcGF0dGVybnMuXG4gKiBUaGlzIGNhbiBzaWduaWZpY2FudGx5IHNwZWVkIHVwIHByb2Nlc3NpbmcgYW5kIGhhcyB2ZXJ5IGxpdHRsZSBkb3duc2lkZVxuICogaW1wYWN0IHdoZW4gbm9uZSBvZiB0aGUgZmFzdCBwYXRocyBtYXRjaC5cbiAqL1xuXG5wYXJzZS5mYXN0cGF0aHMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucyB9O1xuICBjb25zdCBtYXggPSB0eXBlb2Ygb3B0cy5tYXhMZW5ndGggPT09ICdudW1iZXInID8gTWF0aC5taW4oTUFYX0xFTkdUSCwgb3B0cy5tYXhMZW5ndGgpIDogTUFYX0xFTkdUSDtcbiAgY29uc3QgbGVuID0gaW5wdXQubGVuZ3RoO1xuICBpZiAobGVuID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7bGVufSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke21heH1gKTtcbiAgfVxuXG4gIGlucHV0ID0gUkVQTEFDRU1FTlRTW2lucHV0XSB8fCBpbnB1dDtcbiAgY29uc3Qgd2luMzIgPSB1dGlscy5pc1dpbmRvd3Mob3B0aW9ucyk7XG5cbiAgLy8gY3JlYXRlIGNvbnN0YW50cyBiYXNlZCBvbiBwbGF0Zm9ybSwgZm9yIHdpbmRvd3Mgb3IgcG9zaXhcbiAgY29uc3Qge1xuICAgIERPVF9MSVRFUkFMLFxuICAgIFNMQVNIX0xJVEVSQUwsXG4gICAgT05FX0NIQVIsXG4gICAgRE9UU19TTEFTSCxcbiAgICBOT19ET1QsXG4gICAgTk9fRE9UUyxcbiAgICBOT19ET1RTX1NMQVNILFxuICAgIFNUQVIsXG4gICAgU1RBUlRfQU5DSE9SXG4gIH0gPSBjb25zdGFudHMuZ2xvYkNoYXJzKHdpbjMyKTtcblxuICBjb25zdCBub2RvdCA9IG9wdHMuZG90ID8gTk9fRE9UUyA6IE5PX0RPVDtcbiAgY29uc3Qgc2xhc2hEb3QgPSBvcHRzLmRvdCA/IE5PX0RPVFNfU0xBU0ggOiBOT19ET1Q7XG4gIGNvbnN0IGNhcHR1cmUgPSBvcHRzLmNhcHR1cmUgPyAnJyA6ICc/Oic7XG4gIGNvbnN0IHN0YXRlID0geyBuZWdhdGVkOiBmYWxzZSwgcHJlZml4OiAnJyB9O1xuICBsZXQgc3RhciA9IG9wdHMuYmFzaCA9PT0gdHJ1ZSA/ICcuKj8nIDogU1RBUjtcblxuICBpZiAob3B0cy5jYXB0dXJlKSB7XG4gICAgc3RhciA9IGAoJHtzdGFyfSlgO1xuICB9XG5cbiAgY29uc3QgZ2xvYnN0YXIgPSBvcHRzID0+IHtcbiAgICBpZiAob3B0cy5ub2dsb2JzdGFyID09PSB0cnVlKSByZXR1cm4gc3RhcjtcbiAgICByZXR1cm4gYCgke2NhcHR1cmV9KD86KD8hJHtTVEFSVF9BTkNIT1J9JHtvcHRzLmRvdCA/IERPVFNfU0xBU0ggOiBET1RfTElURVJBTH0pLikqPylgO1xuICB9O1xuXG4gIGNvbnN0IGNyZWF0ZSA9IHN0ciA9PiB7XG4gICAgc3dpdGNoIChzdHIpIHtcbiAgICAgIGNhc2UgJyonOlxuICAgICAgICByZXR1cm4gYCR7bm9kb3R9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnLionOlxuICAgICAgICByZXR1cm4gYCR7RE9UX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKi4qJzpcbiAgICAgICAgcmV0dXJuIGAke25vZG90fSR7c3Rhcn0ke0RPVF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cbiAgICAgIGNhc2UgJyovKic6XG4gICAgICAgIHJldHVybiBgJHtub2RvdH0ke3N0YXJ9JHtTTEFTSF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzbGFzaERvdH0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKionOlxuICAgICAgICByZXR1cm4gbm9kb3QgKyBnbG9ic3RhcihvcHRzKTtcblxuICAgICAgY2FzZSAnKiovKic6XG4gICAgICAgIHJldHVybiBgKD86JHtub2RvdH0ke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH0pPyR7c2xhc2hEb3R9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKiovKi4qJzpcbiAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtzbGFzaERvdH0ke3N0YXJ9JHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqKi8uKic6XG4gICAgICAgIHJldHVybiBgKD86JHtub2RvdH0ke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH0pPyR7RE9UX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9eKC4qPylcXC4oXFx3KykkLy5leGVjKHN0cik7XG4gICAgICAgIGlmICghbWF0Y2gpIHJldHVybjtcblxuICAgICAgICBjb25zdCBzb3VyY2UgPSBjcmVhdGUobWF0Y2hbMV0pO1xuICAgICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuO1xuXG4gICAgICAgIHJldHVybiBzb3VyY2UgKyBET1RfTElURVJBTCArIG1hdGNoWzJdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBvdXRwdXQgPSB1dGlscy5yZW1vdmVQcmVmaXgoaW5wdXQsIHN0YXRlKTtcbiAgbGV0IHNvdXJjZSA9IGNyZWF0ZShvdXRwdXQpO1xuXG4gIGlmIChzb3VyY2UgJiYgb3B0cy5zdHJpY3RTbGFzaGVzICE9PSB0cnVlKSB7XG4gICAgc291cmNlICs9IGAke1NMQVNIX0xJVEVSQUx9P2A7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBzY2FuID0gcmVxdWlyZSgnLi9zY2FuJyk7XG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IGlzT2JqZWN0ID0gdmFsID0+IHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRjaGVyIGZ1bmN0aW9uIGZyb20gb25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucy4gVGhlXG4gKiByZXR1cm5lZCBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB0byBtYXRjaCBhcyBpdHMgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBtYXRjaC4gVGhlIHJldHVybmVkIG1hdGNoZXJcbiAqIGZ1bmN0aW9uIGFsc28gdGFrZXMgYSBib29sZWFuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdGhhdCwgd2hlbiB0cnVlLFxuICogcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaChnbG9iWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IGlzTWF0Y2ggPSBwaWNvbWF0Y2goJyouISgqYSknKTtcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYScpKTsgLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5iJykpOyAvLz0+IHRydWVcbiAqIGBgYFxuICogQG5hbWUgcGljb21hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYGdsb2JzYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zLlxuICogQHBhcmFtIHtPYmplY3Q9fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0Z1bmN0aW9uPX0gUmV0dXJucyBhIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmNvbnN0IHBpY29tYXRjaCA9IChnbG9iLCBvcHRpb25zLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGdsb2IpKSB7XG4gICAgY29uc3QgZm5zID0gZ2xvYi5tYXAoaW5wdXQgPT4gcGljb21hdGNoKGlucHV0LCBvcHRpb25zLCByZXR1cm5TdGF0ZSkpO1xuICAgIGNvbnN0IGFycmF5TWF0Y2hlciA9IHN0ciA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGlzTWF0Y2ggb2YgZm5zKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gaXNNYXRjaChzdHIpO1xuICAgICAgICBpZiAoc3RhdGUpIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheU1hdGNoZXI7XG4gIH1cblxuICBjb25zdCBpc1N0YXRlID0gaXNPYmplY3QoZ2xvYikgJiYgZ2xvYi50b2tlbnMgJiYgZ2xvYi5pbnB1dDtcblxuICBpZiAoZ2xvYiA9PT0gJycgfHwgKHR5cGVvZiBnbG9iICE9PSAnc3RyaW5nJyAmJiAhaXNTdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHBvc2l4ID0gdXRpbHMuaXNXaW5kb3dzKG9wdGlvbnMpO1xuICBjb25zdCByZWdleCA9IGlzU3RhdGVcbiAgICA/IHBpY29tYXRjaC5jb21waWxlUmUoZ2xvYiwgb3B0aW9ucylcbiAgICA6IHBpY29tYXRjaC5tYWtlUmUoZ2xvYiwgb3B0aW9ucywgZmFsc2UsIHRydWUpO1xuXG4gIGNvbnN0IHN0YXRlID0gcmVnZXguc3RhdGU7XG4gIGRlbGV0ZSByZWdleC5zdGF0ZTtcblxuICBsZXQgaXNJZ25vcmVkID0gKCkgPT4gZmFsc2U7XG4gIGlmIChvcHRzLmlnbm9yZSkge1xuICAgIGNvbnN0IGlnbm9yZU9wdHMgPSB7IC4uLm9wdGlvbnMsIGlnbm9yZTogbnVsbCwgb25NYXRjaDogbnVsbCwgb25SZXN1bHQ6IG51bGwgfTtcbiAgICBpc0lnbm9yZWQgPSBwaWNvbWF0Y2gob3B0cy5pZ25vcmUsIGlnbm9yZU9wdHMsIHJldHVyblN0YXRlKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXIgPSAoaW5wdXQsIHJldHVybk9iamVjdCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgeyBpc01hdGNoLCBtYXRjaCwgb3V0cHV0IH0gPSBwaWNvbWF0Y2gudGVzdChpbnB1dCwgcmVnZXgsIG9wdGlvbnMsIHsgZ2xvYiwgcG9zaXggfSk7XG4gICAgY29uc3QgcmVzdWx0ID0geyBnbG9iLCBzdGF0ZSwgcmVnZXgsIHBvc2l4LCBpbnB1dCwgb3V0cHV0LCBtYXRjaCwgaXNNYXRjaCB9O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzLm9uUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRzLm9uUmVzdWx0KHJlc3VsdCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTWF0Y2ggPT09IGZhbHNlKSB7XG4gICAgICByZXN1bHQuaXNNYXRjaCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJldHVybk9iamVjdCA/IHJlc3VsdCA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0lnbm9yZWQoaW5wdXQpKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMub25JZ25vcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0cy5vbklnbm9yZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXR1cm5PYmplY3QgPyByZXN1bHQgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMub25NYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0cy5vbk1hdGNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5PYmplY3QgPyByZXN1bHQgOiB0cnVlO1xuICB9O1xuXG4gIGlmIChyZXR1cm5TdGF0ZSkge1xuICAgIG1hdGNoZXIuc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVyO1xufTtcblxuLyoqXG4gKiBUZXN0IGBpbnB1dGAgd2l0aCB0aGUgZ2l2ZW4gYHJlZ2V4YC4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBtYWluXG4gKiBgcGljb21hdGNoKClgIGZ1bmN0aW9uIHRvIHRlc3QgdGhlIGlucHV0IHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2gudGVzdChpbnB1dCwgcmVnZXhbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cocGljb21hdGNoLnRlc3QoJ2Zvby9iYXInLCAvXig/OihbXi9dKj8pXFwvKFteL10qPykpJC8pKTtcbiAqIC8vIHsgaXNNYXRjaDogdHJ1ZSwgbWF0Y2g6IFsgJ2Zvby8nLCAnZm9vJywgJ2JhcicgXSwgb3V0cHV0OiAnZm9vL2JhcicgfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YCBTdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7UmVnRXhwfSBgcmVnZXhgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggbWF0Y2hpbmcgaW5mby5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLnRlc3QgPSAoaW5wdXQsIHJlZ2V4LCBvcHRpb25zLCB7IGdsb2IsIHBvc2l4IH0gPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGlucHV0IHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgcmV0dXJuIHsgaXNNYXRjaDogZmFsc2UsIG91dHB1dDogJycgfTtcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBmb3JtYXQgPSBvcHRzLmZvcm1hdCB8fCAocG9zaXggPyB1dGlscy50b1Bvc2l4U2xhc2hlcyA6IG51bGwpO1xuICBsZXQgbWF0Y2ggPSBpbnB1dCA9PT0gZ2xvYjtcbiAgbGV0IG91dHB1dCA9IChtYXRjaCAmJiBmb3JtYXQpID8gZm9ybWF0KGlucHV0KSA6IGlucHV0O1xuXG4gIGlmIChtYXRjaCA9PT0gZmFsc2UpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXQgPyBmb3JtYXQoaW5wdXQpIDogaW5wdXQ7XG4gICAgbWF0Y2ggPSBvdXRwdXQgPT09IGdsb2I7XG4gIH1cblxuICBpZiAobWF0Y2ggPT09IGZhbHNlIHx8IG9wdHMuY2FwdHVyZSA9PT0gdHJ1ZSkge1xuICAgIGlmIChvcHRzLm1hdGNoQmFzZSA9PT0gdHJ1ZSB8fCBvcHRzLmJhc2VuYW1lID09PSB0cnVlKSB7XG4gICAgICBtYXRjaCA9IHBpY29tYXRjaC5tYXRjaEJhc2UoaW5wdXQsIHJlZ2V4LCBvcHRpb25zLCBwb3NpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhvdXRwdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGlzTWF0Y2g6IEJvb2xlYW4obWF0Y2gpLCBtYXRjaCwgb3V0cHV0IH07XG59O1xuXG4vKipcbiAqIE1hdGNoIHRoZSBiYXNlbmFtZSBvZiBhIGZpbGVwYXRoLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC5tYXRjaEJhc2UoaW5wdXQsIGdsb2JbLCBvcHRpb25zXSk7XG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2gubWF0Y2hCYXNlKCdmb28vYmFyLmpzJywgJyouanMnKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YCBTdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gYGdsb2JgIEdsb2IgcGF0dGVybiBvciByZWdleCBjcmVhdGVkIGJ5IFsubWFrZVJlXSgjbWFrZVJlKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5tYXRjaEJhc2UgPSAoaW5wdXQsIGdsb2IsIG9wdGlvbnMsIHBvc2l4ID0gdXRpbHMuaXNXaW5kb3dzKG9wdGlvbnMpKSA9PiB7XG4gIGNvbnN0IHJlZ2V4ID0gZ2xvYiBpbnN0YW5jZW9mIFJlZ0V4cCA/IGdsb2IgOiBwaWNvbWF0Y2gubWFrZVJlKGdsb2IsIG9wdGlvbnMpO1xuICByZXR1cm4gcmVnZXgudGVzdChwYXRoLmJhc2VuYW1lKGlucHV0KSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiAqKmFueSoqIG9mIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuc2AgbWF0Y2ggdGhlIHNwZWNpZmllZCBgc3RyaW5nYC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2guaXNNYXRjaChzdHJpbmcsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC5pc01hdGNoKCdhLmEnLCBbJ2IuKicsICcqLmEnXSkpOyAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC5pc01hdGNoKCdhLmEnLCAnYi4qJykpOyAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBzdHIgVGhlIHN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdHRlcm5zIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpLlxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2guaXNNYXRjaCA9IChzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSA9PiBwaWNvbWF0Y2gocGF0dGVybnMsIG9wdGlvbnMpKHN0cik7XG5cbi8qKlxuICogUGFyc2UgYSBnbG9iIHBhdHRlcm4gdG8gY3JlYXRlIHRoZSBzb3VyY2Ugc3RyaW5nIGZvciBhIHJlZ3VsYXJcbiAqIGV4cHJlc3Npb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc3QgcmVzdWx0ID0gcGljb21hdGNoLnBhcnNlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VmdWwgcHJvcGVydGllcyBhbmQgb3V0cHV0IHRvIGJlIHVzZWQgYXMgYSByZWdleCBzb3VyY2Ugc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gucGFyc2UgPSAocGF0dGVybiwgb3B0aW9ucykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkgcmV0dXJuIHBhdHRlcm4ubWFwKHAgPT4gcGljb21hdGNoLnBhcnNlKHAsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHBhcnNlKHBhdHRlcm4sIHsgLi4ub3B0aW9ucywgZmFzdHBhdGhzOiBmYWxzZSB9KTtcbn07XG5cbi8qKlxuICogU2NhbiBhIGdsb2IgcGF0dGVybiB0byBzZXBhcmF0ZSB0aGUgcGF0dGVybiBpbnRvIHNlZ21lbnRzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC5zY2FuKGlucHV0Wywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IHBpY29tYXRjaC5zY2FuKCchLi9mb28vKi5qcycpO1xuICogY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIHsgcHJlZml4OiAnIS4vJyxcbiAqICAgaW5wdXQ6ICchLi9mb28vKi5qcycsXG4gKiAgIHN0YXJ0OiAzLFxuICogICBiYXNlOiAnZm9vJyxcbiAqICAgZ2xvYjogJyouanMnLFxuICogICBpc0JyYWNlOiBmYWxzZSxcbiAqICAgaXNCcmFja2V0OiBmYWxzZSxcbiAqICAgaXNHbG9iOiB0cnVlLFxuICogICBpc0V4dGdsb2I6IGZhbHNlLFxuICogICBpc0dsb2JzdGFyOiBmYWxzZSxcbiAqICAgbmVnYXRlZDogdHJ1ZSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgIEdsb2IgcGF0dGVybiB0byBzY2FuLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5zY2FuID0gKGlucHV0LCBvcHRpb25zKSA9PiBzY2FuKGlucHV0LCBvcHRpb25zKTtcblxuLyoqXG4gKiBDb21waWxlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGBzdGF0ZWAgb2JqZWN0IHJldHVybmVkIGJ5IHRoZVxuICogW3BhcnNlKCldKCNwYXJzZSkgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgc3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGByZXR1cm5PdXRwdXRgIEludGVuZGVkIGZvciBpbXBsZW1lbnRvcnMsIHRoaXMgYXJndW1lbnQgYWxsb3dzIHlvdSB0byByZXR1cm4gdGhlIHJhdyBvdXRwdXQgZnJvbSB0aGUgcGFyc2VyLlxuICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuU3RhdGVgIEFkZHMgdGhlIHN0YXRlIHRvIGEgYHN0YXRlYCBwcm9wZXJ0eSBvbiB0aGUgcmV0dXJuZWQgcmVnZXguIFVzZWZ1bCBmb3IgaW1wbGVtZW50b3JzIGFuZCBkZWJ1Z2dpbmcuXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5jb21waWxlUmUgPSAoc3RhdGUsIG9wdGlvbnMsIHJldHVybk91dHB1dCA9IGZhbHNlLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmIChyZXR1cm5PdXRwdXQgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3RhdGUub3V0cHV0O1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHByZXBlbmQgPSBvcHRzLmNvbnRhaW5zID8gJycgOiAnXic7XG4gIGNvbnN0IGFwcGVuZCA9IG9wdHMuY29udGFpbnMgPyAnJyA6ICckJztcblxuICBsZXQgc291cmNlID0gYCR7cHJlcGVuZH0oPzoke3N0YXRlLm91dHB1dH0pJHthcHBlbmR9YDtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLm5lZ2F0ZWQgPT09IHRydWUpIHtcbiAgICBzb3VyY2UgPSBgXig/ISR7c291cmNlfSkuKiRgO1xuICB9XG5cbiAgY29uc3QgcmVnZXggPSBwaWNvbWF0Y2gudG9SZWdleChzb3VyY2UsIG9wdGlvbnMpO1xuICBpZiAocmV0dXJuU3RhdGUgPT09IHRydWUpIHtcbiAgICByZWdleC5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSBhIHBhcnNlZCBnbG9iIHBhdHRlcm4uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc3Qgc3RhdGUgPSBwaWNvbWF0Y2gucGFyc2UoJyouanMnKTtcbiAqIC8vIHBpY29tYXRjaC5jb21waWxlUmUoc3RhdGVbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cocGljb21hdGNoLmNvbXBpbGVSZShzdGF0ZSkpO1xuICogLy89PiAvXig/Oig/IVxcLikoPz0uKVteL10qP1xcLmpzKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RhdGVgIFRoZSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgYC5wYXJzZWAgbWV0aG9kLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuT3V0cHV0YCBJbXBsZW1lbnRvcnMgbWF5IHVzZSB0aGlzIGFyZ3VtZW50IHRvIHJldHVybiB0aGUgY29tcGlsZWQgb3V0cHV0LCBpbnN0ZWFkIG9mIGEgcmVndWxhciBleHByZXNzaW9uLiBUaGlzIGlzIG5vdCBleHBvc2VkIG9uIHRoZSBvcHRpb25zIHRvIHByZXZlbnQgZW5kLXVzZXJzIGZyb20gbXV0YXRpbmcgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVyblN0YXRlYCBJbXBsZW1lbnRvcnMgbWF5IHVzZSB0aGlzIGFyZ3VtZW50IHRvIHJldHVybiB0aGUgc3RhdGUgZnJvbSB0aGUgcGFyc2VkIGdsb2Igd2l0aCB0aGUgcmV0dXJuZWQgcmVndWxhciBleHByZXNzaW9uLlxuICogQHJldHVybiB7UmVnRXhwfSBSZXR1cm5zIGEgcmVnZXggY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gubWFrZVJlID0gKGlucHV0LCBvcHRpb25zID0ge30sIHJldHVybk91dHB1dCA9IGZhbHNlLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgbGV0IHBhcnNlZCA9IHsgbmVnYXRlZDogZmFsc2UsIGZhc3RwYXRoczogdHJ1ZSB9O1xuXG4gIGlmIChvcHRpb25zLmZhc3RwYXRocyAhPT0gZmFsc2UgJiYgKGlucHV0WzBdID09PSAnLicgfHwgaW5wdXRbMF0gPT09ICcqJykpIHtcbiAgICBwYXJzZWQub3V0cHV0ID0gcGFyc2UuZmFzdHBhdGhzKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghcGFyc2VkLm91dHB1dCkge1xuICAgIHBhcnNlZCA9IHBhcnNlKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHBhcnNlZCwgb3B0aW9ucywgcmV0dXJuT3V0cHV0LCByZXR1cm5TdGF0ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiByZWdleCBzb3VyY2Ugc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC50b1JlZ2V4KHNvdXJjZVssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zdCB7IG91dHB1dCB9ID0gcGljb21hdGNoLnBhcnNlKCcqLmpzJyk7XG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2gudG9SZWdleChvdXRwdXQpKTtcbiAqIC8vPT4gL14oPzooPyFcXC4pKD89LilbXi9dKj9cXC5qcykkL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHNvdXJjZWAgUmVndWxhciBleHByZXNzaW9uIHNvdXJjZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC50b1JlZ2V4ID0gKHNvdXJjZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgb3B0cy5mbGFncyB8fCAob3B0cy5ub2Nhc2UgPyAnaScgOiAnJykpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnID09PSB0cnVlKSB0aHJvdyBlcnI7XG4gICAgcmV0dXJuIC8kXi87XG4gIH1cbn07XG5cbi8qKlxuICogUGljb21hdGNoIGNvbnN0YW50cy5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5waWNvbWF0Y2guY29uc3RhbnRzID0gY29uc3RhbnRzO1xuXG4vKipcbiAqIEV4cG9zZSBcInBpY29tYXRjaFwiXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwaWNvbWF0Y2g7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3BpY29tYXRjaCcpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCBzeXNQYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuXG5jb25zdCByZWFkZGlyID0gcHJvbWlzaWZ5KGZzLnJlYWRkaXIpO1xuY29uc3Qgc3RhdCA9IHByb21pc2lmeShmcy5zdGF0KTtcbmNvbnN0IGxzdGF0ID0gcHJvbWlzaWZ5KGZzLmxzdGF0KTtcbmNvbnN0IHJlYWxwYXRoID0gcHJvbWlzaWZ5KGZzLnJlYWxwYXRoKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFbnRyeUluZm9cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwYXRoXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZnVsbFBhdGhcbiAqIEBwcm9wZXJ0eSB7ZnMuU3RhdHM9fSBzdGF0c1xuICogQHByb3BlcnR5IHtmcy5EaXJlbnQ9fSBkaXJlbnRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBiYXNlbmFtZVxuICovXG5cbmNvbnN0IEJBTkcgPSAnISc7XG5jb25zdCBSRUNVUlNJVkVfRVJST1JfQ09ERSA9ICdSRUFERElSUF9SRUNVUlNJVkVfRVJST1InO1xuY29uc3QgTk9STUFMX0ZMT1dfRVJST1JTID0gbmV3IFNldChbJ0VOT0VOVCcsICdFUEVSTScsICdFQUNDRVMnLCAnRUxPT1AnLCBSRUNVUlNJVkVfRVJST1JfQ09ERV0pO1xuY29uc3QgRklMRV9UWVBFID0gJ2ZpbGVzJztcbmNvbnN0IERJUl9UWVBFID0gJ2RpcmVjdG9yaWVzJztcbmNvbnN0IEZJTEVfRElSX1RZUEUgPSAnZmlsZXNfZGlyZWN0b3JpZXMnO1xuY29uc3QgRVZFUllUSElOR19UWVBFID0gJ2FsbCc7XG5jb25zdCBBTExfVFlQRVMgPSBbRklMRV9UWVBFLCBESVJfVFlQRSwgRklMRV9ESVJfVFlQRSwgRVZFUllUSElOR19UWVBFXTtcblxuY29uc3QgaXNOb3JtYWxGbG93RXJyb3IgPSBlcnJvciA9PiBOT1JNQUxfRkxPV19FUlJPUlMuaGFzKGVycm9yLmNvZGUpO1xuY29uc3QgW21haiwgbWluXSA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpLnNsaWNlKDAsIDIpLm1hcChuID0+IE51bWJlci5wYXJzZUludChuLCAxMCkpO1xuY29uc3Qgd2FudEJpZ2ludEZzU3RhdHMgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmIChtYWogPiAxMCB8fCAobWFqID09PSAxMCAmJiBtaW4gPj0gNSkpO1xuXG5jb25zdCBub3JtYWxpemVGaWx0ZXIgPSBmaWx0ZXIgPT4ge1xuICBpZiAoZmlsdGVyID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBmaWx0ZXI7XG5cbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZ2xvYiA9IHBpY29tYXRjaChmaWx0ZXIudHJpbSgpKTtcbiAgICByZXR1cm4gZW50cnkgPT4gZ2xvYihlbnRyeS5iYXNlbmFtZSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgY29uc3QgcG9zaXRpdmUgPSBbXTtcbiAgICBjb25zdCBuZWdhdGl2ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBmaWx0ZXIpIHtcbiAgICAgIGNvbnN0IHRyaW1tZWQgPSBpdGVtLnRyaW0oKTtcbiAgICAgIGlmICh0cmltbWVkLmNoYXJBdCgwKSA9PT0gQkFORykge1xuICAgICAgICBuZWdhdGl2ZS5wdXNoKHBpY29tYXRjaCh0cmltbWVkLnNsaWNlKDEpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGl2ZS5wdXNoKHBpY29tYXRjaCh0cmltbWVkKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lZ2F0aXZlLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChwb3NpdGl2ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBlbnRyeSA9PlxuICAgICAgICAgIHBvc2l0aXZlLnNvbWUoZiA9PiBmKGVudHJ5LmJhc2VuYW1lKSkgJiYgIW5lZ2F0aXZlLnNvbWUoZiA9PiBmKGVudHJ5LmJhc2VuYW1lKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnkgPT4gIW5lZ2F0aXZlLnNvbWUoZiA9PiBmKGVudHJ5LmJhc2VuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeSA9PiBwb3NpdGl2ZS5zb21lKGYgPT4gZihlbnRyeS5iYXNlbmFtZSkpO1xuICB9XG59O1xuXG5jbGFzcyBSZWFkZGlycFN0cmVhbSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgc3RhdGljIGdldCBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDogJy4nLFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgIGZpbGVGaWx0ZXI6IChwYXRoKSA9PiB0cnVlLFxuICAgICAgZGlyZWN0b3J5RmlsdGVyOiAocGF0aCkgPT4gdHJ1ZSxcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgIHR5cGU6IEZJTEVfVFlQRSxcbiAgICAgIGxzdGF0OiBmYWxzZSxcbiAgICAgIGRlcHRoOiAyMTQ3NDgzNjQ4LFxuICAgICAgYWx3YXlzU3RhdDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgaGlnaFdhdGVyTWFyazogb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIHx8IDQwOTZcbiAgICB9KTtcbiAgICBjb25zdCBvcHRzID0geyAuLi5SZWFkZGlycFN0cmVhbS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHsgcm9vdCwgdHlwZSB9ID0gb3B0cztcblxuICAgIHRoaXMuX2ZpbGVGaWx0ZXIgPSBub3JtYWxpemVGaWx0ZXIob3B0cy5maWxlRmlsdGVyKTtcbiAgICB0aGlzLl9kaXJlY3RvcnlGaWx0ZXIgPSBub3JtYWxpemVGaWx0ZXIob3B0cy5kaXJlY3RvcnlGaWx0ZXIpO1xuXG4gICAgY29uc3Qgc3RhdE1ldGhvZCA9IG9wdHMubHN0YXQgPyBsc3RhdCA6IHN0YXQ7XG4gICAgLy8gVXNlIGJpZ2ludCBzdGF0cyBpZiBpdCdzIHdpbmRvd3MgYW5kIHN0YXQoKSBzdXBwb3J0cyBvcHRpb25zIChub2RlIDEwKykuXG4gICAgaWYgKHdhbnRCaWdpbnRGc1N0YXRzKSB7XG4gICAgICB0aGlzLl9zdGF0ID0gcGF0aCA9PiBzdGF0TWV0aG9kKHBhdGgsIHsgYmlnaW50OiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ID0gc3RhdE1ldGhvZDtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXhEZXB0aCA9IG9wdHMuZGVwdGg7XG4gICAgdGhpcy5fd2FudHNEaXIgPSBbRElSX1RZUEUsIEZJTEVfRElSX1RZUEUsIEVWRVJZVEhJTkdfVFlQRV0uaW5jbHVkZXModHlwZSk7XG4gICAgdGhpcy5fd2FudHNGaWxlID0gW0ZJTEVfVFlQRSwgRklMRV9ESVJfVFlQRSwgRVZFUllUSElOR19UWVBFXS5pbmNsdWRlcyh0eXBlKTtcbiAgICB0aGlzLl93YW50c0V2ZXJ5dGhpbmcgPSB0eXBlID09PSBFVkVSWVRISU5HX1RZUEU7XG4gICAgdGhpcy5fcm9vdCA9IHN5c1BhdGgucmVzb2x2ZShyb290KTtcbiAgICB0aGlzLl9pc0RpcmVudCA9ICgnRGlyZW50JyBpbiBmcykgJiYgIW9wdHMuYWx3YXlzU3RhdDtcbiAgICB0aGlzLl9zdGF0c1Byb3AgPSB0aGlzLl9pc0RpcmVudCA/ICdkaXJlbnQnIDogJ3N0YXRzJztcbiAgICB0aGlzLl9yZE9wdGlvbnMgPSB7IGVuY29kaW5nOiAndXRmOCcsIHdpdGhGaWxlVHlwZXM6IHRoaXMuX2lzRGlyZW50IH07XG5cbiAgICAvLyBMYXVuY2ggc3RyZWFtIHdpdGggb25lIHBhcmVudCwgdGhlIHJvb3QgZGlyLlxuICAgIHRoaXMucGFyZW50cyA9IFt0aGlzLl9leHBsb3JlRGlyKHJvb3QsIDEpXTtcbiAgICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFzeW5jIF9yZWFkKGJhdGNoKSB7XG4gICAgaWYgKHRoaXMucmVhZGluZykgcmV0dXJuO1xuICAgIHRoaXMucmVhZGluZyA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgd2hpbGUgKCF0aGlzLmRlc3Ryb3llZCAmJiBiYXRjaCA+IDApIHtcbiAgICAgICAgY29uc3QgeyBwYXRoLCBkZXB0aCwgZmlsZXMgPSBbXSB9ID0gdGhpcy5wYXJlbnQgfHwge307XG5cbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBzbGljZSA9IGZpbGVzLnNwbGljZSgwLCBiYXRjaCkubWFwKGRpcmVudCA9PiB0aGlzLl9mb3JtYXRFbnRyeShkaXJlbnQsIHBhdGgpKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGF3YWl0IFByb21pc2UuYWxsKHNsaWNlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IGVudHJ5VHlwZSA9IGF3YWl0IHRoaXMuX2dldEVudHJ5VHlwZShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoZW50cnlUeXBlID09PSAnZGlyZWN0b3J5JyAmJiB0aGlzLl9kaXJlY3RvcnlGaWx0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICAgIGlmIChkZXB0aCA8PSB0aGlzLl9tYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50cy5wdXNoKHRoaXMuX2V4cGxvcmVEaXIoZW50cnkuZnVsbFBhdGgsIGRlcHRoICsgMSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3dhbnRzRGlyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBiYXRjaC0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChlbnRyeVR5cGUgPT09ICdmaWxlJyB8fCB0aGlzLl9pbmNsdWRlQXNGaWxlKGVudHJ5KSkgJiYgdGhpcy5fZmlsZUZpbHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3dhbnRzRmlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgYmF0Y2gtLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudHMucG9wKCk7XG4gICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBhcmVudCA9IGF3YWl0IHBhcmVudDtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfZXhwbG9yZURpcihwYXRoLCBkZXB0aCkge1xuICAgIGxldCBmaWxlcztcbiAgICB0cnkge1xuICAgICAgZmlsZXMgPSBhd2FpdCByZWFkZGlyKHBhdGgsIHRoaXMuX3JkT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuX29uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4geyBmaWxlcywgZGVwdGgsIHBhdGggfTtcbiAgfVxuXG4gIGFzeW5jIF9mb3JtYXRFbnRyeShkaXJlbnQsIHBhdGgpIHtcbiAgICBsZXQgZW50cnk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJhc2VuYW1lID0gdGhpcy5faXNEaXJlbnQgPyBkaXJlbnQubmFtZSA6IGRpcmVudDtcbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gc3lzUGF0aC5yZXNvbHZlKHN5c1BhdGguam9pbihwYXRoLCBiYXNlbmFtZSkpO1xuICAgICAgZW50cnkgPSB7IHBhdGg6IHN5c1BhdGgucmVsYXRpdmUodGhpcy5fcm9vdCwgZnVsbFBhdGgpLCBmdWxsUGF0aCwgYmFzZW5hbWUgfTtcbiAgICAgIGVudHJ5W3RoaXMuX3N0YXRzUHJvcF0gPSB0aGlzLl9pc0RpcmVudCA/IGRpcmVudCA6IGF3YWl0IHRoaXMuX3N0YXQoZnVsbFBhdGgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fb25FcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG4gIH1cblxuICBfb25FcnJvcihlcnIpIHtcbiAgICBpZiAoaXNOb3JtYWxGbG93RXJyb3IoZXJyKSAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuZW1pdCgnd2FybicsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9nZXRFbnRyeVR5cGUoZW50cnkpIHtcbiAgICAvLyBlbnRyeSBtYXkgYmUgdW5kZWZpbmVkLCBiZWNhdXNlIGEgd2FybmluZyBvciBhbiBlcnJvciB3ZXJlIGVtaXR0ZWRcbiAgICAvLyBhbmQgdGhlIHN0YXRzUHJvcCBpcyB1bmRlZmluZWRcbiAgICBjb25zdCBzdGF0cyA9IGVudHJ5ICYmIGVudHJ5W3RoaXMuX3N0YXRzUHJvcF07XG4gICAgaWYgKCFzdGF0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgIHJldHVybiAnZmlsZSc7XG4gICAgfVxuICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gJ2RpcmVjdG9yeSc7XG4gICAgfVxuICAgIGlmIChzdGF0cyAmJiBzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICBjb25zdCBmdWxsID0gZW50cnkuZnVsbFBhdGg7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlbnRyeVJlYWxQYXRoID0gYXdhaXQgcmVhbHBhdGgoZnVsbCk7XG4gICAgICAgIGNvbnN0IGVudHJ5UmVhbFBhdGhTdGF0cyA9IGF3YWl0IGxzdGF0KGVudHJ5UmVhbFBhdGgpO1xuICAgICAgICBpZiAoZW50cnlSZWFsUGF0aFN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICAgICAgcmV0dXJuICdmaWxlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlSZWFsUGF0aFN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBjb25zdCBsZW4gPSBlbnRyeVJlYWxQYXRoLmxlbmd0aDtcbiAgICAgICAgICBpZiAoZnVsbC5zdGFydHNXaXRoKGVudHJ5UmVhbFBhdGgpICYmIGZ1bGwuc3Vic3RyKGxlbiwgMSkgPT09IHN5c1BhdGguc2VwKSB7XG4gICAgICAgICAgICBjb25zdCByZWN1cnNpdmVFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYENpcmN1bGFyIHN5bWxpbmsgZGV0ZWN0ZWQ6IFwiJHtmdWxsfVwiIHBvaW50cyB0byBcIiR7ZW50cnlSZWFsUGF0aH1cImBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWN1cnNpdmVFcnJvci5jb2RlID0gUkVDVVJTSVZFX0VSUk9SX0NPREU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25FcnJvcihyZWN1cnNpdmVFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAnZGlyZWN0b3J5JztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25FcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2luY2x1ZGVBc0ZpbGUoZW50cnkpIHtcbiAgICBjb25zdCBzdGF0cyA9IGVudHJ5ICYmIGVudHJ5W3RoaXMuX3N0YXRzUHJvcF07XG5cbiAgICByZXR1cm4gc3RhdHMgJiYgdGhpcy5fd2FudHNFdmVyeXRoaW5nICYmICFzdGF0cy5pc0RpcmVjdG9yeSgpO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhZGRpcnBBcmd1bWVudHNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb249fSBmaWxlRmlsdGVyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9uPX0gZGlyZWN0b3J5RmlsdGVyXG4gKiBAcHJvcGVydHkge1N0cmluZz19IHR5cGVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyPX0gZGVwdGhcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nPX0gcm9vdFxuICogQHByb3BlcnR5IHtCb29sZWFuPX0gbHN0YXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbj19IGJpZ2ludFxuICovXG5cbi8qKlxuICogTWFpbiBmdW5jdGlvbiB3aGljaCBlbmRzIHVwIGNhbGxpbmcgcmVhZGRpclJlYyBhbmQgcmVhZHMgYWxsIGZpbGVzIGFuZCBkaXJlY3RvcmllcyBpbiBnaXZlbiByb290IHJlY3Vyc2l2ZWx5LlxuICogQHBhcmFtIHtTdHJpbmd9IHJvb3QgUm9vdCBkaXJlY3RvcnlcbiAqIEBwYXJhbSB7UmVhZGRpcnBBcmd1bWVudHM9fSBvcHRpb25zIE9wdGlvbnMgdG8gc3BlY2lmeSByb290IChzdGFydCBkaXJlY3RvcnkpLCBmaWx0ZXJzIGFuZCByZWN1cnNpb24gZGVwdGhcbiAqL1xuY29uc3QgcmVhZGRpcnAgPSAocm9vdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCB0eXBlID0gb3B0aW9ucy5lbnRyeVR5cGUgfHwgb3B0aW9ucy50eXBlO1xuICBpZiAodHlwZSA9PT0gJ2JvdGgnKSB0eXBlID0gRklMRV9ESVJfVFlQRTsgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbiAgaWYgKHR5cGUpIG9wdGlvbnMudHlwZSA9IHR5cGU7XG4gIGlmICghcm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVhZGRpcnA6IHJvb3QgYXJndW1lbnQgaXMgcmVxdWlyZWQuIFVzYWdlOiByZWFkZGlycChyb290LCBvcHRpb25zKScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiByb290ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlYWRkaXJwOiByb290IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcuIFVzYWdlOiByZWFkZGlycChyb290LCBvcHRpb25zKScpO1xuICB9IGVsc2UgaWYgKHR5cGUgJiYgIUFMTF9UWVBFUy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcmVhZGRpcnA6IEludmFsaWQgdHlwZSBwYXNzZWQuIFVzZSBvbmUgb2YgJHtBTExfVFlQRVMuam9pbignLCAnKX1gKTtcbiAgfVxuXG4gIG9wdGlvbnMucm9vdCA9IHJvb3Q7XG4gIHJldHVybiBuZXcgUmVhZGRpcnBTdHJlYW0ob3B0aW9ucyk7XG59O1xuXG5jb25zdCByZWFkZGlycFByb21pc2UgPSAocm9vdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmlsZXMgPSBbXTtcbiAgICByZWFkZGlycChyb290LCBvcHRpb25zKVxuICAgICAgLm9uKCdkYXRhJywgZW50cnkgPT4gZmlsZXMucHVzaChlbnRyeSkpXG4gICAgICAub24oJ2VuZCcsICgpID0+IHJlc29sdmUoZmlsZXMpKVxuICAgICAgLm9uKCdlcnJvcicsIGVycm9yID0+IHJlamVjdChlcnJvcikpO1xuICB9KTtcbn07XG5cbnJlYWRkaXJwLnByb21pc2UgPSByZWFkZGlycFByb21pc2U7XG5yZWFkZGlycC5SZWFkZGlycFN0cmVhbSA9IFJlYWRkaXJwU3RyZWFtO1xucmVhZGRpcnAuZGVmYXVsdCA9IHJlYWRkaXJwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWRkaXJwO1xuIiwgIi8qIVxuICogbm9ybWFsaXplLXBhdGggPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L25vcm1hbGl6ZS1wYXRoPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE4LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhdGgsIHN0cmlwVHJhaWxpbmcpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdGggdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChwYXRoID09PSAnXFxcXCcgfHwgcGF0aCA9PT0gJy8nKSByZXR1cm4gJy8nO1xuXG4gIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgaWYgKGxlbiA8PSAxKSByZXR1cm4gcGF0aDtcblxuICAvLyBlbnN1cmUgdGhhdCB3aW4zMiBuYW1lc3BhY2VzIGhhcyB0d28gbGVhZGluZyBzbGFzaGVzLCBzbyB0aGF0IHRoZSBwYXRoIGlzXG4gIC8vIGhhbmRsZWQgcHJvcGVybHkgYnkgdGhlIHdpbjMyIHZlcnNpb24gb2YgcGF0aC5wYXJzZSgpIGFmdGVyIGJlaW5nIG5vcm1hbGl6ZWRcbiAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzNjUyNDcodj12cy44NSkuYXNweCNuYW1lc3BhY2VzXG4gIHZhciBwcmVmaXggPSAnJztcbiAgaWYgKGxlbiA+IDQgJiYgcGF0aFszXSA9PT0gJ1xcXFwnKSB7XG4gICAgdmFyIGNoID0gcGF0aFsyXTtcbiAgICBpZiAoKGNoID09PSAnPycgfHwgY2ggPT09ICcuJykgJiYgcGF0aC5zbGljZSgwLCAyKSA9PT0gJ1xcXFxcXFxcJykge1xuICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMik7XG4gICAgICBwcmVmaXggPSAnLy8nO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzZWdzID0gcGF0aC5zcGxpdCgvWy9cXFxcXSsvKTtcbiAgaWYgKHN0cmlwVHJhaWxpbmcgIT09IGZhbHNlICYmIHNlZ3Nbc2Vncy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICBzZWdzLnBvcCgpO1xuICB9XG4gIHJldHVybiBwcmVmaXggKyBzZWdzLmpvaW4oJy8nKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuY29uc3Qgbm9ybWFsaXplUGF0aCA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1wYXRoJyk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyh0ZXN0U3RyaW5nOiBzdHJpbmcpID0+IGJvb2xlYW59IEFueW1hdGNoRm5cbiAqIEB0eXBlZGVmIHtzdHJpbmd8UmVnRXhwfEFueW1hdGNoRm59IEFueW1hdGNoUGF0dGVyblxuICogQHR5cGVkZWYge0FueW1hdGNoUGF0dGVybnxBbnltYXRjaFBhdHRlcm5bXX0gQW55bWF0Y2hNYXRjaGVyXG4gKi9cbmNvbnN0IEJBTkcgPSAnISc7XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7cmV0dXJuSW5kZXg6IGZhbHNlfTtcbmNvbnN0IGFycmlmeSA9IChpdGVtKSA9PiBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXTtcblxuLyoqXG4gKiBAcGFyYW0ge0FueW1hdGNoUGF0dGVybn0gbWF0Y2hlclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBbnltYXRjaEZufVxuICovXG5jb25zdCBjcmVhdGVQYXR0ZXJuID0gKG1hdGNoZXIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1hdGNoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGdsb2IgPSBwaWNvbWF0Y2gobWF0Y2hlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIChzdHJpbmcpID0+IG1hdGNoZXIgPT09IHN0cmluZyB8fCBnbG9iKHN0cmluZyk7XG4gIH1cbiAgaWYgKG1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gKHN0cmluZykgPT4gbWF0Y2hlci50ZXN0KHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIChzdHJpbmcpID0+IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEZ1bmN0aW9uPn0gcGF0dGVybnNcbiAqIEBwYXJhbSB7QXJyYXk8RnVuY3Rpb24+fSBuZWdQYXR0ZXJuc1xuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGFyZ3NcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuSW5kZXhcbiAqIEByZXR1cm5zIHtib29sZWFufG51bWJlcn1cbiAqL1xuY29uc3QgbWF0Y2hQYXR0ZXJucyA9IChwYXR0ZXJucywgbmVnUGF0dGVybnMsIGFyZ3MsIHJldHVybkluZGV4KSA9PiB7XG4gIGNvbnN0IGlzTGlzdCA9IEFycmF5LmlzQXJyYXkoYXJncyk7XG4gIGNvbnN0IF9wYXRoID0gaXNMaXN0ID8gYXJnc1swXSA6IGFyZ3M7XG4gIGlmICghaXNMaXN0ICYmIHR5cGVvZiBfcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhbnltYXRjaDogc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmc6IGdvdCAnICtcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChfcGF0aCkpXG4gIH1cbiAgY29uc3QgcGF0aCA9IG5vcm1hbGl6ZVBhdGgoX3BhdGgsIGZhbHNlKTtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbmVnUGF0dGVybnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3Qgbmdsb2IgPSBuZWdQYXR0ZXJuc1tpbmRleF07XG4gICAgaWYgKG5nbG9iKHBhdGgpKSB7XG4gICAgICByZXR1cm4gcmV0dXJuSW5kZXggPyAtMSA6IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFwcGxpZWQgPSBpc0xpc3QgJiYgW3BhdGhdLmNvbmNhdChhcmdzLnNsaWNlKDEpKTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm5zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBwYXR0ZXJuc1tpbmRleF07XG4gICAgaWYgKGlzTGlzdCA/IHBhdHRlcm4oLi4uYXBwbGllZCkgOiBwYXR0ZXJuKHBhdGgpKSB7XG4gICAgICByZXR1cm4gcmV0dXJuSW5kZXggPyBpbmRleCA6IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVybkluZGV4ID8gLTEgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBbnltYXRjaE1hdGNoZXJ9IG1hdGNoZXJzXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gdGVzdFN0cmluZ1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufG51bWJlcnxGdW5jdGlvbn1cbiAqL1xuY29uc3QgYW55bWF0Y2ggPSAobWF0Y2hlcnMsIHRlc3RTdHJpbmcsIG9wdGlvbnMgPSBERUZBVUxUX09QVElPTlMpID0+IHtcbiAgaWYgKG1hdGNoZXJzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhbnltYXRjaDogc3BlY2lmeSBmaXJzdCBhcmd1bWVudCcpO1xuICB9XG4gIGNvbnN0IG9wdHMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge3JldHVybkluZGV4OiBvcHRpb25zfSA6IG9wdGlvbnM7XG4gIGNvbnN0IHJldHVybkluZGV4ID0gb3B0cy5yZXR1cm5JbmRleCB8fCBmYWxzZTtcblxuICAvLyBFYXJseSBjYWNoZSBmb3IgbWF0Y2hlcnMuXG4gIGNvbnN0IG10Y2hlcnMgPSBhcnJpZnkobWF0Y2hlcnMpO1xuICBjb25zdCBuZWdhdGVkR2xvYnMgPSBtdGNoZXJzXG4gICAgLmZpbHRlcihpdGVtID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyAmJiBpdGVtLmNoYXJBdCgwKSA9PT0gQkFORylcbiAgICAubWFwKGl0ZW0gPT4gaXRlbS5zbGljZSgxKSlcbiAgICAubWFwKGl0ZW0gPT4gcGljb21hdGNoKGl0ZW0sIG9wdHMpKTtcbiAgY29uc3QgcGF0dGVybnMgPSBtdGNoZXJzXG4gICAgLmZpbHRlcihpdGVtID0+IHR5cGVvZiBpdGVtICE9PSAnc3RyaW5nJyB8fCAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICYmIGl0ZW0uY2hhckF0KDApICE9PSBCQU5HKSlcbiAgICAubWFwKG1hdGNoZXIgPT4gY3JlYXRlUGF0dGVybihtYXRjaGVyLCBvcHRzKSk7XG5cbiAgaWYgKHRlc3RTdHJpbmcgPT0gbnVsbCkge1xuICAgIHJldHVybiAodGVzdFN0cmluZywgcmkgPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc3QgcmV0dXJuSW5kZXggPSB0eXBlb2YgcmkgPT09ICdib29sZWFuJyA/IHJpIDogZmFsc2U7XG4gICAgICByZXR1cm4gbWF0Y2hQYXR0ZXJucyhwYXR0ZXJucywgbmVnYXRlZEdsb2JzLCB0ZXN0U3RyaW5nLCByZXR1cm5JbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoUGF0dGVybnMocGF0dGVybnMsIG5lZ2F0ZWRHbG9icywgdGVzdFN0cmluZywgcmV0dXJuSW5kZXgpO1xufTtcblxuYW55bWF0Y2guZGVmYXVsdCA9IGFueW1hdGNoO1xubW9kdWxlLmV4cG9ydHMgPSBhbnltYXRjaDtcbiIsICIvKiFcbiAqIGlzLWV4dGdsb2IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWV4dGdsb2I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeHRnbG9iKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgc3RyID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IC8oXFxcXCkufChbQD8hKypdXFwoLipcXCkpL2cuZXhlYyhzdHIpKSkge1xuICAgIGlmIChtYXRjaFsyXSkgcmV0dXJuIHRydWU7XG4gICAgc3RyID0gc3RyLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCAiLyohXG4gKiBpcy1nbG9iIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1nbG9iPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG52YXIgaXNFeHRnbG9iID0gcmVxdWlyZSgnaXMtZXh0Z2xvYicpO1xudmFyIGNoYXJzID0geyAneyc6ICd9JywgJygnOiAnKScsICdbJzogJ10nfTtcbnZhciBzdHJpY3RDaGVjayA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoc3RyWzBdID09PSAnIScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGlwZUluZGV4ID0gLTI7XG4gIHZhciBjbG9zZVNxdWFyZUluZGV4ID0gLTI7XG4gIHZhciBjbG9zZUN1cmx5SW5kZXggPSAtMjtcbiAgdmFyIGNsb3NlUGFyZW5JbmRleCA9IC0yO1xuICB2YXIgYmFja1NsYXNoSW5kZXggPSAtMjtcbiAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIGlmIChzdHJbaW5kZXhdID09PSAnKicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJbaW5kZXggKyAxXSA9PT0gJz8nICYmIC9bXFxdLispXS8udGVzdChzdHJbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNsb3NlU3F1YXJlSW5kZXggIT09IC0xICYmIHN0cltpbmRleF0gPT09ICdbJyAmJiBzdHJbaW5kZXggKyAxXSAhPT0gJ10nKSB7XG4gICAgICBpZiAoY2xvc2VTcXVhcmVJbmRleCA8IGluZGV4KSB7XG4gICAgICAgIGNsb3NlU3F1YXJlSW5kZXggPSBzdHIuaW5kZXhPZignXScsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9zZVNxdWFyZUluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgaWYgKGJhY2tTbGFzaEluZGV4ID09PSAtMSB8fCBiYWNrU2xhc2hJbmRleCA+IGNsb3NlU3F1YXJlSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBiYWNrU2xhc2hJbmRleCA9IHN0ci5pbmRleE9mKCdcXFxcJywgaW5kZXgpO1xuICAgICAgICBpZiAoYmFja1NsYXNoSW5kZXggPT09IC0xIHx8IGJhY2tTbGFzaEluZGV4ID4gY2xvc2VTcXVhcmVJbmRleCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsb3NlQ3VybHlJbmRleCAhPT0gLTEgJiYgc3RyW2luZGV4XSA9PT0gJ3snICYmIHN0cltpbmRleCArIDFdICE9PSAnfScpIHtcbiAgICAgIGNsb3NlQ3VybHlJbmRleCA9IHN0ci5pbmRleE9mKCd9JywgaW5kZXgpO1xuICAgICAgaWYgKGNsb3NlQ3VybHlJbmRleCA+IGluZGV4KSB7XG4gICAgICAgIGJhY2tTbGFzaEluZGV4ID0gc3RyLmluZGV4T2YoJ1xcXFwnLCBpbmRleCk7XG4gICAgICAgIGlmIChiYWNrU2xhc2hJbmRleCA9PT0gLTEgfHwgYmFja1NsYXNoSW5kZXggPiBjbG9zZUN1cmx5SW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbG9zZVBhcmVuSW5kZXggIT09IC0xICYmIHN0cltpbmRleF0gPT09ICcoJyAmJiBzdHJbaW5kZXggKyAxXSA9PT0gJz8nICYmIC9bOiE9XS8udGVzdChzdHJbaW5kZXggKyAyXSkgJiYgc3RyW2luZGV4ICsgM10gIT09ICcpJykge1xuICAgICAgY2xvc2VQYXJlbkluZGV4ID0gc3RyLmluZGV4T2YoJyknLCBpbmRleCk7XG4gICAgICBpZiAoY2xvc2VQYXJlbkluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgYmFja1NsYXNoSW5kZXggPSBzdHIuaW5kZXhPZignXFxcXCcsIGluZGV4KTtcbiAgICAgICAgaWYgKGJhY2tTbGFzaEluZGV4ID09PSAtMSB8fCBiYWNrU2xhc2hJbmRleCA+IGNsb3NlUGFyZW5JbmRleCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBpcGVJbmRleCAhPT0gLTEgJiYgc3RyW2luZGV4XSA9PT0gJygnICYmIHN0cltpbmRleCArIDFdICE9PSAnfCcpIHtcbiAgICAgIGlmIChwaXBlSW5kZXggPCBpbmRleCkge1xuICAgICAgICBwaXBlSW5kZXggPSBzdHIuaW5kZXhPZignfCcsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChwaXBlSW5kZXggIT09IC0xICYmIHN0cltwaXBlSW5kZXggKyAxXSAhPT0gJyknKSB7XG4gICAgICAgIGNsb3NlUGFyZW5JbmRleCA9IHN0ci5pbmRleE9mKCcpJywgcGlwZUluZGV4KTtcbiAgICAgICAgaWYgKGNsb3NlUGFyZW5JbmRleCA+IHBpcGVJbmRleCkge1xuICAgICAgICAgIGJhY2tTbGFzaEluZGV4ID0gc3RyLmluZGV4T2YoJ1xcXFwnLCBwaXBlSW5kZXgpO1xuICAgICAgICAgIGlmIChiYWNrU2xhc2hJbmRleCA9PT0gLTEgfHwgYmFja1NsYXNoSW5kZXggPiBjbG9zZVBhcmVuSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJbaW5kZXhdID09PSAnXFxcXCcpIHtcbiAgICAgIHZhciBvcGVuID0gc3RyW2luZGV4ICsgMV07XG4gICAgICBpbmRleCArPSAyO1xuICAgICAgdmFyIGNsb3NlID0gY2hhcnNbb3Blbl07XG5cbiAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICB2YXIgbiA9IHN0ci5pbmRleE9mKGNsb3NlLCBpbmRleCk7XG4gICAgICAgIGlmIChuICE9PSAtMSkge1xuICAgICAgICAgIGluZGV4ID0gbiArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0cltpbmRleF0gPT09ICchJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIHJlbGF4ZWRDaGVjayA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoc3RyWzBdID09PSAnIScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKC9bKj97fSgpW1xcXV0vLnRlc3Qoc3RyW2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJbaW5kZXhdID09PSAnXFxcXCcpIHtcbiAgICAgIHZhciBvcGVuID0gc3RyW2luZGV4ICsgMV07XG4gICAgICBpbmRleCArPSAyO1xuICAgICAgdmFyIGNsb3NlID0gY2hhcnNbb3Blbl07XG5cbiAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICB2YXIgbiA9IHN0ci5pbmRleE9mKGNsb3NlLCBpbmRleCk7XG4gICAgICAgIGlmIChuICE9PSAtMSkge1xuICAgICAgICAgIGluZGV4ID0gbiArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0cltpbmRleF0gPT09ICchJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dsb2Ioc3RyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCBzdHIgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRXh0Z2xvYihzdHIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgY2hlY2sgPSBzdHJpY3RDaGVjaztcblxuICAvLyBvcHRpb25hbGx5IHJlbGF4IGNoZWNrXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0ID09PSBmYWxzZSkge1xuICAgIGNoZWNrID0gcmVsYXhlZENoZWNrO1xuICB9XG5cbiAgcmV0dXJuIGNoZWNrKHN0cik7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGlzR2xvYiA9IHJlcXVpcmUoJ2lzLWdsb2InKTtcbnZhciBwYXRoUG9zaXhEaXJuYW1lID0gcmVxdWlyZSgncGF0aCcpLnBvc2l4LmRpcm5hbWU7XG52YXIgaXNXaW4zMiA9IHJlcXVpcmUoJ29zJykucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJztcblxudmFyIHNsYXNoID0gJy8nO1xudmFyIGJhY2tzbGFzaCA9IC9cXFxcL2c7XG52YXIgZW5jbG9zdXJlID0gL1tcXHtcXFtdLipbXFx9XFxdXSQvO1xudmFyIGdsb2JieSA9IC8oXnxbXlxcXFxdKShbXFx7XFxbXXxcXChbXlxcKV0rJCkvO1xudmFyIGVzY2FwZWQgPSAvXFxcXChbXFwhXFwqXFw/XFx8XFxbXFxdXFwoXFwpXFx7XFx9XSkvZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5mbGlwQmFja3NsYXNoZXM9dHJ1ZV1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2xvYlBhcmVudChzdHIsIG9wdHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZmxpcEJhY2tzbGFzaGVzOiB0cnVlIH0sIG9wdHMpO1xuXG4gIC8vIGZsaXAgd2luZG93cyBwYXRoIHNlcGFyYXRvcnNcbiAgaWYgKG9wdGlvbnMuZmxpcEJhY2tzbGFzaGVzICYmIGlzV2luMzIgJiYgc3RyLmluZGV4T2Yoc2xhc2gpIDwgMCkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKGJhY2tzbGFzaCwgc2xhc2gpO1xuICB9XG5cbiAgLy8gc3BlY2lhbCBjYXNlIGZvciBzdHJpbmdzIGVuZGluZyBpbiBlbmNsb3N1cmUgY29udGFpbmluZyBwYXRoIHNlcGFyYXRvclxuICBpZiAoZW5jbG9zdXJlLnRlc3Qoc3RyKSkge1xuICAgIHN0ciArPSBzbGFzaDtcbiAgfVxuXG4gIC8vIHByZXNlcnZlcyBmdWxsIHBhdGggaW4gY2FzZSBvZiB0cmFpbGluZyBwYXRoIHNlcGFyYXRvclxuICBzdHIgKz0gJ2EnO1xuXG4gIC8vIHJlbW92ZSBwYXRoIHBhcnRzIHRoYXQgYXJlIGdsb2JieVxuICBkbyB7XG4gICAgc3RyID0gcGF0aFBvc2l4RGlybmFtZShzdHIpO1xuICB9IHdoaWxlIChpc0dsb2Ioc3RyKSB8fCBnbG9iYnkudGVzdChzdHIpKTtcblxuICAvLyByZW1vdmUgZXNjYXBlIGNoYXJzIGFuZCByZXR1cm4gcmVzdWx0XG4gIHJldHVybiBzdHIucmVwbGFjZShlc2NhcGVkLCAnJDEnKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmlzSW50ZWdlciA9IG51bSA9PiB7XG4gIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKG51bSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnICYmIG51bS50cmltKCkgIT09ICcnKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKG51bSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRmluZCBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGVcbiAqL1xuXG5leHBvcnRzLmZpbmQgPSAobm9kZSwgdHlwZSkgPT4gbm9kZS5ub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS50eXBlID09PSB0eXBlKTtcblxuLyoqXG4gKiBGaW5kIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZVxuICovXG5cbmV4cG9ydHMuZXhjZWVkc0xpbWl0ID0gKG1pbiwgbWF4LCBzdGVwID0gMSwgbGltaXQpID0+IHtcbiAgaWYgKGxpbWl0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWV4cG9ydHMuaXNJbnRlZ2VyKG1pbikgfHwgIWV4cG9ydHMuaXNJbnRlZ2VyKG1heCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICgoTnVtYmVyKG1heCkgLSBOdW1iZXIobWluKSkgLyBOdW1iZXIoc3RlcCkpID49IGxpbWl0O1xufTtcblxuLyoqXG4gKiBFc2NhcGUgdGhlIGdpdmVuIG5vZGUgd2l0aCAnXFxcXCcgYmVmb3JlIG5vZGUudmFsdWVcbiAqL1xuXG5leHBvcnRzLmVzY2FwZU5vZGUgPSAoYmxvY2ssIG4gPSAwLCB0eXBlKSA9PiB7XG4gIGxldCBub2RlID0gYmxvY2subm9kZXNbbl07XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gIGlmICgodHlwZSAmJiBub2RlLnR5cGUgPT09IHR5cGUpIHx8IG5vZGUudHlwZSA9PT0gJ29wZW4nIHx8IG5vZGUudHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgIGlmIChub2RlLmVzY2FwZWQgIT09IHRydWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSAnXFxcXCcgKyBub2RlLnZhbHVlO1xuICAgICAgbm9kZS5lc2NhcGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBicmFjZSBub2RlIHNob3VsZCBiZSBlbmNsb3NlZCBpbiBsaXRlcmFsIGJyYWNlc1xuICovXG5cbmV4cG9ydHMuZW5jbG9zZUJyYWNlID0gbm9kZSA9PiB7XG4gIGlmIChub2RlLnR5cGUgIT09ICdicmFjZScpIHJldHVybiBmYWxzZTtcbiAgaWYgKChub2RlLmNvbW1hcyA+PiAwICsgbm9kZS5yYW5nZXMgPj4gMCkgPT09IDApIHtcbiAgICBub2RlLmludmFsaWQgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgYnJhY2Ugbm9kZSBpcyBpbnZhbGlkLlxuICovXG5cbmV4cG9ydHMuaXNJbnZhbGlkQnJhY2UgPSBibG9jayA9PiB7XG4gIGlmIChibG9jay50eXBlICE9PSAnYnJhY2UnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChibG9jay5pbnZhbGlkID09PSB0cnVlIHx8IGJsb2NrLmRvbGxhcikgcmV0dXJuIHRydWU7XG4gIGlmICgoYmxvY2suY29tbWFzID4+IDAgKyBibG9jay5yYW5nZXMgPj4gMCkgPT09IDApIHtcbiAgICBibG9jay5pbnZhbGlkID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYmxvY2sub3BlbiAhPT0gdHJ1ZSB8fCBibG9jay5jbG9zZSAhPT0gdHJ1ZSkge1xuICAgIGJsb2NrLmludmFsaWQgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgbm9kZSBpcyBhbiBvcGVuIG9yIGNsb3NlIG5vZGVcbiAqL1xuXG5leHBvcnRzLmlzT3Blbk9yQ2xvc2UgPSBub2RlID0+IHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ29wZW4nIHx8IG5vZGUudHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBub2RlLm9wZW4gPT09IHRydWUgfHwgbm9kZS5jbG9zZSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVkdWNlIGFuIGFycmF5IG9mIHRleHQgbm9kZXMuXG4gKi9cblxuZXhwb3J0cy5yZWR1Y2UgPSBub2RlcyA9PiBub2Rlcy5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIGFjYy5wdXNoKG5vZGUudmFsdWUpO1xuICBpZiAobm9kZS50eXBlID09PSAncmFuZ2UnKSBub2RlLnR5cGUgPSAndGV4dCc7XG4gIHJldHVybiBhY2M7XG59LCBbXSk7XG5cbi8qKlxuICogRmxhdHRlbiBhbiBhcnJheVxuICovXG5cbmV4cG9ydHMuZmxhdHRlbiA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBmbGF0ID0gYXJyID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGVsZSA9IGFycltpXTtcbiAgICAgIEFycmF5LmlzQXJyYXkoZWxlKSA/IGZsYXQoZWxlLCByZXN1bHQpIDogZWxlICE9PSB2b2lkIDAgJiYgcmVzdWx0LnB1c2goZWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgZmxhdChhcmdzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoYXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IHN0cmluZ2lmeSA9IChub2RlLCBwYXJlbnQgPSB7fSkgPT4ge1xuICAgIGxldCBpbnZhbGlkQmxvY2sgPSBvcHRpb25zLmVzY2FwZUludmFsaWQgJiYgdXRpbHMuaXNJbnZhbGlkQnJhY2UocGFyZW50KTtcbiAgICBsZXQgaW52YWxpZE5vZGUgPSBub2RlLmludmFsaWQgPT09IHRydWUgJiYgb3B0aW9ucy5lc2NhcGVJbnZhbGlkID09PSB0cnVlO1xuICAgIGxldCBvdXRwdXQgPSAnJztcblxuICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICBpZiAoKGludmFsaWRCbG9jayB8fCBpbnZhbGlkTm9kZSkgJiYgdXRpbHMuaXNPcGVuT3JDbG9zZShub2RlKSkge1xuICAgICAgICByZXR1cm4gJ1xcXFwnICsgbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5ub2Rlcykge1xuICAgICAgICBvdXRwdXQgKz0gc3RyaW5naWZ5KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICByZXR1cm4gc3RyaW5naWZ5KGFzdCk7XG59O1xuXG4iLCAiLyohXG4gKiBpcy1udW1iZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLW51bWJlcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG51bSkge1xuICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbnVtIC0gbnVtID09PSAwO1xuICB9XG4gIGlmICh0eXBlb2YgbnVtID09PSAnc3RyaW5nJyAmJiBudW0udHJpbSgpICE9PSAnJykge1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUgPyBOdW1iZXIuaXNGaW5pdGUoK251bSkgOiBpc0Zpbml0ZSgrbnVtKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwgIi8qIVxuICogdG8tcmVnZXgtcmFuZ2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb21hdGNoL3RvLXJlZ2V4LXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzTnVtYmVyID0gcmVxdWlyZSgnaXMtbnVtYmVyJyk7XG5cbmNvbnN0IHRvUmVnZXhSYW5nZSA9IChtaW4sIG1heCwgb3B0aW9ucykgPT4ge1xuICBpZiAoaXNOdW1iZXIobWluKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b1JlZ2V4UmFuZ2U6IGV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKG1heCA9PT0gdm9pZCAwIHx8IG1pbiA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIFN0cmluZyhtaW4pO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKG1heCkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyLicpO1xuICB9XG5cbiAgbGV0IG9wdHMgPSB7IHJlbGF4WmVyb3M6IHRydWUsIC4uLm9wdGlvbnMgfTtcbiAgaWYgKHR5cGVvZiBvcHRzLnN0cmljdFplcm9zID09PSAnYm9vbGVhbicpIHtcbiAgICBvcHRzLnJlbGF4WmVyb3MgPSBvcHRzLnN0cmljdFplcm9zID09PSBmYWxzZTtcbiAgfVxuXG4gIGxldCByZWxheCA9IFN0cmluZyhvcHRzLnJlbGF4WmVyb3MpO1xuICBsZXQgc2hvcnRoYW5kID0gU3RyaW5nKG9wdHMuc2hvcnRoYW5kKTtcbiAgbGV0IGNhcHR1cmUgPSBTdHJpbmcob3B0cy5jYXB0dXJlKTtcbiAgbGV0IHdyYXAgPSBTdHJpbmcob3B0cy53cmFwKTtcbiAgbGV0IGNhY2hlS2V5ID0gbWluICsgJzonICsgbWF4ICsgJz0nICsgcmVsYXggKyBzaG9ydGhhbmQgKyBjYXB0dXJlICsgd3JhcDtcblxuICBpZiAodG9SZWdleFJhbmdlLmNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgIHJldHVybiB0b1JlZ2V4UmFuZ2UuY2FjaGVbY2FjaGVLZXldLnJlc3VsdDtcbiAgfVxuXG4gIGxldCBhID0gTWF0aC5taW4obWluLCBtYXgpO1xuICBsZXQgYiA9IE1hdGgubWF4KG1pbiwgbWF4KTtcblxuICBpZiAoTWF0aC5hYnMoYSAtIGIpID09PSAxKSB7XG4gICAgbGV0IHJlc3VsdCA9IG1pbiArICd8JyArIG1heDtcbiAgICBpZiAob3B0cy5jYXB0dXJlKSB7XG4gICAgICByZXR1cm4gYCgke3Jlc3VsdH0pYDtcbiAgICB9XG4gICAgaWYgKG9wdHMud3JhcCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBgKD86JHtyZXN1bHR9KWA7XG4gIH1cblxuICBsZXQgaXNQYWRkZWQgPSBoYXNQYWRkaW5nKG1pbikgfHwgaGFzUGFkZGluZyhtYXgpO1xuICBsZXQgc3RhdGUgPSB7IG1pbiwgbWF4LCBhLCBiIH07XG4gIGxldCBwb3NpdGl2ZXMgPSBbXTtcbiAgbGV0IG5lZ2F0aXZlcyA9IFtdO1xuXG4gIGlmIChpc1BhZGRlZCkge1xuICAgIHN0YXRlLmlzUGFkZGVkID0gaXNQYWRkZWQ7XG4gICAgc3RhdGUubWF4TGVuID0gU3RyaW5nKHN0YXRlLm1heCkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGEgPCAwKSB7XG4gICAgbGV0IG5ld01pbiA9IGIgPCAwID8gTWF0aC5hYnMoYikgOiAxO1xuICAgIG5lZ2F0aXZlcyA9IHNwbGl0VG9QYXR0ZXJucyhuZXdNaW4sIE1hdGguYWJzKGEpLCBzdGF0ZSwgb3B0cyk7XG4gICAgYSA9IHN0YXRlLmEgPSAwO1xuICB9XG5cbiAgaWYgKGIgPj0gMCkge1xuICAgIHBvc2l0aXZlcyA9IHNwbGl0VG9QYXR0ZXJucyhhLCBiLCBzdGF0ZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0ZS5uZWdhdGl2ZXMgPSBuZWdhdGl2ZXM7XG4gIHN0YXRlLnBvc2l0aXZlcyA9IHBvc2l0aXZlcztcbiAgc3RhdGUucmVzdWx0ID0gY29sbGF0ZVBhdHRlcm5zKG5lZ2F0aXZlcywgcG9zaXRpdmVzLCBvcHRzKTtcblxuICBpZiAob3B0cy5jYXB0dXJlID09PSB0cnVlKSB7XG4gICAgc3RhdGUucmVzdWx0ID0gYCgke3N0YXRlLnJlc3VsdH0pYDtcbiAgfSBlbHNlIGlmIChvcHRzLndyYXAgIT09IGZhbHNlICYmIChwb3NpdGl2ZXMubGVuZ3RoICsgbmVnYXRpdmVzLmxlbmd0aCkgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ID0gYCg/OiR7c3RhdGUucmVzdWx0fSlgO1xuICB9XG5cbiAgdG9SZWdleFJhbmdlLmNhY2hlW2NhY2hlS2V5XSA9IHN0YXRlO1xuICByZXR1cm4gc3RhdGUucmVzdWx0O1xufTtcblxuZnVuY3Rpb24gY29sbGF0ZVBhdHRlcm5zKG5lZywgcG9zLCBvcHRpb25zKSB7XG4gIGxldCBvbmx5TmVnYXRpdmUgPSBmaWx0ZXJQYXR0ZXJucyhuZWcsIHBvcywgJy0nLCBmYWxzZSwgb3B0aW9ucykgfHwgW107XG4gIGxldCBvbmx5UG9zaXRpdmUgPSBmaWx0ZXJQYXR0ZXJucyhwb3MsIG5lZywgJycsIGZhbHNlLCBvcHRpb25zKSB8fCBbXTtcbiAgbGV0IGludGVyc2VjdGVkID0gZmlsdGVyUGF0dGVybnMobmVnLCBwb3MsICctPycsIHRydWUsIG9wdGlvbnMpIHx8IFtdO1xuICBsZXQgc3VicGF0dGVybnMgPSBvbmx5TmVnYXRpdmUuY29uY2F0KGludGVyc2VjdGVkKS5jb25jYXQob25seVBvc2l0aXZlKTtcbiAgcmV0dXJuIHN1YnBhdHRlcm5zLmpvaW4oJ3wnKTtcbn1cblxuZnVuY3Rpb24gc3BsaXRUb1JhbmdlcyhtaW4sIG1heCkge1xuICBsZXQgbmluZXMgPSAxO1xuICBsZXQgemVyb3MgPSAxO1xuXG4gIGxldCBzdG9wID0gY291bnROaW5lcyhtaW4sIG5pbmVzKTtcbiAgbGV0IHN0b3BzID0gbmV3IFNldChbbWF4XSk7XG5cbiAgd2hpbGUgKG1pbiA8PSBzdG9wICYmIHN0b3AgPD0gbWF4KSB7XG4gICAgc3RvcHMuYWRkKHN0b3ApO1xuICAgIG5pbmVzICs9IDE7XG4gICAgc3RvcCA9IGNvdW50TmluZXMobWluLCBuaW5lcyk7XG4gIH1cblxuICBzdG9wID0gY291bnRaZXJvcyhtYXggKyAxLCB6ZXJvcykgLSAxO1xuXG4gIHdoaWxlIChtaW4gPCBzdG9wICYmIHN0b3AgPD0gbWF4KSB7XG4gICAgc3RvcHMuYWRkKHN0b3ApO1xuICAgIHplcm9zICs9IDE7XG4gICAgc3RvcCA9IGNvdW50WmVyb3MobWF4ICsgMSwgemVyb3MpIC0gMTtcbiAgfVxuXG4gIHN0b3BzID0gWy4uLnN0b3BzXTtcbiAgc3RvcHMuc29ydChjb21wYXJlKTtcbiAgcmV0dXJuIHN0b3BzO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSByYW5nZSB0byBhIHJlZ2V4IHBhdHRlcm5cbiAqIEBwYXJhbSB7TnVtYmVyfSBgc3RhcnRgXG4gKiBAcGFyYW0ge051bWJlcn0gYHN0b3BgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oc3RhcnQsIHN0b3AsIG9wdGlvbnMpIHtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wKSB7XG4gICAgcmV0dXJuIHsgcGF0dGVybjogc3RhcnQsIGNvdW50OiBbXSwgZGlnaXRzOiAwIH07XG4gIH1cblxuICBsZXQgemlwcGVkID0gemlwKHN0YXJ0LCBzdG9wKTtcbiAgbGV0IGRpZ2l0cyA9IHppcHBlZC5sZW5ndGg7XG4gIGxldCBwYXR0ZXJuID0gJyc7XG4gIGxldCBjb3VudCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWdpdHM7IGkrKykge1xuICAgIGxldCBbc3RhcnREaWdpdCwgc3RvcERpZ2l0XSA9IHppcHBlZFtpXTtcblxuICAgIGlmIChzdGFydERpZ2l0ID09PSBzdG9wRGlnaXQpIHtcbiAgICAgIHBhdHRlcm4gKz0gc3RhcnREaWdpdDtcblxuICAgIH0gZWxzZSBpZiAoc3RhcnREaWdpdCAhPT0gJzAnIHx8IHN0b3BEaWdpdCAhPT0gJzknKSB7XG4gICAgICBwYXR0ZXJuICs9IHRvQ2hhcmFjdGVyQ2xhc3Moc3RhcnREaWdpdCwgc3RvcERpZ2l0LCBvcHRpb25zKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb3VudCkge1xuICAgIHBhdHRlcm4gKz0gb3B0aW9ucy5zaG9ydGhhbmQgPT09IHRydWUgPyAnXFxcXGQnIDogJ1swLTldJztcbiAgfVxuXG4gIHJldHVybiB7IHBhdHRlcm4sIGNvdW50OiBbY291bnRdLCBkaWdpdHMgfTtcbn1cblxuZnVuY3Rpb24gc3BsaXRUb1BhdHRlcm5zKG1pbiwgbWF4LCB0b2ssIG9wdGlvbnMpIHtcbiAgbGV0IHJhbmdlcyA9IHNwbGl0VG9SYW5nZXMobWluLCBtYXgpO1xuICBsZXQgdG9rZW5zID0gW107XG4gIGxldCBzdGFydCA9IG1pbjtcbiAgbGV0IHByZXY7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbWF4ID0gcmFuZ2VzW2ldO1xuICAgIGxldCBvYmogPSByYW5nZVRvUGF0dGVybihTdHJpbmcoc3RhcnQpLCBTdHJpbmcobWF4KSwgb3B0aW9ucyk7XG4gICAgbGV0IHplcm9zID0gJyc7XG5cbiAgICBpZiAoIXRvay5pc1BhZGRlZCAmJiBwcmV2ICYmIHByZXYucGF0dGVybiA9PT0gb2JqLnBhdHRlcm4pIHtcbiAgICAgIGlmIChwcmV2LmNvdW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcHJldi5jb3VudC5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgcHJldi5jb3VudC5wdXNoKG9iai5jb3VudFswXSk7XG4gICAgICBwcmV2LnN0cmluZyA9IHByZXYucGF0dGVybiArIHRvUXVhbnRpZmllcihwcmV2LmNvdW50KTtcbiAgICAgIHN0YXJ0ID0gbWF4ICsgMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0b2suaXNQYWRkZWQpIHtcbiAgICAgIHplcm9zID0gcGFkWmVyb3MobWF4LCB0b2ssIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIG9iai5zdHJpbmcgPSB6ZXJvcyArIG9iai5wYXR0ZXJuICsgdG9RdWFudGlmaWVyKG9iai5jb3VudCk7XG4gICAgdG9rZW5zLnB1c2gob2JqKTtcbiAgICBzdGFydCA9IG1heCArIDE7XG4gICAgcHJldiA9IG9iajtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclBhdHRlcm5zKGFyciwgY29tcGFyaXNvbiwgcHJlZml4LCBpbnRlcnNlY3Rpb24sIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gIGZvciAobGV0IGVsZSBvZiBhcnIpIHtcbiAgICBsZXQgeyBzdHJpbmcgfSA9IGVsZTtcblxuICAgIC8vIG9ubHkgcHVzaCBpZiBfYm90aF8gYXJlIG5lZ2F0aXZlLi4uXG4gICAgaWYgKCFpbnRlcnNlY3Rpb24gJiYgIWNvbnRhaW5zKGNvbXBhcmlzb24sICdzdHJpbmcnLCBzdHJpbmcpKSB7XG4gICAgICByZXN1bHQucHVzaChwcmVmaXggKyBzdHJpbmcpO1xuICAgIH1cblxuICAgIC8vIG9yIF9ib3RoXyBhcmUgcG9zaXRpdmVcbiAgICBpZiAoaW50ZXJzZWN0aW9uICYmIGNvbnRhaW5zKGNvbXBhcmlzb24sICdzdHJpbmcnLCBzdHJpbmcpKSB7XG4gICAgICByZXN1bHQucHVzaChwcmVmaXggKyBzdHJpbmcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFppcCBzdHJpbmdzXG4gKi9cblxuZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgbGV0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIGFyci5wdXNoKFthW2ldLCBiW2ldXSk7XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAxIDogYiA+IGEgPyAtMSA6IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGFyciwga2V5LCB2YWwpIHtcbiAgcmV0dXJuIGFyci5zb21lKGVsZSA9PiBlbGVba2V5XSA9PT0gdmFsKTtcbn1cblxuZnVuY3Rpb24gY291bnROaW5lcyhtaW4sIGxlbikge1xuICByZXR1cm4gTnVtYmVyKFN0cmluZyhtaW4pLnNsaWNlKDAsIC1sZW4pICsgJzknLnJlcGVhdChsZW4pKTtcbn1cblxuZnVuY3Rpb24gY291bnRaZXJvcyhpbnRlZ2VyLCB6ZXJvcykge1xuICByZXR1cm4gaW50ZWdlciAtIChpbnRlZ2VyICUgTWF0aC5wb3coMTAsIHplcm9zKSk7XG59XG5cbmZ1bmN0aW9uIHRvUXVhbnRpZmllcihkaWdpdHMpIHtcbiAgbGV0IFtzdGFydCA9IDAsIHN0b3AgPSAnJ10gPSBkaWdpdHM7XG4gIGlmIChzdG9wIHx8IHN0YXJ0ID4gMSkge1xuICAgIHJldHVybiBgeyR7c3RhcnQgKyAoc3RvcCA/ICcsJyArIHN0b3AgOiAnJyl9fWA7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiB0b0NoYXJhY3RlckNsYXNzKGEsIGIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGBbJHthfSR7KGIgLSBhID09PSAxKSA/ICcnIDogJy0nfSR7Yn1dYDtcbn1cblxuZnVuY3Rpb24gaGFzUGFkZGluZyhzdHIpIHtcbiAgcmV0dXJuIC9eLT8oMCspXFxkLy50ZXN0KHN0cik7XG59XG5cbmZ1bmN0aW9uIHBhZFplcm9zKHZhbHVlLCB0b2ssIG9wdGlvbnMpIHtcbiAgaWYgKCF0b2suaXNQYWRkZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBsZXQgZGlmZiA9IE1hdGguYWJzKHRvay5tYXhMZW4gLSBTdHJpbmcodmFsdWUpLmxlbmd0aCk7XG4gIGxldCByZWxheCA9IG9wdGlvbnMucmVsYXhaZXJvcyAhPT0gZmFsc2U7XG5cbiAgc3dpdGNoIChkaWZmKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuICcnO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiByZWxheCA/ICcwPycgOiAnMCc7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHJlbGF4ID8gJzB7MCwyfScgOiAnMDAnO1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiByZWxheCA/IGAwezAsJHtkaWZmfX1gIDogYDB7JHtkaWZmfX1gO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENhY2hlXG4gKi9cblxudG9SZWdleFJhbmdlLmNhY2hlID0ge307XG50b1JlZ2V4UmFuZ2UuY2xlYXJDYWNoZSA9ICgpID0+ICh0b1JlZ2V4UmFuZ2UuY2FjaGUgPSB7fSk7XG5cbi8qKlxuICogRXhwb3NlIGB0b1JlZ2V4UmFuZ2VgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB0b1JlZ2V4UmFuZ2U7XG4iLCAiLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB0b1JlZ2V4UmFuZ2UgPSByZXF1aXJlKCd0by1yZWdleC1yYW5nZScpO1xuXG5jb25zdCBpc09iamVjdCA9IHZhbCA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcblxuY29uc3QgdHJhbnNmb3JtID0gdG9OdW1iZXIgPT4ge1xuICByZXR1cm4gdmFsdWUgPT4gdG9OdW1iZXIgPT09IHRydWUgPyBOdW1iZXIodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn07XG5cbmNvbnN0IGlzVmFsaWRWYWx1ZSA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUgIT09ICcnKTtcbn07XG5cbmNvbnN0IGlzTnVtYmVyID0gbnVtID0+IE51bWJlci5pc0ludGVnZXIoK251bSk7XG5cbmNvbnN0IHplcm9zID0gaW5wdXQgPT4ge1xuICBsZXQgdmFsdWUgPSBgJHtpbnB1dH1gO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgaWYgKHZhbHVlWzBdID09PSAnLScpIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gIGlmICh2YWx1ZSA9PT0gJzAnKSByZXR1cm4gZmFsc2U7XG4gIHdoaWxlICh2YWx1ZVsrK2luZGV4XSA9PT0gJzAnKTtcbiAgcmV0dXJuIGluZGV4ID4gMDtcbn07XG5cbmNvbnN0IHN0cmluZ2lmeSA9IChzdGFydCwgZW5kLCBvcHRpb25zKSA9PiB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMuc3RyaW5naWZ5ID09PSB0cnVlO1xufTtcblxuY29uc3QgcGFkID0gKGlucHV0LCBtYXhMZW5ndGgsIHRvTnVtYmVyKSA9PiB7XG4gIGlmIChtYXhMZW5ndGggPiAwKSB7XG4gICAgbGV0IGRhc2ggPSBpbnB1dFswXSA9PT0gJy0nID8gJy0nIDogJyc7XG4gICAgaWYgKGRhc2gpIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgaW5wdXQgPSAoZGFzaCArIGlucHV0LnBhZFN0YXJ0KGRhc2ggPyBtYXhMZW5ndGggLSAxIDogbWF4TGVuZ3RoLCAnMCcpKTtcbiAgfVxuICBpZiAodG9OdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIFN0cmluZyhpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuY29uc3QgdG9NYXhMZW4gPSAoaW5wdXQsIG1heExlbmd0aCkgPT4ge1xuICBsZXQgbmVnYXRpdmUgPSBpbnB1dFswXSA9PT0gJy0nID8gJy0nIDogJyc7XG4gIGlmIChuZWdhdGl2ZSkge1xuICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgbWF4TGVuZ3RoLS07XG4gIH1cbiAgd2hpbGUgKGlucHV0Lmxlbmd0aCA8IG1heExlbmd0aCkgaW5wdXQgPSAnMCcgKyBpbnB1dDtcbiAgcmV0dXJuIG5lZ2F0aXZlID8gKCctJyArIGlucHV0KSA6IGlucHV0O1xufTtcblxuY29uc3QgdG9TZXF1ZW5jZSA9IChwYXJ0cywgb3B0aW9ucykgPT4ge1xuICBwYXJ0cy5uZWdhdGl2ZXMuc29ydCgoYSwgYikgPT4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDApO1xuICBwYXJ0cy5wb3NpdGl2ZXMuc29ydCgoYSwgYikgPT4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDApO1xuXG4gIGxldCBwcmVmaXggPSBvcHRpb25zLmNhcHR1cmUgPyAnJyA6ICc/Oic7XG4gIGxldCBwb3NpdGl2ZXMgPSAnJztcbiAgbGV0IG5lZ2F0aXZlcyA9ICcnO1xuICBsZXQgcmVzdWx0O1xuXG4gIGlmIChwYXJ0cy5wb3NpdGl2ZXMubGVuZ3RoKSB7XG4gICAgcG9zaXRpdmVzID0gcGFydHMucG9zaXRpdmVzLmpvaW4oJ3wnKTtcbiAgfVxuXG4gIGlmIChwYXJ0cy5uZWdhdGl2ZXMubGVuZ3RoKSB7XG4gICAgbmVnYXRpdmVzID0gYC0oJHtwcmVmaXh9JHtwYXJ0cy5uZWdhdGl2ZXMuam9pbignfCcpfSlgO1xuICB9XG5cbiAgaWYgKHBvc2l0aXZlcyAmJiBuZWdhdGl2ZXMpIHtcbiAgICByZXN1bHQgPSBgJHtwb3NpdGl2ZXN9fCR7bmVnYXRpdmVzfWA7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gcG9zaXRpdmVzIHx8IG5lZ2F0aXZlcztcbiAgfVxuXG4gIGlmIChvcHRpb25zLndyYXApIHtcbiAgICByZXR1cm4gYCgke3ByZWZpeH0ke3Jlc3VsdH0pYDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCB0b1JhbmdlID0gKGEsIGIsIGlzTnVtYmVycywgb3B0aW9ucykgPT4ge1xuICBpZiAoaXNOdW1iZXJzKSB7XG4gICAgcmV0dXJuIHRvUmVnZXhSYW5nZShhLCBiLCB7IHdyYXA6IGZhbHNlLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgbGV0IHN0YXJ0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShhKTtcbiAgaWYgKGEgPT09IGIpIHJldHVybiBzdGFydDtcblxuICBsZXQgc3RvcCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gIHJldHVybiBgWyR7c3RhcnR9LSR7c3RvcH1dYDtcbn07XG5cbmNvbnN0IHRvUmVnZXggPSAoc3RhcnQsIGVuZCwgb3B0aW9ucykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdGFydCkpIHtcbiAgICBsZXQgd3JhcCA9IG9wdGlvbnMud3JhcCA9PT0gdHJ1ZTtcbiAgICBsZXQgcHJlZml4ID0gb3B0aW9ucy5jYXB0dXJlID8gJycgOiAnPzonO1xuICAgIHJldHVybiB3cmFwID8gYCgke3ByZWZpeH0ke3N0YXJ0LmpvaW4oJ3wnKX0pYCA6IHN0YXJ0LmpvaW4oJ3wnKTtcbiAgfVxuICByZXR1cm4gdG9SZWdleFJhbmdlKHN0YXJ0LCBlbmQsIG9wdGlvbnMpO1xufTtcblxuY29uc3QgcmFuZ2VFcnJvciA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCByYW5nZSBhcmd1bWVudHM6ICcgKyB1dGlsLmluc3BlY3QoLi4uYXJncykpO1xufTtcblxuY29uc3QgaW52YWxpZFJhbmdlID0gKHN0YXJ0LCBlbmQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMuc3RyaWN0UmFuZ2VzID09PSB0cnVlKSB0aHJvdyByYW5nZUVycm9yKFtzdGFydCwgZW5kXSk7XG4gIHJldHVybiBbXTtcbn07XG5cbmNvbnN0IGludmFsaWRTdGVwID0gKHN0ZXAsIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMuc3RyaWN0UmFuZ2VzID09PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgc3RlcCBcIiR7c3RlcH1cIiB0byBiZSBhIG51bWJlcmApO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5cbmNvbnN0IGZpbGxOdW1iZXJzID0gKHN0YXJ0LCBlbmQsIHN0ZXAgPSAxLCBvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IGEgPSBOdW1iZXIoc3RhcnQpO1xuICBsZXQgYiA9IE51bWJlcihlbmQpO1xuXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihhKSB8fCAhTnVtYmVyLmlzSW50ZWdlcihiKSkge1xuICAgIGlmIChvcHRpb25zLnN0cmljdFJhbmdlcyA9PT0gdHJ1ZSkgdGhyb3cgcmFuZ2VFcnJvcihbc3RhcnQsIGVuZF0pO1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIGZpeCBuZWdhdGl2ZSB6ZXJvXG4gIGlmIChhID09PSAwKSBhID0gMDtcbiAgaWYgKGIgPT09IDApIGIgPSAwO1xuXG4gIGxldCBkZXNjZW5kaW5nID0gYSA+IGI7XG4gIGxldCBzdGFydFN0cmluZyA9IFN0cmluZyhzdGFydCk7XG4gIGxldCBlbmRTdHJpbmcgPSBTdHJpbmcoZW5kKTtcbiAgbGV0IHN0ZXBTdHJpbmcgPSBTdHJpbmcoc3RlcCk7XG4gIHN0ZXAgPSBNYXRoLm1heChNYXRoLmFicyhzdGVwKSwgMSk7XG5cbiAgbGV0IHBhZGRlZCA9IHplcm9zKHN0YXJ0U3RyaW5nKSB8fCB6ZXJvcyhlbmRTdHJpbmcpIHx8IHplcm9zKHN0ZXBTdHJpbmcpO1xuICBsZXQgbWF4TGVuID0gcGFkZGVkID8gTWF0aC5tYXgoc3RhcnRTdHJpbmcubGVuZ3RoLCBlbmRTdHJpbmcubGVuZ3RoLCBzdGVwU3RyaW5nLmxlbmd0aCkgOiAwO1xuICBsZXQgdG9OdW1iZXIgPSBwYWRkZWQgPT09IGZhbHNlICYmIHN0cmluZ2lmeShzdGFydCwgZW5kLCBvcHRpb25zKSA9PT0gZmFsc2U7XG4gIGxldCBmb3JtYXQgPSBvcHRpb25zLnRyYW5zZm9ybSB8fCB0cmFuc2Zvcm0odG9OdW1iZXIpO1xuXG4gIGlmIChvcHRpb25zLnRvUmVnZXggJiYgc3RlcCA9PT0gMSkge1xuICAgIHJldHVybiB0b1JhbmdlKHRvTWF4TGVuKHN0YXJ0LCBtYXhMZW4pLCB0b01heExlbihlbmQsIG1heExlbiksIHRydWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgbGV0IHBhcnRzID0geyBuZWdhdGl2ZXM6IFtdLCBwb3NpdGl2ZXM6IFtdIH07XG4gIGxldCBwdXNoID0gbnVtID0+IHBhcnRzW251bSA8IDAgPyAnbmVnYXRpdmVzJyA6ICdwb3NpdGl2ZXMnXS5wdXNoKE1hdGguYWJzKG51bSkpO1xuICBsZXQgcmFuZ2UgPSBbXTtcbiAgbGV0IGluZGV4ID0gMDtcblxuICB3aGlsZSAoZGVzY2VuZGluZyA/IGEgPj0gYiA6IGEgPD0gYikge1xuICAgIGlmIChvcHRpb25zLnRvUmVnZXggPT09IHRydWUgJiYgc3RlcCA+IDEpIHtcbiAgICAgIHB1c2goYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnB1c2gocGFkKGZvcm1hdChhLCBpbmRleCksIG1heExlbiwgdG9OdW1iZXIpKTtcbiAgICB9XG4gICAgYSA9IGRlc2NlbmRpbmcgPyBhIC0gc3RlcCA6IGEgKyBzdGVwO1xuICAgIGluZGV4Kys7XG4gIH1cblxuICBpZiAob3B0aW9ucy50b1JlZ2V4ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHN0ZXAgPiAxXG4gICAgICA/IHRvU2VxdWVuY2UocGFydHMsIG9wdGlvbnMpXG4gICAgICA6IHRvUmVnZXgocmFuZ2UsIG51bGwsIHsgd3JhcDogZmFsc2UsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59O1xuXG5jb25zdCBmaWxsTGV0dGVycyA9IChzdGFydCwgZW5kLCBzdGVwID0gMSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmICgoIWlzTnVtYmVyKHN0YXJ0KSAmJiBzdGFydC5sZW5ndGggPiAxKSB8fCAoIWlzTnVtYmVyKGVuZCkgJiYgZW5kLmxlbmd0aCA+IDEpKSB7XG4gICAgcmV0dXJuIGludmFsaWRSYW5nZShzdGFydCwgZW5kLCBvcHRpb25zKTtcbiAgfVxuXG5cbiAgbGV0IGZvcm1hdCA9IG9wdGlvbnMudHJhbnNmb3JtIHx8ICh2YWwgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWwpKTtcbiAgbGV0IGEgPSBgJHtzdGFydH1gLmNoYXJDb2RlQXQoMCk7XG4gIGxldCBiID0gYCR7ZW5kfWAuY2hhckNvZGVBdCgwKTtcblxuICBsZXQgZGVzY2VuZGluZyA9IGEgPiBiO1xuICBsZXQgbWluID0gTWF0aC5taW4oYSwgYik7XG4gIGxldCBtYXggPSBNYXRoLm1heChhLCBiKTtcblxuICBpZiAob3B0aW9ucy50b1JlZ2V4ICYmIHN0ZXAgPT09IDEpIHtcbiAgICByZXR1cm4gdG9SYW5nZShtaW4sIG1heCwgZmFsc2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgbGV0IHJhbmdlID0gW107XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGRlc2NlbmRpbmcgPyBhID49IGIgOiBhIDw9IGIpIHtcbiAgICByYW5nZS5wdXNoKGZvcm1hdChhLCBpbmRleCkpO1xuICAgIGEgPSBkZXNjZW5kaW5nID8gYSAtIHN0ZXAgOiBhICsgc3RlcDtcbiAgICBpbmRleCsrO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudG9SZWdleCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0b1JlZ2V4KHJhbmdlLCBudWxsLCB7IHdyYXA6IGZhbHNlLCBvcHRpb25zIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuY29uc3QgZmlsbCA9IChzdGFydCwgZW5kLCBzdGVwLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKGVuZCA9PSBudWxsICYmIGlzVmFsaWRWYWx1ZShzdGFydCkpIHtcbiAgICByZXR1cm4gW3N0YXJ0XTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZFZhbHVlKHN0YXJ0KSB8fCAhaXNWYWxpZFZhbHVlKGVuZCkpIHtcbiAgICByZXR1cm4gaW52YWxpZFJhbmdlKHN0YXJ0LCBlbmQsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdGVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZpbGwoc3RhcnQsIGVuZCwgMSwgeyB0cmFuc2Zvcm06IHN0ZXAgfSk7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc3RlcCkpIHtcbiAgICByZXR1cm4gZmlsbChzdGFydCwgZW5kLCAwLCBzdGVwKTtcbiAgfVxuXG4gIGxldCBvcHRzID0geyAuLi5vcHRpb25zIH07XG4gIGlmIChvcHRzLmNhcHR1cmUgPT09IHRydWUpIG9wdHMud3JhcCA9IHRydWU7XG4gIHN0ZXAgPSBzdGVwIHx8IG9wdHMuc3RlcCB8fCAxO1xuXG4gIGlmICghaXNOdW1iZXIoc3RlcCkpIHtcbiAgICBpZiAoc3RlcCAhPSBudWxsICYmICFpc09iamVjdChzdGVwKSkgcmV0dXJuIGludmFsaWRTdGVwKHN0ZXAsIG9wdHMpO1xuICAgIHJldHVybiBmaWxsKHN0YXJ0LCBlbmQsIDEsIHN0ZXApO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKHN0YXJ0KSAmJiBpc051bWJlcihlbmQpKSB7XG4gICAgcmV0dXJuIGZpbGxOdW1iZXJzKHN0YXJ0LCBlbmQsIHN0ZXAsIG9wdHMpO1xuICB9XG5cbiAgcmV0dXJuIGZpbGxMZXR0ZXJzKHN0YXJ0LCBlbmQsIE1hdGgubWF4KE1hdGguYWJzKHN0ZXApLCAxKSwgb3B0cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGw7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmaWxsID0gcmVxdWlyZSgnZmlsbC1yYW5nZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNvbnN0IGNvbXBpbGUgPSAoYXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IHdhbGsgPSAobm9kZSwgcGFyZW50ID0ge30pID0+IHtcbiAgICBsZXQgaW52YWxpZEJsb2NrID0gdXRpbHMuaXNJbnZhbGlkQnJhY2UocGFyZW50KTtcbiAgICBsZXQgaW52YWxpZE5vZGUgPSBub2RlLmludmFsaWQgPT09IHRydWUgJiYgb3B0aW9ucy5lc2NhcGVJbnZhbGlkID09PSB0cnVlO1xuICAgIGxldCBpbnZhbGlkID0gaW52YWxpZEJsb2NrID09PSB0cnVlIHx8IGludmFsaWROb2RlID09PSB0cnVlO1xuICAgIGxldCBwcmVmaXggPSBvcHRpb25zLmVzY2FwZUludmFsaWQgPT09IHRydWUgPyAnXFxcXCcgOiAnJztcbiAgICBsZXQgb3V0cHV0ID0gJyc7XG5cbiAgICBpZiAobm9kZS5pc09wZW4gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBwcmVmaXggKyBub2RlLnZhbHVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5pc0Nsb3NlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ICsgbm9kZS52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnb3BlbicpIHtcbiAgICAgIHJldHVybiBpbnZhbGlkID8gKHByZWZpeCArIG5vZGUudmFsdWUpIDogJygnO1xuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdjbG9zZScpIHtcbiAgICAgIHJldHVybiBpbnZhbGlkID8gKHByZWZpeCArIG5vZGUudmFsdWUpIDogJyknO1xuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdjb21tYScpIHtcbiAgICAgIHJldHVybiBub2RlLnByZXYudHlwZSA9PT0gJ2NvbW1hJyA/ICcnIDogKGludmFsaWQgPyBub2RlLnZhbHVlIDogJ3wnKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubm9kZXMgJiYgbm9kZS5yYW5nZXMgPiAwKSB7XG4gICAgICBsZXQgYXJncyA9IHV0aWxzLnJlZHVjZShub2RlLm5vZGVzKTtcbiAgICAgIGxldCByYW5nZSA9IGZpbGwoLi4uYXJncywgeyAuLi5vcHRpb25zLCB3cmFwOiBmYWxzZSwgdG9SZWdleDogdHJ1ZSB9KTtcblxuICAgICAgaWYgKHJhbmdlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPiAxICYmIHJhbmdlLmxlbmd0aCA+IDEgPyBgKCR7cmFuZ2V9KWAgOiByYW5nZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5ub2Rlcykge1xuICAgICAgICBvdXRwdXQgKz0gd2FsayhjaGlsZCwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIHdhbGsoYXN0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZpbGwgPSByZXF1aXJlKCdmaWxsLXJhbmdlJyk7XG5jb25zdCBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNvbnN0IGFwcGVuZCA9IChxdWV1ZSA9ICcnLCBzdGFzaCA9ICcnLCBlbmNsb3NlID0gZmFsc2UpID0+IHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gIHF1ZXVlID0gW10uY29uY2F0KHF1ZXVlKTtcbiAgc3Rhc2ggPSBbXS5jb25jYXQoc3Rhc2gpO1xuXG4gIGlmICghc3Rhc2gubGVuZ3RoKSByZXR1cm4gcXVldWU7XG4gIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGVuY2xvc2UgPyB1dGlscy5mbGF0dGVuKHN0YXNoKS5tYXAoZWxlID0+IGB7JHtlbGV9fWApIDogc3Rhc2g7XG4gIH1cblxuICBmb3IgKGxldCBpdGVtIG9mIHF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZW0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYXBwZW5kKHZhbHVlLCBzdGFzaCwgZW5jbG9zZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBlbGUgb2Ygc3Rhc2gpIHtcbiAgICAgICAgaWYgKGVuY2xvc2UgPT09IHRydWUgJiYgdHlwZW9mIGVsZSA9PT0gJ3N0cmluZycpIGVsZSA9IGB7JHtlbGV9fWA7XG4gICAgICAgIHJlc3VsdC5wdXNoKEFycmF5LmlzQXJyYXkoZWxlKSA/IGFwcGVuZChpdGVtLCBlbGUsIGVuY2xvc2UpIDogKGl0ZW0gKyBlbGUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHV0aWxzLmZsYXR0ZW4ocmVzdWx0KTtcbn07XG5cbmNvbnN0IGV4cGFuZCA9IChhc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQgcmFuZ2VMaW1pdCA9IG9wdGlvbnMucmFuZ2VMaW1pdCA9PT0gdm9pZCAwID8gMTAwMCA6IG9wdGlvbnMucmFuZ2VMaW1pdDtcblxuICBsZXQgd2FsayA9IChub2RlLCBwYXJlbnQgPSB7fSkgPT4ge1xuICAgIG5vZGUucXVldWUgPSBbXTtcblxuICAgIGxldCBwID0gcGFyZW50O1xuICAgIGxldCBxID0gcGFyZW50LnF1ZXVlO1xuXG4gICAgd2hpbGUgKHAudHlwZSAhPT0gJ2JyYWNlJyAmJiBwLnR5cGUgIT09ICdyb290JyAmJiBwLnBhcmVudCkge1xuICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgcSA9IHAucXVldWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuaW52YWxpZCB8fCBub2RlLmRvbGxhcikge1xuICAgICAgcS5wdXNoKGFwcGVuZChxLnBvcCgpLCBzdHJpbmdpZnkobm9kZSwgb3B0aW9ucykpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnYnJhY2UnICYmIG5vZGUuaW52YWxpZCAhPT0gdHJ1ZSAmJiBub2RlLm5vZGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcS5wdXNoKGFwcGVuZChxLnBvcCgpLCBbJ3t9J10pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2RlcyAmJiBub2RlLnJhbmdlcyA+IDApIHtcbiAgICAgIGxldCBhcmdzID0gdXRpbHMucmVkdWNlKG5vZGUubm9kZXMpO1xuXG4gICAgICBpZiAodXRpbHMuZXhjZWVkc0xpbWl0KC4uLmFyZ3MsIG9wdGlvbnMuc3RlcCwgcmFuZ2VMaW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2V4cGFuZGVkIGFycmF5IGxlbmd0aCBleGNlZWRzIHJhbmdlIGxpbWl0LiBVc2Ugb3B0aW9ucy5yYW5nZUxpbWl0IHRvIGluY3JlYXNlIG9yIGRpc2FibGUgdGhlIGxpbWl0LicpO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmFuZ2UgPSBmaWxsKC4uLmFyZ3MsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByYW5nZSA9IHN0cmluZ2lmeShub2RlLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcS5wdXNoKGFwcGVuZChxLnBvcCgpLCByYW5nZSkpO1xuICAgICAgbm9kZS5ub2RlcyA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBlbmNsb3NlID0gdXRpbHMuZW5jbG9zZUJyYWNlKG5vZGUpO1xuICAgIGxldCBxdWV1ZSA9IG5vZGUucXVldWU7XG4gICAgbGV0IGJsb2NrID0gbm9kZTtcblxuICAgIHdoaWxlIChibG9jay50eXBlICE9PSAnYnJhY2UnICYmIGJsb2NrLnR5cGUgIT09ICdyb290JyAmJiBibG9jay5wYXJlbnQpIHtcbiAgICAgIGJsb2NrID0gYmxvY2sucGFyZW50O1xuICAgICAgcXVldWUgPSBibG9jay5xdWV1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjaGlsZCA9IG5vZGUubm9kZXNbaV07XG5cbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAnY29tbWEnICYmIG5vZGUudHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICBpZiAoaSA9PT0gMSkgcXVldWUucHVzaCgnJyk7XG4gICAgICAgIHF1ZXVlLnB1c2goJycpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdjbG9zZScpIHtcbiAgICAgICAgcS5wdXNoKGFwcGVuZChxLnBvcCgpLCBxdWV1ZSwgZW5jbG9zZSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLnZhbHVlICYmIGNoaWxkLnR5cGUgIT09ICdvcGVuJykge1xuICAgICAgICBxdWV1ZS5wdXNoKGFwcGVuZChxdWV1ZS5wb3AoKSwgY2hpbGQudmFsdWUpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5ub2Rlcykge1xuICAgICAgICB3YWxrKGNoaWxkLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWU7XG4gIH07XG5cbiAgcmV0dXJuIHV0aWxzLmZsYXR0ZW4od2Fsayhhc3QpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwYW5kO1xuIiwgIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1BWF9MRU5HVEg6IDEwMjQgKiA2NCxcblxuICAvLyBEaWdpdHNcbiAgQ0hBUl8wOiAnMCcsIC8qIDAgKi9cbiAgQ0hBUl85OiAnOScsIC8qIDkgKi9cblxuICAvLyBBbHBoYWJldCBjaGFycy5cbiAgQ0hBUl9VUFBFUkNBU0VfQTogJ0EnLCAvKiBBICovXG4gIENIQVJfTE9XRVJDQVNFX0E6ICdhJywgLyogYSAqL1xuICBDSEFSX1VQUEVSQ0FTRV9aOiAnWicsIC8qIFogKi9cbiAgQ0hBUl9MT1dFUkNBU0VfWjogJ3onLCAvKiB6ICovXG5cbiAgQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOiAnKCcsIC8qICggKi9cbiAgQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzogJyknLCAvKiApICovXG5cbiAgQ0hBUl9BU1RFUklTSzogJyonLCAvKiAqICovXG5cbiAgLy8gTm9uLWFscGhhYmV0aWMgY2hhcnMuXG4gIENIQVJfQU1QRVJTQU5EOiAnJicsIC8qICYgKi9cbiAgQ0hBUl9BVDogJ0AnLCAvKiBAICovXG4gIENIQVJfQkFDS1NMQVNIOiAnXFxcXCcsIC8qIFxcICovXG4gIENIQVJfQkFDS1RJQ0s6ICdgJywgLyogYCAqL1xuICBDSEFSX0NBUlJJQUdFX1JFVFVSTjogJ1xccicsIC8qIFxcciAqL1xuICBDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOiAnXicsIC8qIF4gKi9cbiAgQ0hBUl9DT0xPTjogJzonLCAvKiA6ICovXG4gIENIQVJfQ09NTUE6ICcsJywgLyogLCAqL1xuICBDSEFSX0RPTExBUjogJyQnLCAvKiAuICovXG4gIENIQVJfRE9UOiAnLicsIC8qIC4gKi9cbiAgQ0hBUl9ET1VCTEVfUVVPVEU6ICdcIicsIC8qIFwiICovXG4gIENIQVJfRVFVQUw6ICc9JywgLyogPSAqL1xuICBDSEFSX0VYQ0xBTUFUSU9OX01BUks6ICchJywgLyogISAqL1xuICBDSEFSX0ZPUk1fRkVFRDogJ1xcZicsIC8qIFxcZiAqL1xuICBDSEFSX0ZPUldBUkRfU0xBU0g6ICcvJywgLyogLyAqL1xuICBDSEFSX0hBU0g6ICcjJywgLyogIyAqL1xuICBDSEFSX0hZUEhFTl9NSU5VUzogJy0nLCAvKiAtICovXG4gIENIQVJfTEVGVF9BTkdMRV9CUkFDS0VUOiAnPCcsIC8qIDwgKi9cbiAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOiAneycsIC8qIHsgKi9cbiAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOiAnWycsIC8qIFsgKi9cbiAgQ0hBUl9MSU5FX0ZFRUQ6ICdcXG4nLCAvKiBcXG4gKi9cbiAgQ0hBUl9OT19CUkVBS19TUEFDRTogJ1xcdTAwQTAnLCAvKiBcXHUwMEEwICovXG4gIENIQVJfUEVSQ0VOVDogJyUnLCAvKiAlICovXG4gIENIQVJfUExVUzogJysnLCAvKiArICovXG4gIENIQVJfUVVFU1RJT05fTUFSSzogJz8nLCAvKiA/ICovXG4gIENIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVDogJz4nLCAvKiA+ICovXG4gIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6ICd9JywgLyogfSAqL1xuICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOiAnXScsIC8qIF0gKi9cbiAgQ0hBUl9TRU1JQ09MT046ICc7JywgLyogOyAqL1xuICBDSEFSX1NJTkdMRV9RVU9URTogJ1xcJycsIC8qICcgKi9cbiAgQ0hBUl9TUEFDRTogJyAnLCAvKiAgICovXG4gIENIQVJfVEFCOiAnXFx0JywgLyogXFx0ICovXG4gIENIQVJfVU5ERVJTQ09SRTogJ18nLCAvKiBfICovXG4gIENIQVJfVkVSVElDQUxfTElORTogJ3wnLCAvKiB8ICovXG4gIENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOiAnXFx1RkVGRicgLyogXFx1RkVGRiAqL1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3Qge1xuICBNQVhfTEVOR1RILFxuICBDSEFSX0JBQ0tTTEFTSCwgLyogXFwgKi9cbiAgQ0hBUl9CQUNLVElDSywgLyogYCAqL1xuICBDSEFSX0NPTU1BLCAvKiAsICovXG4gIENIQVJfRE9ULCAvKiAuICovXG4gIENIQVJfTEVGVF9QQVJFTlRIRVNFUywgLyogKCAqL1xuICBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTLCAvKiApICovXG4gIENIQVJfTEVGVF9DVVJMWV9CUkFDRSwgLyogeyAqL1xuICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFLCAvKiB9ICovXG4gIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCwgLyogWyAqL1xuICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VULCAvKiBdICovXG4gIENIQVJfRE9VQkxFX1FVT1RFLCAvKiBcIiAqL1xuICBDSEFSX1NJTkdMRV9RVU9URSwgLyogJyAqL1xuICBDSEFSX05PX0JSRUFLX1NQQUNFLFxuICBDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRVxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8qKlxuICogcGFyc2VcbiAqL1xuXG5jb25zdCBwYXJzZSA9IChpbnB1dCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGxldCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG1heCA9IHR5cGVvZiBvcHRzLm1heExlbmd0aCA9PT0gJ251bWJlcicgPyBNYXRoLm1pbihNQVhfTEVOR1RILCBvcHRzLm1heExlbmd0aCkgOiBNQVhfTEVOR1RIO1xuICBpZiAoaW5wdXQubGVuZ3RoID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGggKCR7aW5wdXQubGVuZ3RofSksIGV4Y2VlZHMgbWF4IGNoYXJhY3RlcnMgKCR7bWF4fSlgKTtcbiAgfVxuXG4gIGxldCBhc3QgPSB7IHR5cGU6ICdyb290JywgaW5wdXQsIG5vZGVzOiBbXSB9O1xuICBsZXQgc3RhY2sgPSBbYXN0XTtcbiAgbGV0IGJsb2NrID0gYXN0O1xuICBsZXQgcHJldiA9IGFzdDtcbiAgbGV0IGJyYWNrZXRzID0gMDtcbiAgbGV0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGRlcHRoID0gMDtcbiAgbGV0IHZhbHVlO1xuICBsZXQgbWVtbyA9IHt9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuXG4gIGNvbnN0IGFkdmFuY2UgPSAoKSA9PiBpbnB1dFtpbmRleCsrXTtcbiAgY29uc3QgcHVzaCA9IG5vZGUgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICd0ZXh0JyAmJiBwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG4gICAgICBwcmV2LnR5cGUgPSAndGV4dCc7XG4gICAgfVxuXG4gICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSAndGV4dCcgJiYgbm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHByZXYudmFsdWUgKz0gbm9kZS52YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBibG9jay5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIG5vZGUucGFyZW50ID0gYmxvY2s7XG4gICAgbm9kZS5wcmV2ID0gcHJldjtcbiAgICBwcmV2ID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBwdXNoKHsgdHlwZTogJ2JvcycgfSk7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgYmxvY2sgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICB2YWx1ZSA9IGFkdmFuY2UoKTtcblxuICAgIC8qKlxuICAgICAqIEludmFsaWQgY2hhcnNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0UgfHwgdmFsdWUgPT09IENIQVJfTk9fQlJFQUtfU1BBQ0UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZWQgY2hhcnNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9CQUNLU0xBU0gpIHtcbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlOiAob3B0aW9ucy5rZWVwRXNjYXBpbmcgPyB2YWx1ZSA6ICcnKSArIGFkdmFuY2UoKSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJpZ2h0IHNxdWFyZSBicmFja2V0IChsaXRlcmFsKTogJ10nXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQpIHtcbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlOiAnXFxcXCcgKyB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZnQgc3F1YXJlIGJyYWNrZXQ6ICdbJ1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQpIHtcbiAgICAgIGJyYWNrZXRzKys7XG5cbiAgICAgIGxldCBjbG9zZWQgPSB0cnVlO1xuICAgICAgbGV0IG5leHQ7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiAobmV4dCA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgdmFsdWUgKz0gbmV4dDtcblxuICAgICAgICBpZiAobmV4dCA9PT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUKSB7XG4gICAgICAgICAgYnJhY2tldHMrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ID09PSBDSEFSX0JBQ0tTTEFTSCkge1xuICAgICAgICAgIHZhbHVlICs9IGFkdmFuY2UoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ID09PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUKSB7XG4gICAgICAgICAgYnJhY2tldHMtLTtcblxuICAgICAgICAgIGlmIChicmFja2V0cyA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyZW50aGVzZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG4gICAgICBibG9jayA9IHB1c2goeyB0eXBlOiAncGFyZW4nLCBub2RlczogW10gfSk7XG4gICAgICBzdGFjay5wdXNoKGJsb2NrKTtcbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTKSB7XG4gICAgICBpZiAoYmxvY2sudHlwZSAhPT0gJ3BhcmVuJykge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBibG9jayA9IHN0YWNrLnBvcCgpO1xuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBibG9jayA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVvdGVzOiAnfFwifGBcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9ET1VCTEVfUVVPVEUgfHwgdmFsdWUgPT09IENIQVJfU0lOR0xFX1FVT1RFIHx8IHZhbHVlID09PSBDSEFSX0JBQ0tUSUNLKSB7XG4gICAgICBsZXQgb3BlbiA9IHZhbHVlO1xuICAgICAgbGV0IG5leHQ7XG5cbiAgICAgIGlmIChvcHRpb25zLmtlZXBRdW90ZXMgIT09IHRydWUpIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoICYmIChuZXh0ID0gYWR2YW5jZSgpKSkge1xuICAgICAgICBpZiAobmV4dCA9PT0gQ0hBUl9CQUNLU0xBU0gpIHtcbiAgICAgICAgICB2YWx1ZSArPSBuZXh0ICsgYWR2YW5jZSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHQgPT09IG9wZW4pIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwUXVvdGVzID09PSB0cnVlKSB2YWx1ZSArPSBuZXh0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgKz0gbmV4dDtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWZ0IGN1cmx5IGJyYWNlOiAneydcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNFKSB7XG4gICAgICBkZXB0aCsrO1xuXG4gICAgICBsZXQgZG9sbGFyID0gcHJldi52YWx1ZSAmJiBwcmV2LnZhbHVlLnNsaWNlKC0xKSA9PT0gJyQnIHx8IGJsb2NrLmRvbGxhciA9PT0gdHJ1ZTtcbiAgICAgIGxldCBicmFjZSA9IHtcbiAgICAgICAgdHlwZTogJ2JyYWNlJyxcbiAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgY2xvc2U6IGZhbHNlLFxuICAgICAgICBkb2xsYXIsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBjb21tYXM6IDAsXG4gICAgICAgIHJhbmdlczogMCxcbiAgICAgICAgbm9kZXM6IFtdXG4gICAgICB9O1xuXG4gICAgICBibG9jayA9IHB1c2goYnJhY2UpO1xuICAgICAgc3RhY2sucHVzaChibG9jayk7XG4gICAgICBwdXNoKHsgdHlwZTogJ29wZW4nLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJpZ2h0IGN1cmx5IGJyYWNlOiAnfSdcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSkge1xuICAgICAgaWYgKGJsb2NrLnR5cGUgIT09ICdicmFjZScpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgdHlwZSA9ICdjbG9zZSc7XG4gICAgICBibG9jayA9IHN0YWNrLnBvcCgpO1xuICAgICAgYmxvY2suY2xvc2UgPSB0cnVlO1xuXG4gICAgICBwdXNoKHsgdHlwZSwgdmFsdWUgfSk7XG4gICAgICBkZXB0aC0tO1xuXG4gICAgICBibG9jayA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tbWE6ICcsJ1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSBDSEFSX0NPTU1BICYmIGRlcHRoID4gMCkge1xuICAgICAgaWYgKGJsb2NrLnJhbmdlcyA+IDApIHtcbiAgICAgICAgYmxvY2sucmFuZ2VzID0gMDtcbiAgICAgICAgbGV0IG9wZW4gPSBibG9jay5ub2Rlcy5zaGlmdCgpO1xuICAgICAgICBibG9jay5ub2RlcyA9IFtvcGVuLCB7IHR5cGU6ICd0ZXh0JywgdmFsdWU6IHN0cmluZ2lmeShibG9jaykgfV07XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnY29tbWEnLCB2YWx1ZSB9KTtcbiAgICAgIGJsb2NrLmNvbW1hcysrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG90OiAnLidcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gQ0hBUl9ET1QgJiYgZGVwdGggPiAwICYmIGJsb2NrLmNvbW1hcyA9PT0gMCkge1xuICAgICAgbGV0IHNpYmxpbmdzID0gYmxvY2subm9kZXM7XG5cbiAgICAgIGlmIChkZXB0aCA9PT0gMCB8fCBzaWJsaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldi50eXBlID09PSAnZG90Jykge1xuICAgICAgICBibG9jay5yYW5nZSA9IFtdO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICBwcmV2LnR5cGUgPSAncmFuZ2UnO1xuXG4gICAgICAgIGlmIChibG9jay5ub2Rlcy5sZW5ndGggIT09IDMgJiYgYmxvY2subm9kZXMubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgYmxvY2suaW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgYmxvY2sucmFuZ2VzID0gMDtcbiAgICAgICAgICBwcmV2LnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBibG9jay5yYW5nZXMrKztcbiAgICAgICAgYmxvY2suYXJncyA9IFtdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICBzaWJsaW5ncy5wb3AoKTtcblxuICAgICAgICBsZXQgYmVmb3JlID0gc2libGluZ3Nbc2libGluZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGJlZm9yZS52YWx1ZSArPSBwcmV2LnZhbHVlICsgdmFsdWU7XG4gICAgICAgIHByZXYgPSBiZWZvcmU7XG4gICAgICAgIGJsb2NrLnJhbmdlcy0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdkb3QnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRleHRcbiAgICAgKi9cblxuICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICB9XG5cbiAgLy8gTWFyayBpbWJhbGFuY2VkIGJyYWNlcyBhbmQgYnJhY2tldHMgYXMgaW52YWxpZFxuICBkbyB7XG4gICAgYmxvY2sgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChibG9jay50eXBlICE9PSAncm9vdCcpIHtcbiAgICAgIGJsb2NrLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5ub2Rlcykge1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdvcGVuJykgbm9kZS5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdjbG9zZScpIG5vZGUuaXNDbG9zZSA9IHRydWU7XG4gICAgICAgICAgaWYgKCFub2RlLm5vZGVzKSBub2RlLnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgbm9kZS5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGdldCB0aGUgbG9jYXRpb24gb2YgdGhlIGJsb2NrIG9uIHBhcmVudC5ub2RlcyAoYmxvY2sncyBzaWJsaW5ncylcbiAgICAgIGxldCBwYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGxldCBpbmRleCA9IHBhcmVudC5ub2Rlcy5pbmRleE9mKGJsb2NrKTtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIChpbnZhbGlkKSBibG9jayB3aXRoIGl0J3Mgbm9kZXNcbiAgICAgIHBhcmVudC5ub2Rlcy5zcGxpY2UoaW5kZXgsIDEsIC4uLmJsb2NrLm5vZGVzKTtcbiAgICB9XG4gIH0gd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApO1xuXG4gIHB1c2goeyB0eXBlOiAnZW9zJyB9KTtcbiAgcmV0dXJuIGFzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcbmNvbnN0IGNvbXBpbGUgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlJyk7XG5jb25zdCBleHBhbmQgPSByZXF1aXJlKCcuL2xpYi9leHBhbmQnKTtcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKTtcblxuLyoqXG4gKiBFeHBhbmQgdGhlIGdpdmVuIHBhdHRlcm4gb3IgY3JlYXRlIGEgcmVnZXgtY29tcGF0aWJsZSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogY29uc29sZS5sb2coYnJhY2VzKCd7YSxiLGN9JywgeyBjb21waWxlOiB0cnVlIH0pKTsgLy89PiBbJyhhfGJ8YyknXVxuICogY29uc29sZS5sb2coYnJhY2VzKCd7YSxiLGN9JykpOyAvLz0+IFsnYScsICdiJywgJ2MnXVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY29uc3QgYnJhY2VzID0gKGlucHV0LCBvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IG91dHB1dCA9IFtdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGZvciAobGV0IHBhdHRlcm4gb2YgaW5wdXQpIHtcbiAgICAgIGxldCByZXN1bHQgPSBicmFjZXMuY3JlYXRlKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICBvdXRwdXQucHVzaCguLi5yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gW10uY29uY2F0KGJyYWNlcy5jcmVhdGUoaW5wdXQsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXhwYW5kID09PSB0cnVlICYmIG9wdGlvbnMubm9kdXBlcyA9PT0gdHJ1ZSkge1xuICAgIG91dHB1dCA9IFsuLi5uZXcgU2V0KG91dHB1dCldO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIC8vIGJyYWNlcy5wYXJzZShwYXR0ZXJuLCBbLCBvcHRpb25zXSk7XG4gKiBjb25zdCBhc3QgPSBicmFjZXMucGFyc2UoJ2Eve2IsY30vZCcpO1xuICogY29uc29sZS5sb2coYXN0KTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gQnJhY2UgcGF0dGVybiB0byBwYXJzZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBBU1RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLnBhcnNlID0gKGlucHV0LCBvcHRpb25zID0ge30pID0+IHBhcnNlKGlucHV0LCBvcHRpb25zKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYnJhY2VzIHN0cmluZyBmcm9tIGFuIEFTVCwgb3IgYW4gQVNUIG5vZGUuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogbGV0IGFzdCA9IGJyYWNlcy5wYXJzZSgnZm9vL3thLGJ9L2JhcicpO1xuICogY29uc29sZS5sb2coc3RyaW5naWZ5KGFzdC5ub2Rlc1syXSkpOyAvLz0+ICd7YSxifSdcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGAgQnJhY2UgcGF0dGVybiBvciBBU1QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBleHBhbmRlZCB2YWx1ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5zdHJpbmdpZnkgPSAoaW5wdXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmdpZnkoYnJhY2VzLnBhcnNlKGlucHV0LCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeShpbnB1dCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbXBpbGVzIGEgYnJhY2UgcGF0dGVybiBpbnRvIGEgcmVnZXgtY29tcGF0aWJsZSwgb3B0aW1pemVkIHN0cmluZy5cbiAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgbWFpbiBbYnJhY2VzXSgjYnJhY2VzKSBmdW5jdGlvbiBieSBkZWZhdWx0LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNlcy5jb21waWxlKCdhL3tiLGN9L2QnKSk7XG4gKiAvLz0+IFsnYS8oYnxjKS9kJ11cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGAgQnJhY2UgcGF0dGVybiBvciBBU1QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBleHBhbmRlZCB2YWx1ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5jb21waWxlID0gKGlucHV0LCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICBpbnB1dCA9IGJyYWNlcy5wYXJzZShpbnB1dCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGNvbXBpbGUoaW5wdXQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeHBhbmRzIGEgYnJhY2UgcGF0dGVybiBpbnRvIGFuIGFycmF5LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlXG4gKiBtYWluIFticmFjZXNdKCNicmFjZXMpIGZ1bmN0aW9uIHdoZW4gYG9wdGlvbnMuZXhwYW5kYCBpcyB0cnVlLiBCZWZvcmVcbiAqIHVzaW5nIHRoaXMgbWV0aG9kIGl0J3MgcmVjb21tZW5kZWQgdGhhdCB5b3UgcmVhZCB0aGUgW3BlcmZvcm1hbmNlIG5vdGVzXSgjcGVyZm9ybWFuY2UpKVxuICogYW5kIGFkdmFudGFnZXMgb2YgdXNpbmcgWy5jb21waWxlXSgjY29tcGlsZSkgaW5zdGVhZC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYnJhY2VzID0gcmVxdWlyZSgnYnJhY2VzJyk7XG4gKiBjb25zb2xlLmxvZyhicmFjZXMuZXhwYW5kKCdhL3tiLGN9L2QnKSk7XG4gKiAvLz0+IFsnYS9iL2QnLCAnYS9jL2QnXTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBCcmFjZSBwYXR0ZXJuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBleHBhbmRlZCB2YWx1ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5leHBhbmQgPSAoaW5wdXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIGlucHV0ID0gYnJhY2VzLnBhcnNlKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGxldCByZXN1bHQgPSBleHBhbmQoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIC8vIGZpbHRlciBvdXQgZW1wdHkgc3RyaW5ncyBpZiBzcGVjaWZpZWRcbiAgaWYgKG9wdGlvbnMubm9lbXB0eSA9PT0gdHJ1ZSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoQm9vbGVhbik7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IGR1cGxpY2F0ZXMgaWYgc3BlY2lmaWVkXG4gIGlmIChvcHRpb25zLm5vZHVwZXMgPT09IHRydWUpIHtcbiAgICByZXN1bHQgPSBbLi4ubmV3IFNldChyZXN1bHQpXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhIGJyYWNlIHBhdHRlcm4gYW5kIHJldHVybnMgZWl0aGVyIGFuIGV4cGFuZGVkIGFycmF5XG4gKiAoaWYgYG9wdGlvbnMuZXhwYW5kYCBpcyB0cnVlKSwgYSBoaWdobHkgb3B0aW1pemVkIHJlZ2V4LWNvbXBhdGlibGUgc3RyaW5nLlxuICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBtYWluIFticmFjZXNdKCNicmFjZXMpIGZ1bmN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNlcy5jcmVhdGUoJ3VzZXItezIwMC4uMzAwfS9wcm9qZWN0LXthLGIsY30tezEuLjEwfScpKVxuICogLy89PiAndXNlci0oMjBbMC05XXwyWzEtOV1bMC05XXwzMDApL3Byb2plY3QtKGF8YnxjKS0oWzEtOV18MTApJ1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEJyYWNlIHBhdHRlcm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGV4cGFuZGVkIHZhbHVlcy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLmNyZWF0ZSA9IChpbnB1dCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChpbnB1dCA9PT0gJycgfHwgaW5wdXQubGVuZ3RoIDwgMykge1xuICAgIHJldHVybiBbaW5wdXRdO1xuICB9XG5cbiByZXR1cm4gb3B0aW9ucy5leHBhbmQgIT09IHRydWVcbiAgICA/IGJyYWNlcy5jb21waWxlKGlucHV0LCBvcHRpb25zKVxuICAgIDogYnJhY2VzLmV4cGFuZChpbnB1dCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBcImJyYWNlc1wiXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBicmFjZXM7XG4iLCAiW1xuXHRcIjNkbVwiLFxuXHRcIjNkc1wiLFxuXHRcIjNnMlwiLFxuXHRcIjNncFwiLFxuXHRcIjd6XCIsXG5cdFwiYVwiLFxuXHRcImFhY1wiLFxuXHRcImFkcFwiLFxuXHRcImFmZGVzaWduXCIsXG5cdFwiYWZwaG90b1wiLFxuXHRcImFmcHViXCIsXG5cdFwiYWlcIixcblx0XCJhaWZcIixcblx0XCJhaWZmXCIsXG5cdFwiYWx6XCIsXG5cdFwiYXBlXCIsXG5cdFwiYXBrXCIsXG5cdFwiYXBwaW1hZ2VcIixcblx0XCJhclwiLFxuXHRcImFyalwiLFxuXHRcImFzZlwiLFxuXHRcImF1XCIsXG5cdFwiYXZpXCIsXG5cdFwiYmFrXCIsXG5cdFwiYmFtbFwiLFxuXHRcImJoXCIsXG5cdFwiYmluXCIsXG5cdFwiYmtcIixcblx0XCJibXBcIixcblx0XCJidGlmXCIsXG5cdFwiYnoyXCIsXG5cdFwiYnppcDJcIixcblx0XCJjYWJcIixcblx0XCJjYWZcIixcblx0XCJjZ21cIixcblx0XCJjbGFzc1wiLFxuXHRcImNteFwiLFxuXHRcImNwaW9cIixcblx0XCJjcjJcIixcblx0XCJjdXJcIixcblx0XCJkYXRcIixcblx0XCJkY21cIixcblx0XCJkZWJcIixcblx0XCJkZXhcIixcblx0XCJkanZ1XCIsXG5cdFwiZGxsXCIsXG5cdFwiZG1nXCIsXG5cdFwiZG5nXCIsXG5cdFwiZG9jXCIsXG5cdFwiZG9jbVwiLFxuXHRcImRvY3hcIixcblx0XCJkb3RcIixcblx0XCJkb3RtXCIsXG5cdFwiZHJhXCIsXG5cdFwiRFNfU3RvcmVcIixcblx0XCJkc2tcIixcblx0XCJkdHNcIixcblx0XCJkdHNoZFwiLFxuXHRcImR2YlwiLFxuXHRcImR3Z1wiLFxuXHRcImR4ZlwiLFxuXHRcImVjZWxwNDgwMFwiLFxuXHRcImVjZWxwNzQ3MFwiLFxuXHRcImVjZWxwOTYwMFwiLFxuXHRcImVnZ1wiLFxuXHRcImVvbFwiLFxuXHRcImVvdFwiLFxuXHRcImVwdWJcIixcblx0XCJleGVcIixcblx0XCJmNHZcIixcblx0XCJmYnNcIixcblx0XCJmaFwiLFxuXHRcImZsYVwiLFxuXHRcImZsYWNcIixcblx0XCJmbGF0cGFrXCIsXG5cdFwiZmxpXCIsXG5cdFwiZmx2XCIsXG5cdFwiZnB4XCIsXG5cdFwiZnN0XCIsXG5cdFwiZnZ0XCIsXG5cdFwiZzNcIixcblx0XCJnaFwiLFxuXHRcImdpZlwiLFxuXHRcImdyYWZmbGVcIixcblx0XCJnelwiLFxuXHRcImd6aXBcIixcblx0XCJoMjYxXCIsXG5cdFwiaDI2M1wiLFxuXHRcImgyNjRcIixcblx0XCJpY25zXCIsXG5cdFwiaWNvXCIsXG5cdFwiaWVmXCIsXG5cdFwiaW1nXCIsXG5cdFwiaXBhXCIsXG5cdFwiaXNvXCIsXG5cdFwiamFyXCIsXG5cdFwianBlZ1wiLFxuXHRcImpwZ1wiLFxuXHRcImpwZ3ZcIixcblx0XCJqcG1cIixcblx0XCJqeHJcIixcblx0XCJrZXlcIixcblx0XCJrdHhcIixcblx0XCJsaGFcIixcblx0XCJsaWJcIixcblx0XCJsdnBcIixcblx0XCJselwiLFxuXHRcImx6aFwiLFxuXHRcImx6bWFcIixcblx0XCJsem9cIixcblx0XCJtM3VcIixcblx0XCJtNGFcIixcblx0XCJtNHZcIixcblx0XCJtYXJcIixcblx0XCJtZGlcIixcblx0XCJtaHRcIixcblx0XCJtaWRcIixcblx0XCJtaWRpXCIsXG5cdFwibWoyXCIsXG5cdFwibWthXCIsXG5cdFwibWt2XCIsXG5cdFwibW1yXCIsXG5cdFwibW5nXCIsXG5cdFwibW9iaVwiLFxuXHRcIm1vdlwiLFxuXHRcIm1vdmllXCIsXG5cdFwibXAzXCIsXG5cdFwibXA0XCIsXG5cdFwibXA0YVwiLFxuXHRcIm1wZWdcIixcblx0XCJtcGdcIixcblx0XCJtcGdhXCIsXG5cdFwibXh1XCIsXG5cdFwibmVmXCIsXG5cdFwibnB4XCIsXG5cdFwibnVtYmVyc1wiLFxuXHRcIm51cGtnXCIsXG5cdFwib1wiLFxuXHRcIm9kcFwiLFxuXHRcIm9kc1wiLFxuXHRcIm9kdFwiLFxuXHRcIm9nYVwiLFxuXHRcIm9nZ1wiLFxuXHRcIm9ndlwiLFxuXHRcIm90ZlwiLFxuXHRcIm90dFwiLFxuXHRcInBhZ2VzXCIsXG5cdFwicGJtXCIsXG5cdFwicGN4XCIsXG5cdFwicGRiXCIsXG5cdFwicGRmXCIsXG5cdFwicGVhXCIsXG5cdFwicGdtXCIsXG5cdFwicGljXCIsXG5cdFwicG5nXCIsXG5cdFwicG5tXCIsXG5cdFwicG90XCIsXG5cdFwicG90bVwiLFxuXHRcInBvdHhcIixcblx0XCJwcGFcIixcblx0XCJwcGFtXCIsXG5cdFwicHBtXCIsXG5cdFwicHBzXCIsXG5cdFwicHBzbVwiLFxuXHRcInBwc3hcIixcblx0XCJwcHRcIixcblx0XCJwcHRtXCIsXG5cdFwicHB0eFwiLFxuXHRcInBzZFwiLFxuXHRcInB5YVwiLFxuXHRcInB5Y1wiLFxuXHRcInB5b1wiLFxuXHRcInB5dlwiLFxuXHRcInF0XCIsXG5cdFwicmFyXCIsXG5cdFwicmFzXCIsXG5cdFwicmF3XCIsXG5cdFwicmVzb3VyY2VzXCIsXG5cdFwicmdiXCIsXG5cdFwicmlwXCIsXG5cdFwicmxjXCIsXG5cdFwicm1mXCIsXG5cdFwicm12YlwiLFxuXHRcInJwbVwiLFxuXHRcInJ0ZlwiLFxuXHRcInJ6XCIsXG5cdFwiczNtXCIsXG5cdFwiczd6XCIsXG5cdFwic2NwdFwiLFxuXHRcInNnaVwiLFxuXHRcInNoYXJcIixcblx0XCJzbmFwXCIsXG5cdFwic2lsXCIsXG5cdFwic2tldGNoXCIsXG5cdFwic2xrXCIsXG5cdFwic212XCIsXG5cdFwic25rXCIsXG5cdFwic29cIixcblx0XCJzdGxcIixcblx0XCJzdW9cIixcblx0XCJzdWJcIixcblx0XCJzd2ZcIixcblx0XCJ0YXJcIixcblx0XCJ0YnpcIixcblx0XCJ0YnoyXCIsXG5cdFwidGdhXCIsXG5cdFwidGd6XCIsXG5cdFwidGhteFwiLFxuXHRcInRpZlwiLFxuXHRcInRpZmZcIixcblx0XCJ0bHpcIixcblx0XCJ0dGNcIixcblx0XCJ0dGZcIixcblx0XCJ0eHpcIixcblx0XCJ1ZGZcIixcblx0XCJ1dmhcIixcblx0XCJ1dmlcIixcblx0XCJ1dm1cIixcblx0XCJ1dnBcIixcblx0XCJ1dnNcIixcblx0XCJ1dnVcIixcblx0XCJ2aXZcIixcblx0XCJ2b2JcIixcblx0XCJ3YXJcIixcblx0XCJ3YXZcIixcblx0XCJ3YXhcIixcblx0XCJ3Ym1wXCIsXG5cdFwid2RwXCIsXG5cdFwid2ViYVwiLFxuXHRcIndlYm1cIixcblx0XCJ3ZWJwXCIsXG5cdFwid2hsXCIsXG5cdFwid2ltXCIsXG5cdFwid21cIixcblx0XCJ3bWFcIixcblx0XCJ3bXZcIixcblx0XCJ3bXhcIixcblx0XCJ3b2ZmXCIsXG5cdFwid29mZjJcIixcblx0XCJ3cm1cIixcblx0XCJ3dnhcIixcblx0XCJ4Ym1cIixcblx0XCJ4aWZcIixcblx0XCJ4bGFcIixcblx0XCJ4bGFtXCIsXG5cdFwieGxzXCIsXG5cdFwieGxzYlwiLFxuXHRcInhsc21cIixcblx0XCJ4bHN4XCIsXG5cdFwieGx0XCIsXG5cdFwieGx0bVwiLFxuXHRcInhsdHhcIixcblx0XCJ4bVwiLFxuXHRcInhtaW5kXCIsXG5cdFwieHBpXCIsXG5cdFwieHBtXCIsXG5cdFwieHdkXCIsXG5cdFwieHpcIixcblx0XCJ6XCIsXG5cdFwiemlwXCIsXG5cdFwiemlweFwiXG5dXG4iLCAibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2JpbmFyeS1leHRlbnNpb25zLmpzb24nKTtcbiIsICIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgYmluYXJ5RXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ2JpbmFyeS1leHRlbnNpb25zJyk7XG5cbmNvbnN0IGV4dGVuc2lvbnMgPSBuZXcgU2V0KGJpbmFyeUV4dGVuc2lvbnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGVQYXRoID0+IGV4dGVuc2lvbnMuaGFzKHBhdGguZXh0bmFtZShmaWxlUGF0aCkuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7c2VwfSA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHtwbGF0Zm9ybX0gPSBwcm9jZXNzO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuXG5leHBvcnRzLkVWX0FMTCA9ICdhbGwnO1xuZXhwb3J0cy5FVl9SRUFEWSA9ICdyZWFkeSc7XG5leHBvcnRzLkVWX0FERCA9ICdhZGQnO1xuZXhwb3J0cy5FVl9DSEFOR0UgPSAnY2hhbmdlJztcbmV4cG9ydHMuRVZfQUREX0RJUiA9ICdhZGREaXInO1xuZXhwb3J0cy5FVl9VTkxJTksgPSAndW5saW5rJztcbmV4cG9ydHMuRVZfVU5MSU5LX0RJUiA9ICd1bmxpbmtEaXInO1xuZXhwb3J0cy5FVl9SQVcgPSAncmF3JztcbmV4cG9ydHMuRVZfRVJST1IgPSAnZXJyb3InO1xuXG5leHBvcnRzLlNUUl9EQVRBID0gJ2RhdGEnO1xuZXhwb3J0cy5TVFJfRU5EID0gJ2VuZCc7XG5leHBvcnRzLlNUUl9DTE9TRSA9ICdjbG9zZSc7XG5cbmV4cG9ydHMuRlNFVkVOVF9DUkVBVEVEID0gJ2NyZWF0ZWQnO1xuZXhwb3J0cy5GU0VWRU5UX01PRElGSUVEID0gJ21vZGlmaWVkJztcbmV4cG9ydHMuRlNFVkVOVF9ERUxFVEVEID0gJ2RlbGV0ZWQnO1xuZXhwb3J0cy5GU0VWRU5UX01PVkVEID0gJ21vdmVkJztcbmV4cG9ydHMuRlNFVkVOVF9DTE9ORUQgPSAnY2xvbmVkJztcbmV4cG9ydHMuRlNFVkVOVF9VTktOT1dOID0gJ3Vua25vd24nO1xuZXhwb3J0cy5GU0VWRU5UX0ZMQUdfTVVTVF9TQ0FOX1NVQkRJUlMgPSAxO1xuZXhwb3J0cy5GU0VWRU5UX1RZUEVfRklMRSA9ICdmaWxlJztcbmV4cG9ydHMuRlNFVkVOVF9UWVBFX0RJUkVDVE9SWSA9ICdkaXJlY3RvcnknO1xuZXhwb3J0cy5GU0VWRU5UX1RZUEVfU1lNTElOSyA9ICdzeW1saW5rJztcblxuZXhwb3J0cy5LRVlfTElTVEVORVJTID0gJ2xpc3RlbmVycyc7XG5leHBvcnRzLktFWV9FUlIgPSAnZXJySGFuZGxlcnMnO1xuZXhwb3J0cy5LRVlfUkFXID0gJ3Jhd0VtaXR0ZXJzJztcbmV4cG9ydHMuSEFORExFUl9LRVlTID0gW2V4cG9ydHMuS0VZX0xJU1RFTkVSUywgZXhwb3J0cy5LRVlfRVJSLCBleHBvcnRzLktFWV9SQVddO1xuXG5leHBvcnRzLkRPVF9TTEFTSCA9IGAuJHtzZXB9YDtcblxuZXhwb3J0cy5CQUNLX1NMQVNIX1JFID0gL1xcXFwvZztcbmV4cG9ydHMuRE9VQkxFX1NMQVNIX1JFID0gL1xcL1xcLy87XG5leHBvcnRzLlNMQVNIX09SX0JBQ0tfU0xBU0hfUkUgPSAvWy9cXFxcXS87XG5leHBvcnRzLkRPVF9SRSA9IC9cXC4uKlxcLihzd1tweF0pJHx+JHxcXC5zdWJsLipcXC50bXAvO1xuZXhwb3J0cy5SRVBMQUNFUl9SRSA9IC9eXFwuWy9cXFxcXS87XG5cbmV4cG9ydHMuU0xBU0ggPSAnLyc7XG5leHBvcnRzLlNMQVNIX1NMQVNIID0gJy8vJztcbmV4cG9ydHMuQlJBQ0VfU1RBUlQgPSAneyc7XG5leHBvcnRzLkJBTkcgPSAnISc7XG5leHBvcnRzLk9ORV9ET1QgPSAnLic7XG5leHBvcnRzLlRXT19ET1RTID0gJy4uJztcbmV4cG9ydHMuU1RBUiA9ICcqJztcbmV4cG9ydHMuR0xPQlNUQVIgPSAnKionO1xuZXhwb3J0cy5ST09UX0dMT0JTVEFSID0gJy8qKi8qJztcbmV4cG9ydHMuU0xBU0hfR0xPQlNUQVIgPSAnLyoqJztcbmV4cG9ydHMuRElSX1NVRkZJWCA9ICdEaXInO1xuZXhwb3J0cy5BTllNQVRDSF9PUFRTID0ge2RvdDogdHJ1ZX07XG5leHBvcnRzLlNUUklOR19UWVBFID0gJ3N0cmluZyc7XG5leHBvcnRzLkZVTkNUSU9OX1RZUEUgPSAnZnVuY3Rpb24nO1xuZXhwb3J0cy5FTVBUWV9TVFIgPSAnJztcbmV4cG9ydHMuRU1QVFlfRk4gPSAoKSA9PiB7fTtcbmV4cG9ydHMuSURFTlRJVFlfRk4gPSB2YWwgPT4gdmFsO1xuXG5leHBvcnRzLmlzV2luZG93cyA9IHBsYXRmb3JtID09PSAnd2luMzInO1xuZXhwb3J0cy5pc01hY29zID0gcGxhdGZvcm0gPT09ICdkYXJ3aW4nO1xuZXhwb3J0cy5pc0xpbnV4ID0gcGxhdGZvcm0gPT09ICdsaW51eCc7XG5leHBvcnRzLmlzSUJNaSA9IG9zLnR5cGUoKSA9PT0gJ09TNDAwJztcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHN5c1BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgaXNCaW5hcnlQYXRoID0gcmVxdWlyZSgnaXMtYmluYXJ5LXBhdGgnKTtcbmNvbnN0IHtcbiAgaXNXaW5kb3dzLFxuICBpc0xpbnV4LFxuICBFTVBUWV9GTixcbiAgRU1QVFlfU1RSLFxuICBLRVlfTElTVEVORVJTLFxuICBLRVlfRVJSLFxuICBLRVlfUkFXLFxuICBIQU5ETEVSX0tFWVMsXG4gIEVWX0NIQU5HRSxcbiAgRVZfQURELFxuICBFVl9BRERfRElSLFxuICBFVl9FUlJPUixcbiAgU1RSX0RBVEEsXG4gIFNUUl9FTkQsXG4gIEJSQUNFX1NUQVJULFxuICBTVEFSXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgVEhST1RUTEVfTU9ERV9XQVRDSCA9ICd3YXRjaCc7XG5cbmNvbnN0IG9wZW4gPSBwcm9taXNpZnkoZnMub3Blbik7XG5jb25zdCBzdGF0ID0gcHJvbWlzaWZ5KGZzLnN0YXQpO1xuY29uc3QgbHN0YXQgPSBwcm9taXNpZnkoZnMubHN0YXQpO1xuY29uc3QgY2xvc2UgPSBwcm9taXNpZnkoZnMuY2xvc2UpO1xuY29uc3QgZnNyZWFscGF0aCA9IHByb21pc2lmeShmcy5yZWFscGF0aCk7XG5cbmNvbnN0IHN0YXRNZXRob2RzID0geyBsc3RhdCwgc3RhdCB9O1xuXG4vLyBUT0RPOiBlbWl0IGVycm9ycyBwcm9wZXJseS4gRXhhbXBsZTogRU1GSUxFIG9uIE1hY29zLlxuY29uc3QgZm9yZWFjaCA9ICh2YWwsIGZuKSA9PiB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICB2YWwuZm9yRWFjaChmbik7XG4gIH0gZWxzZSB7XG4gICAgZm4odmFsKTtcbiAgfVxufTtcblxuY29uc3QgYWRkQW5kQ29udmVydCA9IChtYWluLCBwcm9wLCBpdGVtKSA9PiB7XG4gIGxldCBjb250YWluZXIgPSBtYWluW3Byb3BdO1xuICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBTZXQpKSB7XG4gICAgbWFpbltwcm9wXSA9IGNvbnRhaW5lciA9IG5ldyBTZXQoW2NvbnRhaW5lcl0pO1xuICB9XG4gIGNvbnRhaW5lci5hZGQoaXRlbSk7XG59O1xuXG5jb25zdCBjbGVhckl0ZW0gPSBjb250ID0+IGtleSA9PiB7XG4gIGNvbnN0IHNldCA9IGNvbnRba2V5XTtcbiAgaWYgKHNldCBpbnN0YW5jZW9mIFNldCkge1xuICAgIHNldC5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBjb250W2tleV07XG4gIH1cbn07XG5cbmNvbnN0IGRlbEZyb21TZXQgPSAobWFpbiwgcHJvcCwgaXRlbSkgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBtYWluW3Byb3BdO1xuICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgY29udGFpbmVyLmRlbGV0ZShpdGVtKTtcbiAgfSBlbHNlIGlmIChjb250YWluZXIgPT09IGl0ZW0pIHtcbiAgICBkZWxldGUgbWFpbltwcm9wXTtcbiAgfVxufTtcblxuY29uc3QgaXNFbXB0eVNldCA9ICh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIFNldCA/IHZhbC5zaXplID09PSAwIDogIXZhbDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7U3RyaW5nfSBQYXRoXG4gKi9cblxuLy8gZnNfd2F0Y2ggaGVscGVyc1xuXG4vLyBvYmplY3QgdG8gaG9sZCBwZXItcHJvY2VzcyBmc193YXRjaCBpbnN0YW5jZXNcbi8vIChtYXkgYmUgc2hhcmVkIGFjcm9zcyBjaG9raWRhciBGU1dhdGNoZXIgaW5zdGFuY2VzKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZzV2F0Y2hDb250YWluZXJcbiAqIEBwcm9wZXJ0eSB7U2V0fSBsaXN0ZW5lcnNcbiAqIEBwcm9wZXJ0eSB7U2V0fSBlcnJIYW5kbGVyc1xuICogQHByb3BlcnR5IHtTZXR9IHJhd0VtaXR0ZXJzXG4gKiBAcHJvcGVydHkge2ZzLkZTV2F0Y2hlcj19IHdhdGNoZXJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbj19IHdhdGNoZXJVbnVzYWJsZVxuICovXG5cbi8qKlxuICogQHR5cGUge01hcDxTdHJpbmcsRnNXYXRjaENvbnRhaW5lcj59XG4gKi9cbmNvbnN0IEZzV2F0Y2hJbnN0YW5jZXMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogSW5zdGFudGlhdGVzIHRoZSBmc193YXRjaCBpbnRlcmZhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGJlIHdhdGNoZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBmc193YXRjaFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgbWFpbiBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJIYW5kbGVyIGVtaXRzIGluZm8gYWJvdXQgZXJyb3JzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbWl0UmF3IGVtaXRzIHJhdyBldmVudCBkYXRhXG4gKiBAcmV0dXJucyB7ZnMuRlNXYXRjaGVyfSBuZXcgZnNldmVudHMgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRnNXYXRjaEluc3RhbmNlKHBhdGgsIG9wdGlvbnMsIGxpc3RlbmVyLCBlcnJIYW5kbGVyLCBlbWl0UmF3KSB7XG4gIGNvbnN0IGhhbmRsZUV2ZW50ID0gKHJhd0V2ZW50LCBldlBhdGgpID0+IHtcbiAgICBsaXN0ZW5lcihwYXRoKTtcbiAgICBlbWl0UmF3KHJhd0V2ZW50LCBldlBhdGgsIHt3YXRjaGVkUGF0aDogcGF0aH0pO1xuXG4gICAgLy8gZW1pdCBiYXNlZCBvbiBldmVudHMgb2NjdXJyaW5nIGZvciBmaWxlcyBmcm9tIGEgZGlyZWN0b3J5J3Mgd2F0Y2hlciBpblxuICAgIC8vIGNhc2UgdGhlIGZpbGUncyB3YXRjaGVyIG1pc3NlcyBpdCAoYW5kIHJlbHkgb24gdGhyb3R0bGluZyB0byBkZS1kdXBlKVxuICAgIGlmIChldlBhdGggJiYgcGF0aCAhPT0gZXZQYXRoKSB7XG4gICAgICBmc1dhdGNoQnJvYWRjYXN0KFxuICAgICAgICBzeXNQYXRoLnJlc29sdmUocGF0aCwgZXZQYXRoKSwgS0VZX0xJU1RFTkVSUywgc3lzUGF0aC5qb2luKHBhdGgsIGV2UGF0aClcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICB0cnkge1xuICAgIHJldHVybiBmcy53YXRjaChwYXRoLCBvcHRpb25zLCBoYW5kbGVFdmVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZXJySGFuZGxlcihlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHBhc3NpbmcgZnNfd2F0Y2ggZXZlbnQgZGF0YSB0byBhIGNvbGxlY3Rpb24gb2YgbGlzdGVuZXJzXG4gKiBAcGFyYW0ge1BhdGh9IGZ1bGxQYXRoIGFic29sdXRlIHBhdGggYm91bmQgdG8gZnNfd2F0Y2ggaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGxpc3RlbmVyIHR5cGVcbiAqIEBwYXJhbSB7Kj19IHZhbDEgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBsaXN0ZW5lcnNcbiAqIEBwYXJhbSB7Kj19IHZhbDJcbiAqIEBwYXJhbSB7Kj19IHZhbDNcbiAqL1xuY29uc3QgZnNXYXRjaEJyb2FkY2FzdCA9IChmdWxsUGF0aCwgdHlwZSwgdmFsMSwgdmFsMiwgdmFsMykgPT4ge1xuICBjb25zdCBjb250ID0gRnNXYXRjaEluc3RhbmNlcy5nZXQoZnVsbFBhdGgpO1xuICBpZiAoIWNvbnQpIHJldHVybjtcbiAgZm9yZWFjaChjb250W3R5cGVdLCAobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcih2YWwxLCB2YWwyLCB2YWwzKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlcyB0aGUgZnNfd2F0Y2ggaW50ZXJmYWNlIG9yIGJpbmRzIGxpc3RlbmVyc1xuICogdG8gYW4gZXhpc3Rpbmcgb25lIGNvdmVyaW5nIHRoZSBzYW1lIGZpbGUgc3lzdGVtIGVudHJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IGZ1bGxQYXRoIGFic29sdXRlIHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBmc193YXRjaFxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJzIGNvbnRhaW5lciBmb3IgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zXG4gKi9cbmNvbnN0IHNldEZzV2F0Y2hMaXN0ZW5lciA9IChwYXRoLCBmdWxsUGF0aCwgb3B0aW9ucywgaGFuZGxlcnMpID0+IHtcbiAgY29uc3Qge2xpc3RlbmVyLCBlcnJIYW5kbGVyLCByYXdFbWl0dGVyfSA9IGhhbmRsZXJzO1xuICBsZXQgY29udCA9IEZzV2F0Y2hJbnN0YW5jZXMuZ2V0KGZ1bGxQYXRoKTtcblxuICAvKiogQHR5cGUge2ZzLkZTV2F0Y2hlcj19ICovXG4gIGxldCB3YXRjaGVyO1xuICBpZiAoIW9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgIHdhdGNoZXIgPSBjcmVhdGVGc1dhdGNoSW5zdGFuY2UoXG4gICAgICBwYXRoLCBvcHRpb25zLCBsaXN0ZW5lciwgZXJySGFuZGxlciwgcmF3RW1pdHRlclxuICAgICk7XG4gICAgcmV0dXJuIHdhdGNoZXIuY2xvc2UuYmluZCh3YXRjaGVyKTtcbiAgfVxuICBpZiAoY29udCkge1xuICAgIGFkZEFuZENvbnZlcnQoY29udCwgS0VZX0xJU1RFTkVSUywgbGlzdGVuZXIpO1xuICAgIGFkZEFuZENvbnZlcnQoY29udCwgS0VZX0VSUiwgZXJySGFuZGxlcik7XG4gICAgYWRkQW5kQ29udmVydChjb250LCBLRVlfUkFXLCByYXdFbWl0dGVyKTtcbiAgfSBlbHNlIHtcbiAgICB3YXRjaGVyID0gY3JlYXRlRnNXYXRjaEluc3RhbmNlKFxuICAgICAgcGF0aCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBmc1dhdGNoQnJvYWRjYXN0LmJpbmQobnVsbCwgZnVsbFBhdGgsIEtFWV9MSVNURU5FUlMpLFxuICAgICAgZXJySGFuZGxlciwgLy8gbm8gbmVlZCB0byB1c2UgYnJvYWRjYXN0IGhlcmVcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QuYmluZChudWxsLCBmdWxsUGF0aCwgS0VZX1JBVylcbiAgICApO1xuICAgIGlmICghd2F0Y2hlcikgcmV0dXJuO1xuICAgIHdhdGNoZXIub24oRVZfRVJST1IsIGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgY29uc3QgYnJvYWRjYXN0RXJyID0gZnNXYXRjaEJyb2FkY2FzdC5iaW5kKG51bGwsIGZ1bGxQYXRoLCBLRVlfRVJSKTtcbiAgICAgIGNvbnQud2F0Y2hlclVudXNhYmxlID0gdHJ1ZTsgLy8gZG9jdW1lbnRlZCBzaW5jZSBOb2RlIDEwLjQuMVxuICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy80MzM3XG4gICAgICBpZiAoaXNXaW5kb3dzICYmIGVycm9yLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBmZCA9IGF3YWl0IG9wZW4ocGF0aCwgJ3InKTtcbiAgICAgICAgICBhd2FpdCBjbG9zZShmZCk7XG4gICAgICAgICAgYnJvYWRjYXN0RXJyKGVycm9yKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJvYWRjYXN0RXJyKGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250ID0ge1xuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcixcbiAgICAgIGVyckhhbmRsZXJzOiBlcnJIYW5kbGVyLFxuICAgICAgcmF3RW1pdHRlcnM6IHJhd0VtaXR0ZXIsXG4gICAgICB3YXRjaGVyXG4gICAgfTtcbiAgICBGc1dhdGNoSW5zdGFuY2VzLnNldChmdWxsUGF0aCwgY29udCk7XG4gIH1cbiAgLy8gY29uc3QgaW5kZXggPSBjb250Lmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcblxuICAvLyByZW1vdmVzIHRoaXMgaW5zdGFuY2UncyBsaXN0ZW5lcnMgYW5kIGNsb3NlcyB0aGUgdW5kZXJseWluZyBmc193YXRjaFxuICAvLyBpbnN0YW5jZSBpZiB0aGVyZSBhcmUgbm8gbW9yZSBsaXN0ZW5lcnMgbGVmdFxuICByZXR1cm4gKCkgPT4ge1xuICAgIGRlbEZyb21TZXQoY29udCwgS0VZX0xJU1RFTkVSUywgbGlzdGVuZXIpO1xuICAgIGRlbEZyb21TZXQoY29udCwgS0VZX0VSUiwgZXJySGFuZGxlcik7XG4gICAgZGVsRnJvbVNldChjb250LCBLRVlfUkFXLCByYXdFbWl0dGVyKTtcbiAgICBpZiAoaXNFbXB0eVNldChjb250Lmxpc3RlbmVycykpIHtcbiAgICAgIC8vIENoZWNrIHRvIHByb3RlY3QgYWdhaW5zdCBpc3N1ZSBnaC03MzAuXG4gICAgICAvLyBpZiAoY29udC53YXRjaGVyVW51c2FibGUpIHtcbiAgICAgIGNvbnQud2F0Y2hlci5jbG9zZSgpO1xuICAgICAgLy8gfVxuICAgICAgRnNXYXRjaEluc3RhbmNlcy5kZWxldGUoZnVsbFBhdGgpO1xuICAgICAgSEFORExFUl9LRVlTLmZvckVhY2goY2xlYXJJdGVtKGNvbnQpKTtcbiAgICAgIGNvbnQud2F0Y2hlciA9IHVuZGVmaW5lZDtcbiAgICAgIE9iamVjdC5mcmVlemUoY29udCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gZnNfd2F0Y2hGaWxlIGhlbHBlcnNcblxuLy8gb2JqZWN0IHRvIGhvbGQgcGVyLXByb2Nlc3MgZnNfd2F0Y2hGaWxlIGluc3RhbmNlc1xuLy8gKG1heSBiZSBzaGFyZWQgYWNyb3NzIGNob2tpZGFyIEZTV2F0Y2hlciBpbnN0YW5jZXMpXG5jb25zdCBGc1dhdGNoRmlsZUluc3RhbmNlcyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgdGhlIGZzX3dhdGNoRmlsZSBpbnRlcmZhY2Ugb3IgYmluZHMgbGlzdGVuZXJzXG4gKiB0byBhbiBleGlzdGluZyBvbmUgY292ZXJpbmcgdGhlIHNhbWUgZmlsZSBzeXN0ZW0gZW50cnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGJlIHdhdGNoZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmdWxsUGF0aCBhYnNvbHV0ZSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBmc193YXRjaEZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVycyBjb250YWluZXIgZm9yIGV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9uc1xuICogQHJldHVybnMge0Z1bmN0aW9ufSBjbG9zZXJcbiAqL1xuY29uc3Qgc2V0RnNXYXRjaEZpbGVMaXN0ZW5lciA9IChwYXRoLCBmdWxsUGF0aCwgb3B0aW9ucywgaGFuZGxlcnMpID0+IHtcbiAgY29uc3Qge2xpc3RlbmVyLCByYXdFbWl0dGVyfSA9IGhhbmRsZXJzO1xuICBsZXQgY29udCA9IEZzV2F0Y2hGaWxlSW5zdGFuY2VzLmdldChmdWxsUGF0aCk7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIHByZWZlci1kZXN0cnVjdHVyaW5nICovXG4gIGxldCBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gIGxldCByYXdFbWl0dGVycyA9IG5ldyBTZXQoKTtcblxuICBjb25zdCBjb3B0cyA9IGNvbnQgJiYgY29udC5vcHRpb25zO1xuICBpZiAoY29wdHMgJiYgKGNvcHRzLnBlcnNpc3RlbnQgPCBvcHRpb25zLnBlcnNpc3RlbnQgfHwgY29wdHMuaW50ZXJ2YWwgPiBvcHRpb25zLmludGVydmFsKSkge1xuICAgIC8vIFwiVXBncmFkZVwiIHRoZSB3YXRjaGVyIHRvIHBlcnNpc3RlbmNlIG9yIGEgcXVpY2tlciBpbnRlcnZhbC5cbiAgICAvLyBUaGlzIGNyZWF0ZXMgc29tZSB1bmxpa2VseSBlZGdlIGNhc2UgaXNzdWVzIGlmIHRoZSB1c2VyIG1peGVzXG4gICAgLy8gc2V0dGluZ3MgaW4gYSB2ZXJ5IHdlaXJkIHdheSwgYnV0IHNvbHZpbmcgZm9yIHRob3NlIGNhc2VzXG4gICAgLy8gZG9lc24ndCBzZWVtIHdvcnRod2hpbGUgZm9yIHRoZSBhZGRlZCBjb21wbGV4aXR5LlxuICAgIGxpc3RlbmVycyA9IGNvbnQubGlzdGVuZXJzO1xuICAgIHJhd0VtaXR0ZXJzID0gY29udC5yYXdFbWl0dGVycztcbiAgICBmcy51bndhdGNoRmlsZShmdWxsUGF0aCk7XG4gICAgY29udCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIHByZWZlci1kZXN0cnVjdHVyaW5nICovXG5cbiAgaWYgKGNvbnQpIHtcbiAgICBhZGRBbmRDb252ZXJ0KGNvbnQsIEtFWV9MSVNURU5FUlMsIGxpc3RlbmVyKTtcbiAgICBhZGRBbmRDb252ZXJ0KGNvbnQsIEtFWV9SQVcsIHJhd0VtaXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE9cbiAgICAvLyBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAvLyByYXdFbWl0dGVycy5hZGQocmF3RW1pdHRlcik7XG4gICAgY29udCA9IHtcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXIsXG4gICAgICByYXdFbWl0dGVyczogcmF3RW1pdHRlcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICB3YXRjaGVyOiBmcy53YXRjaEZpbGUoZnVsbFBhdGgsIG9wdGlvbnMsIChjdXJyLCBwcmV2KSA9PiB7XG4gICAgICAgIGZvcmVhY2goY29udC5yYXdFbWl0dGVycywgKHJhd0VtaXR0ZXIpID0+IHtcbiAgICAgICAgICByYXdFbWl0dGVyKEVWX0NIQU5HRSwgZnVsbFBhdGgsIHtjdXJyLCBwcmV2fSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjdXJybXRpbWUgPSBjdXJyLm10aW1lTXM7XG4gICAgICAgIGlmIChjdXJyLnNpemUgIT09IHByZXYuc2l6ZSB8fCBjdXJybXRpbWUgPiBwcmV2Lm10aW1lTXMgfHwgY3Vycm10aW1lID09PSAwKSB7XG4gICAgICAgICAgZm9yZWFjaChjb250Lmxpc3RlbmVycywgKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihwYXRoLCBjdXJyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgICBGc1dhdGNoRmlsZUluc3RhbmNlcy5zZXQoZnVsbFBhdGgsIGNvbnQpO1xuICB9XG4gIC8vIGNvbnN0IGluZGV4ID0gY29udC5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG5cbiAgLy8gUmVtb3ZlcyB0aGlzIGluc3RhbmNlJ3MgbGlzdGVuZXJzIGFuZCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgZnNfd2F0Y2hGaWxlXG4gIC8vIGluc3RhbmNlIGlmIHRoZXJlIGFyZSBubyBtb3JlIGxpc3RlbmVycyBsZWZ0LlxuICByZXR1cm4gKCkgPT4ge1xuICAgIGRlbEZyb21TZXQoY29udCwgS0VZX0xJU1RFTkVSUywgbGlzdGVuZXIpO1xuICAgIGRlbEZyb21TZXQoY29udCwgS0VZX1JBVywgcmF3RW1pdHRlcik7XG4gICAgaWYgKGlzRW1wdHlTZXQoY29udC5saXN0ZW5lcnMpKSB7XG4gICAgICBGc1dhdGNoRmlsZUluc3RhbmNlcy5kZWxldGUoZnVsbFBhdGgpO1xuICAgICAgZnMudW53YXRjaEZpbGUoZnVsbFBhdGgpO1xuICAgICAgY29udC5vcHRpb25zID0gY29udC53YXRjaGVyID0gdW5kZWZpbmVkO1xuICAgICAgT2JqZWN0LmZyZWV6ZShjb250KTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEBtaXhpblxuICovXG5jbGFzcyBOb2RlRnNIYW5kbGVyIHtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2luZGV4XCIpLkZTV2F0Y2hlcn0gZnNXXG4gKi9cbmNvbnN0cnVjdG9yKGZzVykge1xuICB0aGlzLmZzdyA9IGZzVztcbiAgdGhpcy5fYm91bmRIYW5kbGVFcnJvciA9IChlcnJvcikgPT4gZnNXLl9oYW5kbGVFcnJvcihlcnJvcik7XG59XG5cbi8qKlxuICogV2F0Y2ggZmlsZSBmb3IgY2hhbmdlcyB3aXRoIGZzX3dhdGNoRmlsZSBvciBmc193YXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGZpbGUgb3IgZGlyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBvbiBmcyBjaGFuZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gY2xvc2VyIGZvciB0aGUgd2F0Y2hlciBpbnN0YW5jZVxuICovXG5fd2F0Y2hXaXRoTm9kZUZzKHBhdGgsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IG9wdHMgPSB0aGlzLmZzdy5vcHRpb25zO1xuICBjb25zdCBkaXJlY3RvcnkgPSBzeXNQYXRoLmRpcm5hbWUocGF0aCk7XG4gIGNvbnN0IGJhc2VuYW1lID0gc3lzUGF0aC5iYXNlbmFtZShwYXRoKTtcbiAgY29uc3QgcGFyZW50ID0gdGhpcy5mc3cuX2dldFdhdGNoZWREaXIoZGlyZWN0b3J5KTtcbiAgcGFyZW50LmFkZChiYXNlbmFtZSk7XG4gIGNvbnN0IGFic29sdXRlUGF0aCA9IHN5c1BhdGgucmVzb2x2ZShwYXRoKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtwZXJzaXN0ZW50OiBvcHRzLnBlcnNpc3RlbnR9O1xuICBpZiAoIWxpc3RlbmVyKSBsaXN0ZW5lciA9IEVNUFRZX0ZOO1xuXG4gIGxldCBjbG9zZXI7XG4gIGlmIChvcHRzLnVzZVBvbGxpbmcpIHtcbiAgICBvcHRpb25zLmludGVydmFsID0gb3B0cy5lbmFibGVCaW5hcnlJbnRlcnZhbCAmJiBpc0JpbmFyeVBhdGgoYmFzZW5hbWUpID9cbiAgICAgIG9wdHMuYmluYXJ5SW50ZXJ2YWwgOiBvcHRzLmludGVydmFsO1xuICAgIGNsb3NlciA9IHNldEZzV2F0Y2hGaWxlTGlzdGVuZXIocGF0aCwgYWJzb2x1dGVQYXRoLCBvcHRpb25zLCB7XG4gICAgICBsaXN0ZW5lcixcbiAgICAgIHJhd0VtaXR0ZXI6IHRoaXMuZnN3Ll9lbWl0UmF3XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2xvc2VyID0gc2V0RnNXYXRjaExpc3RlbmVyKHBhdGgsIGFic29sdXRlUGF0aCwgb3B0aW9ucywge1xuICAgICAgbGlzdGVuZXIsXG4gICAgICBlcnJIYW5kbGVyOiB0aGlzLl9ib3VuZEhhbmRsZUVycm9yLFxuICAgICAgcmF3RW1pdHRlcjogdGhpcy5mc3cuX2VtaXRSYXdcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2xvc2VyO1xufVxuXG4vKipcbiAqIFdhdGNoIGEgZmlsZSBhbmQgZW1pdCBhZGQgZXZlbnQgaWYgd2FycmFudGVkLlxuICogQHBhcmFtIHtQYXRofSBmaWxlIFBhdGhcbiAqIEBwYXJhbSB7ZnMuU3RhdHN9IHN0YXRzIHJlc3VsdCBvZiBmc19zdGF0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRpYWxBZGQgd2FzIHRoZSBmaWxlIGFkZGVkIGF0IHdhdGNoIGluc3RhbnRpYXRpb24/XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGNsb3NlciBmb3IgdGhlIHdhdGNoZXIgaW5zdGFuY2VcbiAqL1xuX2hhbmRsZUZpbGUoZmlsZSwgc3RhdHMsIGluaXRpYWxBZGQpIHtcbiAgaWYgKHRoaXMuZnN3LmNsb3NlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkaXJuYW1lID0gc3lzUGF0aC5kaXJuYW1lKGZpbGUpO1xuICBjb25zdCBiYXNlbmFtZSA9IHN5c1BhdGguYmFzZW5hbWUoZmlsZSk7XG4gIGNvbnN0IHBhcmVudCA9IHRoaXMuZnN3Ll9nZXRXYXRjaGVkRGlyKGRpcm5hbWUpO1xuICAvLyBzdGF0cyBpcyBhbHdheXMgcHJlc2VudFxuICBsZXQgcHJldlN0YXRzID0gc3RhdHM7XG5cbiAgLy8gaWYgdGhlIGZpbGUgaXMgYWxyZWFkeSBiZWluZyB3YXRjaGVkLCBkbyBub3RoaW5nXG4gIGlmIChwYXJlbnQuaGFzKGJhc2VuYW1lKSkgcmV0dXJuO1xuXG4gIGNvbnN0IGxpc3RlbmVyID0gYXN5bmMgKHBhdGgsIG5ld1N0YXRzKSA9PiB7XG4gICAgaWYgKCF0aGlzLmZzdy5fdGhyb3R0bGUoVEhST1RUTEVfTU9ERV9XQVRDSCwgZmlsZSwgNSkpIHJldHVybjtcbiAgICBpZiAoIW5ld1N0YXRzIHx8IG5ld1N0YXRzLm10aW1lTXMgPT09IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRzID0gYXdhaXQgc3RhdChmaWxlKTtcbiAgICAgICAgaWYgKHRoaXMuZnN3LmNsb3NlZCkgcmV0dXJuO1xuICAgICAgICAvLyBDaGVjayB0aGF0IGNoYW5nZSBldmVudCB3YXMgbm90IGZpcmVkIGJlY2F1c2Ugb2YgY2hhbmdlZCBvbmx5IGFjY2Vzc1RpbWUuXG4gICAgICAgIGNvbnN0IGF0ID0gbmV3U3RhdHMuYXRpbWVNcztcbiAgICAgICAgY29uc3QgbXQgPSBuZXdTdGF0cy5tdGltZU1zO1xuICAgICAgICBpZiAoIWF0IHx8IGF0IDw9IG10IHx8IG10ICE9PSBwcmV2U3RhdHMubXRpbWVNcykge1xuICAgICAgICAgIHRoaXMuZnN3Ll9lbWl0KEVWX0NIQU5HRSwgZmlsZSwgbmV3U3RhdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpbnV4ICYmIHByZXZTdGF0cy5pbm8gIT09IG5ld1N0YXRzLmlubykge1xuICAgICAgICAgIHRoaXMuZnN3Ll9jbG9zZUZpbGUocGF0aClcbiAgICAgICAgICBwcmV2U3RhdHMgPSBuZXdTdGF0cztcbiAgICAgICAgICB0aGlzLmZzdy5fYWRkUGF0aENsb3NlcihwYXRoLCB0aGlzLl93YXRjaFdpdGhOb2RlRnMoZmlsZSwgbGlzdGVuZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2U3RhdHMgPSBuZXdTdGF0cztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gRml4IGlzc3VlcyB3aGVyZSBtdGltZSBpcyBudWxsIGJ1dCBmaWxlIGlzIHN0aWxsIHByZXNlbnRcbiAgICAgICAgdGhpcy5mc3cuX3JlbW92ZShkaXJuYW1lLCBiYXNlbmFtZSk7XG4gICAgICB9XG4gICAgICAvLyBhZGQgaXMgYWJvdXQgdG8gYmUgZW1pdHRlZCBpZiBmaWxlIG5vdCBhbHJlYWR5IHRyYWNrZWQgaW4gcGFyZW50XG4gICAgfSBlbHNlIGlmIChwYXJlbnQuaGFzKGJhc2VuYW1lKSkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCBjaGFuZ2UgZXZlbnQgd2FzIG5vdCBmaXJlZCBiZWNhdXNlIG9mIGNoYW5nZWQgb25seSBhY2Nlc3NUaW1lLlxuICAgICAgY29uc3QgYXQgPSBuZXdTdGF0cy5hdGltZU1zO1xuICAgICAgY29uc3QgbXQgPSBuZXdTdGF0cy5tdGltZU1zO1xuICAgICAgaWYgKCFhdCB8fCBhdCA8PSBtdCB8fCBtdCAhPT0gcHJldlN0YXRzLm10aW1lTXMpIHtcbiAgICAgICAgdGhpcy5mc3cuX2VtaXQoRVZfQ0hBTkdFLCBmaWxlLCBuZXdTdGF0cyk7XG4gICAgICB9XG4gICAgICBwcmV2U3RhdHMgPSBuZXdTdGF0cztcbiAgICB9XG4gIH1cbiAgLy8ga2ljayBvZmYgdGhlIHdhdGNoZXJcbiAgY29uc3QgY2xvc2VyID0gdGhpcy5fd2F0Y2hXaXRoTm9kZUZzKGZpbGUsIGxpc3RlbmVyKTtcblxuICAvLyBlbWl0IGFuIGFkZCBldmVudCBpZiB3ZSdyZSBzdXBwb3NlZCB0b1xuICBpZiAoIShpbml0aWFsQWRkICYmIHRoaXMuZnN3Lm9wdGlvbnMuaWdub3JlSW5pdGlhbCkgJiYgdGhpcy5mc3cuX2lzbnRJZ25vcmVkKGZpbGUpKSB7XG4gICAgaWYgKCF0aGlzLmZzdy5fdGhyb3R0bGUoRVZfQURELCBmaWxlLCAwKSkgcmV0dXJuO1xuICAgIHRoaXMuZnN3Ll9lbWl0KEVWX0FERCwgZmlsZSwgc3RhdHMpO1xuICB9XG5cbiAgcmV0dXJuIGNsb3Nlcjtcbn1cblxuLyoqXG4gKiBIYW5kbGUgc3ltbGlua3MgZW5jb3VudGVyZWQgd2hpbGUgcmVhZGluZyBhIGRpci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSByZXR1cm5lZCBieSByZWFkZGlycFxuICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdG9yeSBwYXRoIG9mIGRpciBiZWluZyByZWFkXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBvZiB0aGlzIGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtIGJhc2VuYW1lIG9mIHRoaXMgaXRlbVxuICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59IHRydWUgaWYgbm8gbW9yZSBwcm9jZXNzaW5nIGlzIG5lZWRlZCBmb3IgdGhpcyBlbnRyeS5cbiAqL1xuYXN5bmMgX2hhbmRsZVN5bWxpbmsoZW50cnksIGRpcmVjdG9yeSwgcGF0aCwgaXRlbSkge1xuICBpZiAodGhpcy5mc3cuY2xvc2VkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZ1bGwgPSBlbnRyeS5mdWxsUGF0aDtcbiAgY29uc3QgZGlyID0gdGhpcy5mc3cuX2dldFdhdGNoZWREaXIoZGlyZWN0b3J5KTtcblxuICBpZiAoIXRoaXMuZnN3Lm9wdGlvbnMuZm9sbG93U3ltbGlua3MpIHtcbiAgICAvLyB3YXRjaCBzeW1saW5rIGRpcmVjdGx5IChkb24ndCBmb2xsb3cpIGFuZCBkZXRlY3QgY2hhbmdlc1xuICAgIHRoaXMuZnN3Ll9pbmNyUmVhZHlDb3VudCgpO1xuXG4gICAgbGV0IGxpbmtQYXRoO1xuICAgIHRyeSB7XG4gICAgICBsaW5rUGF0aCA9IGF3YWl0IGZzcmVhbHBhdGgocGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5mc3cuX2VtaXRSZWFkeSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnN3LmNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkaXIuaGFzKGl0ZW0pKSB7XG4gICAgICBpZiAodGhpcy5mc3cuX3N5bWxpbmtQYXRocy5nZXQoZnVsbCkgIT09IGxpbmtQYXRoKSB7XG4gICAgICAgIHRoaXMuZnN3Ll9zeW1saW5rUGF0aHMuc2V0KGZ1bGwsIGxpbmtQYXRoKTtcbiAgICAgICAgdGhpcy5mc3cuX2VtaXQoRVZfQ0hBTkdFLCBwYXRoLCBlbnRyeS5zdGF0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpci5hZGQoaXRlbSk7XG4gICAgICB0aGlzLmZzdy5fc3ltbGlua1BhdGhzLnNldChmdWxsLCBsaW5rUGF0aCk7XG4gICAgICB0aGlzLmZzdy5fZW1pdChFVl9BREQsIHBhdGgsIGVudHJ5LnN0YXRzKTtcbiAgICB9XG4gICAgdGhpcy5mc3cuX2VtaXRSZWFkeSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZG9uJ3QgZm9sbG93IHRoZSBzYW1lIHN5bWxpbmsgbW9yZSB0aGFuIG9uY2VcbiAgaWYgKHRoaXMuZnN3Ll9zeW1saW5rUGF0aHMuaGFzKGZ1bGwpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0aGlzLmZzdy5fc3ltbGlua1BhdGhzLnNldChmdWxsLCB0cnVlKTtcbn1cblxuX2hhbmRsZVJlYWQoZGlyZWN0b3J5LCBpbml0aWFsQWRkLCB3aCwgdGFyZ2V0LCBkaXIsIGRlcHRoLCB0aHJvdHRsZXIpIHtcbiAgLy8gTm9ybWFsaXplIHRoZSBkaXJlY3RvcnkgbmFtZSBvbiBXaW5kb3dzXG4gIGRpcmVjdG9yeSA9IHN5c1BhdGguam9pbihkaXJlY3RvcnksIEVNUFRZX1NUUik7XG5cbiAgaWYgKCF3aC5oYXNHbG9iKSB7XG4gICAgdGhyb3R0bGVyID0gdGhpcy5mc3cuX3Rocm90dGxlKCdyZWFkZGlyJywgZGlyZWN0b3J5LCAxMDAwKTtcbiAgICBpZiAoIXRocm90dGxlcikgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcHJldmlvdXMgPSB0aGlzLmZzdy5fZ2V0V2F0Y2hlZERpcih3aC5wYXRoKTtcbiAgY29uc3QgY3VycmVudCA9IG5ldyBTZXQoKTtcblxuICBsZXQgc3RyZWFtID0gdGhpcy5mc3cuX3JlYWRkaXJwKGRpcmVjdG9yeSwge1xuICAgIGZpbGVGaWx0ZXI6IGVudHJ5ID0+IHdoLmZpbHRlclBhdGgoZW50cnkpLFxuICAgIGRpcmVjdG9yeUZpbHRlcjogZW50cnkgPT4gd2guZmlsdGVyRGlyKGVudHJ5KSxcbiAgICBkZXB0aDogMFxuICB9KS5vbihTVFJfREFUQSwgYXN5bmMgKGVudHJ5KSA9PiB7XG4gICAgaWYgKHRoaXMuZnN3LmNsb3NlZCkge1xuICAgICAgc3RyZWFtID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gZW50cnkucGF0aDtcbiAgICBsZXQgcGF0aCA9IHN5c1BhdGguam9pbihkaXJlY3RvcnksIGl0ZW0pO1xuICAgIGN1cnJlbnQuYWRkKGl0ZW0pO1xuXG4gICAgaWYgKGVudHJ5LnN0YXRzLmlzU3ltYm9saWNMaW5rKCkgJiYgYXdhaXQgdGhpcy5faGFuZGxlU3ltbGluayhlbnRyeSwgZGlyZWN0b3J5LCBwYXRoLCBpdGVtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZzdy5jbG9zZWQpIHtcbiAgICAgIHN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmlsZXMgdGhhdCBwcmVzZW50IGluIGN1cnJlbnQgZGlyZWN0b3J5IHNuYXBzaG90XG4gICAgLy8gYnV0IGFic2VudCBpbiBwcmV2aW91cyBhcmUgYWRkZWQgdG8gd2F0Y2ggbGlzdCBhbmRcbiAgICAvLyBlbWl0IGBhZGRgIGV2ZW50LlxuICAgIGlmIChpdGVtID09PSB0YXJnZXQgfHwgIXRhcmdldCAmJiAhcHJldmlvdXMuaGFzKGl0ZW0pKSB7XG4gICAgICB0aGlzLmZzdy5faW5jclJlYWR5Q291bnQoKTtcblxuICAgICAgLy8gZW5zdXJlIHJlbGF0aXZlbmVzcyBvZiBwYXRoIGlzIHByZXNlcnZlZCBpbiBjYXNlIG9mIHdhdGNoZXIgcmV1c2VcbiAgICAgIHBhdGggPSBzeXNQYXRoLmpvaW4oZGlyLCBzeXNQYXRoLnJlbGF0aXZlKGRpciwgcGF0aCkpO1xuXG4gICAgICB0aGlzLl9hZGRUb05vZGVGcyhwYXRoLCBpbml0aWFsQWRkLCB3aCwgZGVwdGggKyAxKTtcbiAgICB9XG4gIH0pLm9uKEVWX0VSUk9SLCB0aGlzLl9ib3VuZEhhbmRsZUVycm9yKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PlxuICAgIHN0cmVhbS5vbmNlKFNUUl9FTkQsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmZzdy5jbG9zZWQpIHtcbiAgICAgICAgc3RyZWFtID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB3YXNUaHJvdHRsZWQgPSB0aHJvdHRsZXIgPyB0aHJvdHRsZXIuY2xlYXIoKSA6IGZhbHNlO1xuXG4gICAgICByZXNvbHZlKCk7XG5cbiAgICAgIC8vIEZpbGVzIHRoYXQgYWJzZW50IGluIGN1cnJlbnQgZGlyZWN0b3J5IHNuYXBzaG90XG4gICAgICAvLyBidXQgcHJlc2VudCBpbiBwcmV2aW91cyBlbWl0IGByZW1vdmVgIGV2ZW50XG4gICAgICAvLyBhbmQgYXJlIHJlbW92ZWQgZnJvbSBAd2F0Y2hlZFtkaXJlY3RvcnldLlxuICAgICAgcHJldmlvdXMuZ2V0Q2hpbGRyZW4oKS5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGRpcmVjdG9yeSAmJlxuICAgICAgICAgICFjdXJyZW50LmhhcyhpdGVtKSAmJlxuICAgICAgICAgIC8vIGluIGNhc2Ugb2YgaW50ZXJzZWN0aW5nIGdsb2JzO1xuICAgICAgICAgIC8vIGEgcGF0aCBtYXkgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dCBvZiB0aGlzIHJlYWRkaXIsIGJ1dFxuICAgICAgICAgIC8vIHNob3VsZG4ndCBiZSByZW1vdmVkIGJlY2F1c2UgaXQgbWF0Y2hlcyBhIGRpZmZlcmVudCBnbG9iXG4gICAgICAgICAgKCF3aC5oYXNHbG9iIHx8IHdoLmZpbHRlclBhdGgoe1xuICAgICAgICAgICAgZnVsbFBhdGg6IHN5c1BhdGgucmVzb2x2ZShkaXJlY3RvcnksIGl0ZW0pXG4gICAgICAgICAgfSkpO1xuICAgICAgfSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICB0aGlzLmZzdy5fcmVtb3ZlKGRpcmVjdG9yeSwgaXRlbSk7XG4gICAgICB9KTtcblxuICAgICAgc3RyZWFtID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBvbmUgbW9yZSB0aW1lIGZvciBhbnkgbWlzc2VkIGluIGNhc2UgY2hhbmdlcyBjYW1lIGluIGV4dHJlbWVseSBxdWlja2x5XG4gICAgICBpZiAod2FzVGhyb3R0bGVkKSB0aGlzLl9oYW5kbGVSZWFkKGRpcmVjdG9yeSwgZmFsc2UsIHdoLCB0YXJnZXQsIGRpciwgZGVwdGgsIHRocm90dGxlcik7XG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBSZWFkIGRpcmVjdG9yeSB0byBhZGQgLyByZW1vdmUgZmlsZXMgZnJvbSBgQHdhdGNoZWRgIGxpc3QgYW5kIHJlLXJlYWQgaXQgb24gY2hhbmdlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRpciBmcyBwYXRoXG4gKiBAcGFyYW0ge2ZzLlN0YXRzfSBzdGF0c1xuICogQHBhcmFtIHtCb29sZWFufSBpbml0aWFsQWRkXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggcmVsYXRpdmUgdG8gdXNlci1zdXBwbGllZCBwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IGNoaWxkIHBhdGggdGFyZ2V0ZWQgZm9yIHdhdGNoXG4gKiBAcGFyYW0ge09iamVjdH0gd2ggQ29tbW9uIHdhdGNoIGhlbHBlcnMgZm9yIHRoaXMgcGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IHJlYWxwYXRoXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGdW5jdGlvbj59IGNsb3NlciBmb3IgdGhlIHdhdGNoZXIgaW5zdGFuY2UuXG4gKi9cbmFzeW5jIF9oYW5kbGVEaXIoZGlyLCBzdGF0cywgaW5pdGlhbEFkZCwgZGVwdGgsIHRhcmdldCwgd2gsIHJlYWxwYXRoKSB7XG4gIGNvbnN0IHBhcmVudERpciA9IHRoaXMuZnN3Ll9nZXRXYXRjaGVkRGlyKHN5c1BhdGguZGlybmFtZShkaXIpKTtcbiAgY29uc3QgdHJhY2tlZCA9IHBhcmVudERpci5oYXMoc3lzUGF0aC5iYXNlbmFtZShkaXIpKTtcbiAgaWYgKCEoaW5pdGlhbEFkZCAmJiB0aGlzLmZzdy5vcHRpb25zLmlnbm9yZUluaXRpYWwpICYmICF0YXJnZXQgJiYgIXRyYWNrZWQpIHtcbiAgICBpZiAoIXdoLmhhc0dsb2IgfHwgd2guZ2xvYkZpbHRlcihkaXIpKSB0aGlzLmZzdy5fZW1pdChFVl9BRERfRElSLCBkaXIsIHN0YXRzKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBkaXIgaXMgdHJhY2tlZCAoaGFybWxlc3MgaWYgcmVkdW5kYW50KVxuICBwYXJlbnREaXIuYWRkKHN5c1BhdGguYmFzZW5hbWUoZGlyKSk7XG4gIHRoaXMuZnN3Ll9nZXRXYXRjaGVkRGlyKGRpcik7XG4gIGxldCB0aHJvdHRsZXI7XG4gIGxldCBjbG9zZXI7XG5cbiAgY29uc3Qgb0RlcHRoID0gdGhpcy5mc3cub3B0aW9ucy5kZXB0aDtcbiAgaWYgKChvRGVwdGggPT0gbnVsbCB8fCBkZXB0aCA8PSBvRGVwdGgpICYmICF0aGlzLmZzdy5fc3ltbGlua1BhdGhzLmhhcyhyZWFscGF0aCkpIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgYXdhaXQgdGhpcy5faGFuZGxlUmVhZChkaXIsIGluaXRpYWxBZGQsIHdoLCB0YXJnZXQsIGRpciwgZGVwdGgsIHRocm90dGxlcik7XG4gICAgICBpZiAodGhpcy5mc3cuY2xvc2VkKSByZXR1cm47XG4gICAgfVxuXG4gICAgY2xvc2VyID0gdGhpcy5fd2F0Y2hXaXRoTm9kZUZzKGRpciwgKGRpclBhdGgsIHN0YXRzKSA9PiB7XG4gICAgICAvLyBpZiBjdXJyZW50IGRpcmVjdG9yeSBpcyByZW1vdmVkLCBkbyBub3RoaW5nXG4gICAgICBpZiAoc3RhdHMgJiYgc3RhdHMubXRpbWVNcyA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9oYW5kbGVSZWFkKGRpclBhdGgsIGZhbHNlLCB3aCwgdGFyZ2V0LCBkaXIsIGRlcHRoLCB0aHJvdHRsZXIpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjbG9zZXI7XG59XG5cbi8qKlxuICogSGFuZGxlIGFkZGVkIGZpbGUsIGRpcmVjdG9yeSwgb3IgZ2xvYiBwYXR0ZXJuLlxuICogRGVsZWdhdGVzIGNhbGwgdG8gX2hhbmRsZUZpbGUgLyBfaGFuZGxlRGlyIGFmdGVyIGNoZWNrcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGZpbGUgb3IgaXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdGlhbEFkZCB3YXMgdGhlIGZpbGUgYWRkZWQgYXQgd2F0Y2ggaW5zdGFudGlhdGlvbj9cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcmlvcldoIGRlcHRoIHJlbGF0aXZlIHRvIHVzZXItc3VwcGxpZWQgcGF0aFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIENoaWxkIHBhdGggYWN0dWFsbHkgdGFyZ2V0ZWQgZm9yIHdhdGNoXG4gKiBAcGFyYW0ge1N0cmluZz19IHRhcmdldCBDaGlsZCBwYXRoIGFjdHVhbGx5IHRhcmdldGVkIGZvciB3YXRjaFxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmFzeW5jIF9hZGRUb05vZGVGcyhwYXRoLCBpbml0aWFsQWRkLCBwcmlvcldoLCBkZXB0aCwgdGFyZ2V0KSB7XG4gIGNvbnN0IHJlYWR5ID0gdGhpcy5mc3cuX2VtaXRSZWFkeTtcbiAgaWYgKHRoaXMuZnN3Ll9pc0lnbm9yZWQocGF0aCkgfHwgdGhpcy5mc3cuY2xvc2VkKSB7XG4gICAgcmVhZHkoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCB3aCA9IHRoaXMuZnN3Ll9nZXRXYXRjaEhlbHBlcnMocGF0aCwgZGVwdGgpO1xuICBpZiAoIXdoLmhhc0dsb2IgJiYgcHJpb3JXaCkge1xuICAgIHdoLmhhc0dsb2IgPSBwcmlvcldoLmhhc0dsb2I7XG4gICAgd2guZ2xvYkZpbHRlciA9IHByaW9yV2guZ2xvYkZpbHRlcjtcbiAgICB3aC5maWx0ZXJQYXRoID0gZW50cnkgPT4gcHJpb3JXaC5maWx0ZXJQYXRoKGVudHJ5KTtcbiAgICB3aC5maWx0ZXJEaXIgPSBlbnRyeSA9PiBwcmlvcldoLmZpbHRlckRpcihlbnRyeSk7XG4gIH1cblxuICAvLyBldmFsdWF0ZSB3aGF0IGlzIGF0IHRoZSBwYXRoIHdlJ3JlIGJlaW5nIGFza2VkIHRvIHdhdGNoXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBzdGF0TWV0aG9kc1t3aC5zdGF0TWV0aG9kXSh3aC53YXRjaFBhdGgpO1xuICAgIGlmICh0aGlzLmZzdy5jbG9zZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5mc3cuX2lzSWdub3JlZCh3aC53YXRjaFBhdGgsIHN0YXRzKSkge1xuICAgICAgcmVhZHkoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBmb2xsb3cgPSB0aGlzLmZzdy5vcHRpb25zLmZvbGxvd1N5bWxpbmtzICYmICFwYXRoLmluY2x1ZGVzKFNUQVIpICYmICFwYXRoLmluY2x1ZGVzKEJSQUNFX1NUQVJUKTtcbiAgICBsZXQgY2xvc2VyO1xuICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBjb25zdCBhYnNQYXRoID0gc3lzUGF0aC5yZXNvbHZlKHBhdGgpO1xuICAgICAgY29uc3QgdGFyZ2V0UGF0aCA9IGZvbGxvdyA/IGF3YWl0IGZzcmVhbHBhdGgocGF0aCkgOiBwYXRoO1xuICAgICAgaWYgKHRoaXMuZnN3LmNsb3NlZCkgcmV0dXJuO1xuICAgICAgY2xvc2VyID0gYXdhaXQgdGhpcy5faGFuZGxlRGlyKHdoLndhdGNoUGF0aCwgc3RhdHMsIGluaXRpYWxBZGQsIGRlcHRoLCB0YXJnZXQsIHdoLCB0YXJnZXRQYXRoKTtcbiAgICAgIGlmICh0aGlzLmZzdy5jbG9zZWQpIHJldHVybjtcbiAgICAgIC8vIHByZXNlcnZlIHRoaXMgc3ltbGluaydzIHRhcmdldCBwYXRoXG4gICAgICBpZiAoYWJzUGF0aCAhPT0gdGFyZ2V0UGF0aCAmJiB0YXJnZXRQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mc3cuX3N5bWxpbmtQYXRocy5zZXQoYWJzUGF0aCwgdGFyZ2V0UGF0aCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICBjb25zdCB0YXJnZXRQYXRoID0gZm9sbG93ID8gYXdhaXQgZnNyZWFscGF0aChwYXRoKSA6IHBhdGg7XG4gICAgICBpZiAodGhpcy5mc3cuY2xvc2VkKSByZXR1cm47XG4gICAgICBjb25zdCBwYXJlbnQgPSBzeXNQYXRoLmRpcm5hbWUod2gud2F0Y2hQYXRoKTtcbiAgICAgIHRoaXMuZnN3Ll9nZXRXYXRjaGVkRGlyKHBhcmVudCkuYWRkKHdoLndhdGNoUGF0aCk7XG4gICAgICB0aGlzLmZzdy5fZW1pdChFVl9BREQsIHdoLndhdGNoUGF0aCwgc3RhdHMpO1xuICAgICAgY2xvc2VyID0gYXdhaXQgdGhpcy5faGFuZGxlRGlyKHBhcmVudCwgc3RhdHMsIGluaXRpYWxBZGQsIGRlcHRoLCBwYXRoLCB3aCwgdGFyZ2V0UGF0aCk7XG4gICAgICBpZiAodGhpcy5mc3cuY2xvc2VkKSByZXR1cm47XG5cbiAgICAgIC8vIHByZXNlcnZlIHRoaXMgc3ltbGluaydzIHRhcmdldCBwYXRoXG4gICAgICBpZiAodGFyZ2V0UGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZnN3Ll9zeW1saW5rUGF0aHMuc2V0KHN5c1BhdGgucmVzb2x2ZShwYXRoKSwgdGFyZ2V0UGF0aCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlciA9IHRoaXMuX2hhbmRsZUZpbGUod2gud2F0Y2hQYXRoLCBzdGF0cywgaW5pdGlhbEFkZCk7XG4gICAgfVxuICAgIHJlYWR5KCk7XG5cbiAgICB0aGlzLmZzdy5fYWRkUGF0aENsb3NlcihwYXRoLCBjbG9zZXIpO1xuICAgIHJldHVybiBmYWxzZTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh0aGlzLmZzdy5faGFuZGxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICByZWFkeSgpO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9XG59XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlRnNIYW5kbGVyO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3Qgc3lzUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmxldCBmc2V2ZW50cztcbnRyeSB7XG4gIGZzZXZlbnRzID0gcmVxdWlyZSgnZnNldmVudHMnKTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGlmIChwcm9jZXNzLmVudi5DSE9LSURBUl9QUklOVF9GU0VWRU5UU19SRVFVSVJFX0VSUk9SKSBjb25zb2xlLmVycm9yKGVycm9yKTtcbn1cblxuaWYgKGZzZXZlbnRzKSB7XG4gIC8vIFRPRE86IHJlYWwgY2hlY2tcbiAgY29uc3QgbXRjaCA9IHByb2Nlc3MudmVyc2lvbi5tYXRjaCgvdihcXGQrKVxcLihcXGQrKS8pO1xuICBpZiAobXRjaCAmJiBtdGNoWzFdICYmIG10Y2hbMl0pIHtcbiAgICBjb25zdCBtYWogPSBOdW1iZXIucGFyc2VJbnQobXRjaFsxXSwgMTApO1xuICAgIGNvbnN0IG1pbiA9IE51bWJlci5wYXJzZUludChtdGNoWzJdLCAxMCk7XG4gICAgaWYgKG1haiA9PT0gOCAmJiBtaW4gPCAxNikge1xuICAgICAgZnNldmVudHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHtcbiAgRVZfQURELFxuICBFVl9DSEFOR0UsXG4gIEVWX0FERF9ESVIsXG4gIEVWX1VOTElOSyxcbiAgRVZfRVJST1IsXG4gIFNUUl9EQVRBLFxuICBTVFJfRU5ELFxuICBGU0VWRU5UX0NSRUFURUQsXG4gIEZTRVZFTlRfTU9ESUZJRUQsXG4gIEZTRVZFTlRfREVMRVRFRCxcbiAgRlNFVkVOVF9NT1ZFRCxcbiAgLy8gRlNFVkVOVF9DTE9ORUQsXG4gIEZTRVZFTlRfVU5LTk9XTixcbiAgRlNFVkVOVF9GTEFHX01VU1RfU0NBTl9TVUJESVJTLFxuICBGU0VWRU5UX1RZUEVfRklMRSxcbiAgRlNFVkVOVF9UWVBFX0RJUkVDVE9SWSxcbiAgRlNFVkVOVF9UWVBFX1NZTUxJTkssXG5cbiAgUk9PVF9HTE9CU1RBUixcbiAgRElSX1NVRkZJWCxcbiAgRE9UX1NMQVNILFxuICBGVU5DVElPTl9UWVBFLFxuICBFTVBUWV9GTixcbiAgSURFTlRJVFlfRk5cbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBEZXB0aCA9ICh2YWx1ZSkgPT4gaXNOYU4odmFsdWUpID8ge30gOiB7ZGVwdGg6IHZhbHVlfTtcblxuY29uc3Qgc3RhdCA9IHByb21pc2lmeShmcy5zdGF0KTtcbmNvbnN0IGxzdGF0ID0gcHJvbWlzaWZ5KGZzLmxzdGF0KTtcbmNvbnN0IHJlYWxwYXRoID0gcHJvbWlzaWZ5KGZzLnJlYWxwYXRoKTtcblxuY29uc3Qgc3RhdE1ldGhvZHMgPSB7IHN0YXQsIGxzdGF0IH07XG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ30gUGF0aFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRnNFdmVudHNXYXRjaENvbnRhaW5lclxuICogQHByb3BlcnR5IHtTZXQ8RnVuY3Rpb24+fSBsaXN0ZW5lcnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJhd0VtaXR0ZXJcbiAqIEBwcm9wZXJ0eSB7e3N0b3A6IEZ1bmN0aW9ufX0gd2F0Y2hlclxuICovXG5cbi8vIGZzZXZlbnRzIGluc3RhbmNlIGhlbHBlciBmdW5jdGlvbnNcbi8qKlxuICogT2JqZWN0IHRvIGhvbGQgcGVyLXByb2Nlc3MgZnNldmVudHMgaW5zdGFuY2VzIChtYXkgYmUgc2hhcmVkIGFjcm9zcyBjaG9raWRhciBGU1dhdGNoZXIgaW5zdGFuY2VzKVxuICogQHR5cGUge01hcDxQYXRoLEZzRXZlbnRzV2F0Y2hDb250YWluZXI+fVxuICovXG5jb25zdCBGU0V2ZW50c1dhdGNoZXJzID0gbmV3IE1hcCgpO1xuXG4vLyBUaHJlc2hvbGQgb2YgZHVwbGljYXRlIHBhdGggcHJlZml4ZXMgYXQgd2hpY2ggdG8gc3RhcnRcbi8vIGNvbnNvbGlkYXRpbmcgZ29pbmcgZm9yd2FyZFxuY29uc3QgY29uc29saWRhdGVUaHJlc2hob2xkID0gMTA7XG5cbmNvbnN0IHdyb25nRXZlbnRGbGFncyA9IG5ldyBTZXQoW1xuICA2OTg4OCwgNzA0MDAsIDcxNDI0LCA3MjcwNCwgNzM0NzIsIDEzMTMyOCwgMTMxODQwLCAyNjI5MTJcbl0pO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlcyB0aGUgZnNldmVudHMgaW50ZXJmYWNlXG4gKiBAcGFyYW0ge1BhdGh9IHBhdGggcGF0aCB0byBiZSB3YXRjaGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsZWQgd2hlbiBmc2V2ZW50cyBpcyBib3VuZCBhbmQgcmVhZHlcbiAqIEByZXR1cm5zIHt7c3RvcDogRnVuY3Rpb259fSBuZXcgZnNldmVudHMgaW5zdGFuY2VcbiAqL1xuY29uc3QgY3JlYXRlRlNFdmVudHNJbnN0YW5jZSA9IChwYXRoLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBzdG9wID0gZnNldmVudHMud2F0Y2gocGF0aCwgY2FsbGJhY2spO1xuICByZXR1cm4ge3N0b3B9O1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgdGhlIGZzZXZlbnRzIGludGVyZmFjZSBvciBiaW5kcyBsaXN0ZW5lcnMgdG8gYW4gZXhpc3Rpbmcgb25lIGNvdmVyaW5nXG4gKiB0aGUgc2FtZSBmaWxlIHRyZWUuXG4gKiBAcGFyYW0ge1BhdGh9IHBhdGggICAgICAgICAgIC0gdG8gYmUgd2F0Y2hlZFxuICogQHBhcmFtIHtQYXRofSByZWFsUGF0aCAgICAgICAtIHJlYWwgcGF0aCBmb3Igc3ltbGlua3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyICAgLSBjYWxsZWQgd2hlbiBmc2V2ZW50cyBlbWl0cyBldmVudHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJhd0VtaXR0ZXIgLSBwYXNzZXMgZGF0YSB0byBsaXN0ZW5lcnMgb2YgdGhlICdyYXcnIGV2ZW50XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGNsb3NlclxuICovXG5mdW5jdGlvbiBzZXRGU0V2ZW50c0xpc3RlbmVyKHBhdGgsIHJlYWxQYXRoLCBsaXN0ZW5lciwgcmF3RW1pdHRlcikge1xuICBsZXQgd2F0Y2hQYXRoID0gc3lzUGF0aC5leHRuYW1lKHJlYWxQYXRoKSA/IHN5c1BhdGguZGlybmFtZShyZWFsUGF0aCkgOiByZWFsUGF0aDtcblxuICBjb25zdCBwYXJlbnRQYXRoID0gc3lzUGF0aC5kaXJuYW1lKHdhdGNoUGF0aCk7XG4gIGxldCBjb250ID0gRlNFdmVudHNXYXRjaGVycy5nZXQod2F0Y2hQYXRoKTtcblxuICAvLyBJZiB3ZSd2ZSBhY2N1bXVsYXRlZCBhIHN1YnN0YW50aWFsIG51bWJlciBvZiBwYXRocyB0aGF0XG4gIC8vIGNvdWxkIGhhdmUgYmVlbiBjb25zb2xpZGF0ZWQgYnkgd2F0Y2hpbmcgb25lIGRpcmVjdG9yeVxuICAvLyBhYm92ZSB0aGUgY3VycmVudCBvbmUsIGNyZWF0ZSBhIHdhdGNoZXIgb24gdGhlIHBhcmVudFxuICAvLyBwYXRoIGluc3RlYWQsIHNvIHRoYXQgd2UgZG8gY29uc29saWRhdGUgZ29pbmcgZm9yd2FyZC5cbiAgaWYgKGNvdWxkQ29uc29saWRhdGUocGFyZW50UGF0aCkpIHtcbiAgICB3YXRjaFBhdGggPSBwYXJlbnRQYXRoO1xuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gc3lzUGF0aC5yZXNvbHZlKHBhdGgpO1xuICBjb25zdCBoYXNTeW1saW5rID0gcmVzb2x2ZWRQYXRoICE9PSByZWFsUGF0aDtcblxuICBjb25zdCBmaWx0ZXJlZExpc3RlbmVyID0gKGZ1bGxQYXRoLCBmbGFncywgaW5mbykgPT4ge1xuICAgIGlmIChoYXNTeW1saW5rKSBmdWxsUGF0aCA9IGZ1bGxQYXRoLnJlcGxhY2UocmVhbFBhdGgsIHJlc29sdmVkUGF0aCk7XG4gICAgaWYgKFxuICAgICAgZnVsbFBhdGggPT09IHJlc29sdmVkUGF0aCB8fFxuICAgICAgIWZ1bGxQYXRoLmluZGV4T2YocmVzb2x2ZWRQYXRoICsgc3lzUGF0aC5zZXApXG4gICAgKSBsaXN0ZW5lcihmdWxsUGF0aCwgZmxhZ3MsIGluZm8pO1xuICB9O1xuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSB3YXRjaGVyIG9uIGEgcGFyZW50IHBhdGhcbiAgLy8gbW9kaWZpZXMgYHdhdGNoUGF0aGAgdG8gdGhlIHBhcmVudCBwYXRoIHdoZW4gaXQgZmluZHMgYSBtYXRjaFxuICBsZXQgd2F0Y2hlZFBhcmVudCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHdhdGNoZWRQYXRoIG9mIEZTRXZlbnRzV2F0Y2hlcnMua2V5cygpKSB7XG4gICAgaWYgKHJlYWxQYXRoLmluZGV4T2Yoc3lzUGF0aC5yZXNvbHZlKHdhdGNoZWRQYXRoKSArIHN5c1BhdGguc2VwKSA9PT0gMCkge1xuICAgICAgd2F0Y2hQYXRoID0gd2F0Y2hlZFBhdGg7XG4gICAgICBjb250ID0gRlNFdmVudHNXYXRjaGVycy5nZXQod2F0Y2hQYXRoKTtcbiAgICAgIHdhdGNoZWRQYXJlbnQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnQgfHwgd2F0Y2hlZFBhcmVudCkge1xuICAgIGNvbnQubGlzdGVuZXJzLmFkZChmaWx0ZXJlZExpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ID0ge1xuICAgICAgbGlzdGVuZXJzOiBuZXcgU2V0KFtmaWx0ZXJlZExpc3RlbmVyXSksXG4gICAgICByYXdFbWl0dGVyLFxuICAgICAgd2F0Y2hlcjogY3JlYXRlRlNFdmVudHNJbnN0YW5jZSh3YXRjaFBhdGgsIChmdWxsUGF0aCwgZmxhZ3MpID0+IHtcbiAgICAgICAgaWYgKCFjb250Lmxpc3RlbmVycy5zaXplKSByZXR1cm47XG4gICAgICAgIGlmIChmbGFncyAmIEZTRVZFTlRfRkxBR19NVVNUX1NDQU5fU1VCRElSUykgcmV0dXJuO1xuICAgICAgICBjb25zdCBpbmZvID0gZnNldmVudHMuZ2V0SW5mbyhmdWxsUGF0aCwgZmxhZ3MpO1xuICAgICAgICBjb250Lmxpc3RlbmVycy5mb3JFYWNoKGxpc3QgPT4ge1xuICAgICAgICAgIGxpc3QoZnVsbFBhdGgsIGZsYWdzLCBpbmZvKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29udC5yYXdFbWl0dGVyKGluZm8uZXZlbnQsIGZ1bGxQYXRoLCBpbmZvKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgICBGU0V2ZW50c1dhdGNoZXJzLnNldCh3YXRjaFBhdGgsIGNvbnQpO1xuICB9XG5cbiAgLy8gcmVtb3ZlcyB0aGlzIGluc3RhbmNlJ3MgbGlzdGVuZXJzIGFuZCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgZnNldmVudHNcbiAgLy8gaW5zdGFuY2UgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIGxlZnRcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBsc3QgPSBjb250Lmxpc3RlbmVycztcblxuICAgIGxzdC5kZWxldGUoZmlsdGVyZWRMaXN0ZW5lcik7XG4gICAgaWYgKCFsc3Quc2l6ZSkge1xuICAgICAgRlNFdmVudHNXYXRjaGVycy5kZWxldGUod2F0Y2hQYXRoKTtcbiAgICAgIGlmIChjb250LndhdGNoZXIpIHJldHVybiBjb250LndhdGNoZXIuc3RvcCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb250LnJhd0VtaXR0ZXIgPSBjb250LndhdGNoZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY29udCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIERlY2lkZSB3aGV0aGVyIG9yIG5vdCB3ZSBzaG91bGQgc3RhcnQgYSBuZXcgaGlnaGVyLWxldmVsXG4vLyBwYXJlbnQgd2F0Y2hlclxuY29uc3QgY291bGRDb25zb2xpZGF0ZSA9IChwYXRoKSA9PiB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoY29uc3Qgd2F0Y2hQYXRoIG9mIEZTRXZlbnRzV2F0Y2hlcnMua2V5cygpKSB7XG4gICAgaWYgKHdhdGNoUGF0aC5pbmRleE9mKHBhdGgpID09PSAwKSB7XG4gICAgICBjb3VudCsrO1xuICAgICAgaWYgKGNvdW50ID49IGNvbnNvbGlkYXRlVGhyZXNoaG9sZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGZzZXZlbnRzIGNhbiBiZSB1c2VkXG5jb25zdCBjYW5Vc2UgPSAoKSA9PiBmc2V2ZW50cyAmJiBGU0V2ZW50c1dhdGNoZXJzLnNpemUgPCAxMjg7XG5cbi8vIGRldGVybWluZXMgc3ViZGlyZWN0b3J5IHRyYXZlcnNhbCBsZXZlbHMgZnJvbSByb290IHRvIHBhdGhcbmNvbnN0IGNhbGNEZXB0aCA9IChwYXRoLCByb290KSA9PiB7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKCFwYXRoLmluZGV4T2Yocm9vdCkgJiYgKHBhdGggPSBzeXNQYXRoLmRpcm5hbWUocGF0aCkpICE9PSByb290KSBpKys7XG4gIHJldHVybiBpO1xufTtcblxuLy8gcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZnNldmVudHMnIGV2ZW50IGluZm8gaGFzIHRoZSBzYW1lIHR5cGVcbi8vIGFzIHRoZSBvbmUgcmV0dXJuZWQgYnkgZnMuc3RhdFxuY29uc3Qgc2FtZVR5cGVzID0gKGluZm8sIHN0YXRzKSA9PiAoXG4gIGluZm8udHlwZSA9PT0gRlNFVkVOVF9UWVBFX0RJUkVDVE9SWSAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpIHx8XG4gIGluZm8udHlwZSA9PT0gRlNFVkVOVF9UWVBFX1NZTUxJTksgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSB8fFxuICBpbmZvLnR5cGUgPT09IEZTRVZFTlRfVFlQRV9GSUxFICYmIHN0YXRzLmlzRmlsZSgpXG4pXG5cbi8qKlxuICogQG1peGluXG4gKi9cbmNsYXNzIEZzRXZlbnRzSGFuZGxlciB7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuRlNXYXRjaGVyfSBmc3dcbiAqL1xuY29uc3RydWN0b3IoZnN3KSB7XG4gIHRoaXMuZnN3ID0gZnN3O1xufVxuY2hlY2tJZ25vcmVkKHBhdGgsIHN0YXRzKSB7XG4gIGNvbnN0IGlwYXRocyA9IHRoaXMuZnN3Ll9pZ25vcmVkUGF0aHM7XG4gIGlmICh0aGlzLmZzdy5faXNJZ25vcmVkKHBhdGgsIHN0YXRzKSkge1xuICAgIGlwYXRocy5hZGQocGF0aCk7XG4gICAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGlwYXRocy5hZGQocGF0aCArIFJPT1RfR0xPQlNUQVIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlwYXRocy5kZWxldGUocGF0aCk7XG4gIGlwYXRocy5kZWxldGUocGF0aCArIFJPT1RfR0xPQlNUQVIpO1xufVxuXG5hZGRPckNoYW5nZShwYXRoLCBmdWxsUGF0aCwgcmVhbFBhdGgsIHBhcmVudCwgd2F0Y2hlZERpciwgaXRlbSwgaW5mbywgb3B0cykge1xuICBjb25zdCBldmVudCA9IHdhdGNoZWREaXIuaGFzKGl0ZW0pID8gRVZfQ0hBTkdFIDogRVZfQUREO1xuICB0aGlzLmhhbmRsZUV2ZW50KGV2ZW50LCBwYXRoLCBmdWxsUGF0aCwgcmVhbFBhdGgsIHBhcmVudCwgd2F0Y2hlZERpciwgaXRlbSwgaW5mbywgb3B0cyk7XG59XG5cbmFzeW5jIGNoZWNrRXhpc3RzKHBhdGgsIGZ1bGxQYXRoLCByZWFsUGF0aCwgcGFyZW50LCB3YXRjaGVkRGlyLCBpdGVtLCBpbmZvLCBvcHRzKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBzdGF0KHBhdGgpXG4gICAgaWYgKHRoaXMuZnN3LmNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChzYW1lVHlwZXMoaW5mbywgc3RhdHMpKSB7XG4gICAgICB0aGlzLmFkZE9yQ2hhbmdlKHBhdGgsIGZ1bGxQYXRoLCByZWFsUGF0aCwgcGFyZW50LCB3YXRjaGVkRGlyLCBpdGVtLCBpbmZvLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVFdmVudChFVl9VTkxJTkssIHBhdGgsIGZ1bGxQYXRoLCByZWFsUGF0aCwgcGFyZW50LCB3YXRjaGVkRGlyLCBpdGVtLCBpbmZvLCBvcHRzKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdFQUNDRVMnKSB7XG4gICAgICB0aGlzLmFkZE9yQ2hhbmdlKHBhdGgsIGZ1bGxQYXRoLCByZWFsUGF0aCwgcGFyZW50LCB3YXRjaGVkRGlyLCBpdGVtLCBpbmZvLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVFdmVudChFVl9VTkxJTkssIHBhdGgsIGZ1bGxQYXRoLCByZWFsUGF0aCwgcGFyZW50LCB3YXRjaGVkRGlyLCBpdGVtLCBpbmZvLCBvcHRzKTtcbiAgICB9XG4gIH1cbn1cblxuaGFuZGxlRXZlbnQoZXZlbnQsIHBhdGgsIGZ1bGxQYXRoLCByZWFsUGF0aCwgcGFyZW50LCB3YXRjaGVkRGlyLCBpdGVtLCBpbmZvLCBvcHRzKSB7XG4gIGlmICh0aGlzLmZzdy5jbG9zZWQgfHwgdGhpcy5jaGVja0lnbm9yZWQocGF0aCkpIHJldHVybjtcblxuICBpZiAoZXZlbnQgPT09IEVWX1VOTElOSykge1xuICAgIGNvbnN0IGlzRGlyZWN0b3J5ID0gaW5mby50eXBlID09PSBGU0VWRU5UX1RZUEVfRElSRUNUT1JZXG4gICAgLy8gc3VwcHJlc3MgdW5saW5rIGV2ZW50cyBvbiBuZXZlciBiZWZvcmUgc2VlbiBmaWxlc1xuICAgIGlmIChpc0RpcmVjdG9yeSB8fCB3YXRjaGVkRGlyLmhhcyhpdGVtKSkge1xuICAgICAgdGhpcy5mc3cuX3JlbW92ZShwYXJlbnQsIGl0ZW0sIGlzRGlyZWN0b3J5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGV2ZW50ID09PSBFVl9BREQpIHtcbiAgICAgIC8vIHRyYWNrIG5ldyBkaXJlY3Rvcmllc1xuICAgICAgaWYgKGluZm8udHlwZSA9PT0gRlNFVkVOVF9UWVBFX0RJUkVDVE9SWSkgdGhpcy5mc3cuX2dldFdhdGNoZWREaXIocGF0aCk7XG5cbiAgICAgIGlmIChpbmZvLnR5cGUgPT09IEZTRVZFTlRfVFlQRV9TWU1MSU5LICYmIG9wdHMuZm9sbG93U3ltbGlua3MpIHtcbiAgICAgICAgLy8gcHVzaCBzeW1saW5rcyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrIHRvIGdldCBoYW5kbGVkXG4gICAgICAgIGNvbnN0IGN1ckRlcHRoID0gb3B0cy5kZXB0aCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB1bmRlZmluZWQgOiBjYWxjRGVwdGgoZnVsbFBhdGgsIHJlYWxQYXRoKSArIDE7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRUb0ZzRXZlbnRzKHBhdGgsIGZhbHNlLCB0cnVlLCBjdXJEZXB0aCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRyYWNrIG5ldyBwYXRoc1xuICAgICAgLy8gKG90aGVyIHRoYW4gc3ltbGlua3MgYmVpbmcgZm9sbG93ZWQsIHdoaWNoIHdpbGwgYmUgdHJhY2tlZCBzb29uKVxuICAgICAgdGhpcy5mc3cuX2dldFdhdGNoZWREaXIocGFyZW50KS5hZGQoaXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHsnYWRkJ3wnYWRkRGlyJ3wndW5saW5rJ3wndW5saW5rRGlyJ31cbiAgICAgKi9cbiAgICBjb25zdCBldmVudE5hbWUgPSBpbmZvLnR5cGUgPT09IEZTRVZFTlRfVFlQRV9ESVJFQ1RPUlkgPyBldmVudCArIERJUl9TVUZGSVggOiBldmVudDtcbiAgICB0aGlzLmZzdy5fZW1pdChldmVudE5hbWUsIHBhdGgpO1xuICAgIGlmIChldmVudE5hbWUgPT09IEVWX0FERF9ESVIpIHRoaXMuX2FkZFRvRnNFdmVudHMocGF0aCwgZmFsc2UsIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIHN5bWxpbmtzIGVuY291bnRlcmVkIGR1cmluZyBkaXJlY3Rvcnkgc2NhblxuICogQHBhcmFtIHtTdHJpbmd9IHdhdGNoUGF0aCAgLSBmaWxlL2RpciBwYXRoIHRvIGJlIHdhdGNoZWQgd2l0aCBmc2V2ZW50c1xuICogQHBhcmFtIHtTdHJpbmd9IHJlYWxQYXRoICAgLSByZWFsIHBhdGggKGluIGNhc2Ugb2Ygc3ltbGlua3MpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gIC0gcGF0aCB0cmFuc2Zvcm1lclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2xvYkZpbHRlciAtIHBhdGggZmlsdGVyIGluIGNhc2UgYSBnbG9iIHBhdHRlcm4gd2FzIHByb3ZpZGVkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGNsb3NlciBmb3IgdGhlIHdhdGNoZXIgaW5zdGFuY2VcbiovXG5fd2F0Y2hXaXRoRnNFdmVudHMod2F0Y2hQYXRoLCByZWFsUGF0aCwgdHJhbnNmb3JtLCBnbG9iRmlsdGVyKSB7XG4gIGlmICh0aGlzLmZzdy5jbG9zZWQgfHwgdGhpcy5mc3cuX2lzSWdub3JlZCh3YXRjaFBhdGgpKSByZXR1cm47XG4gIGNvbnN0IG9wdHMgPSB0aGlzLmZzdy5vcHRpb25zO1xuICBjb25zdCB3YXRjaENhbGxiYWNrID0gYXN5bmMgKGZ1bGxQYXRoLCBmbGFncywgaW5mbykgPT4ge1xuICAgIGlmICh0aGlzLmZzdy5jbG9zZWQpIHJldHVybjtcbiAgICBpZiAoXG4gICAgICBvcHRzLmRlcHRoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGNhbGNEZXB0aChmdWxsUGF0aCwgcmVhbFBhdGgpID4gb3B0cy5kZXB0aFxuICAgICkgcmV0dXJuO1xuICAgIGNvbnN0IHBhdGggPSB0cmFuc2Zvcm0oc3lzUGF0aC5qb2luKFxuICAgICAgd2F0Y2hQYXRoLCBzeXNQYXRoLnJlbGF0aXZlKHdhdGNoUGF0aCwgZnVsbFBhdGgpXG4gICAgKSk7XG4gICAgaWYgKGdsb2JGaWx0ZXIgJiYgIWdsb2JGaWx0ZXIocGF0aCkpIHJldHVybjtcbiAgICAvLyBlbnN1cmUgZGlyZWN0b3JpZXMgYXJlIHRyYWNrZWRcbiAgICBjb25zdCBwYXJlbnQgPSBzeXNQYXRoLmRpcm5hbWUocGF0aCk7XG4gICAgY29uc3QgaXRlbSA9IHN5c1BhdGguYmFzZW5hbWUocGF0aCk7XG4gICAgY29uc3Qgd2F0Y2hlZERpciA9IHRoaXMuZnN3Ll9nZXRXYXRjaGVkRGlyKFxuICAgICAgaW5mby50eXBlID09PSBGU0VWRU5UX1RZUEVfRElSRUNUT1JZID8gcGF0aCA6IHBhcmVudFxuICAgICk7XG5cbiAgICAvLyBjb3JyZWN0IGZvciB3cm9uZyBldmVudHMgZW1pdHRlZFxuICAgIGlmICh3cm9uZ0V2ZW50RmxhZ3MuaGFzKGZsYWdzKSB8fCBpbmZvLmV2ZW50ID09PSBGU0VWRU5UX1VOS05PV04pIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5pZ25vcmVkID09PSBGVU5DVElPTl9UWVBFKSB7XG4gICAgICAgIGxldCBzdGF0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0cyA9IGF3YWl0IHN0YXQocGF0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgICAgICBpZiAodGhpcy5mc3cuY2xvc2VkKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmNoZWNrSWdub3JlZChwYXRoLCBzdGF0cykpIHJldHVybjtcbiAgICAgICAgaWYgKHNhbWVUeXBlcyhpbmZvLCBzdGF0cykpIHtcbiAgICAgICAgICB0aGlzLmFkZE9yQ2hhbmdlKHBhdGgsIGZ1bGxQYXRoLCByZWFsUGF0aCwgcGFyZW50LCB3YXRjaGVkRGlyLCBpdGVtLCBpbmZvLCBvcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KEVWX1VOTElOSywgcGF0aCwgZnVsbFBhdGgsIHJlYWxQYXRoLCBwYXJlbnQsIHdhdGNoZWREaXIsIGl0ZW0sIGluZm8sIG9wdHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrRXhpc3RzKHBhdGgsIGZ1bGxQYXRoLCByZWFsUGF0aCwgcGFyZW50LCB3YXRjaGVkRGlyLCBpdGVtLCBpbmZvLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChpbmZvLmV2ZW50KSB7XG4gICAgICBjYXNlIEZTRVZFTlRfQ1JFQVRFRDpcbiAgICAgIGNhc2UgRlNFVkVOVF9NT0RJRklFRDpcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkT3JDaGFuZ2UocGF0aCwgZnVsbFBhdGgsIHJlYWxQYXRoLCBwYXJlbnQsIHdhdGNoZWREaXIsIGl0ZW0sIGluZm8sIG9wdHMpO1xuICAgICAgY2FzZSBGU0VWRU5UX0RFTEVURUQ6XG4gICAgICBjYXNlIEZTRVZFTlRfTU9WRUQ6XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrRXhpc3RzKHBhdGgsIGZ1bGxQYXRoLCByZWFsUGF0aCwgcGFyZW50LCB3YXRjaGVkRGlyLCBpdGVtLCBpbmZvLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2xvc2VyID0gc2V0RlNFdmVudHNMaXN0ZW5lcihcbiAgICB3YXRjaFBhdGgsXG4gICAgcmVhbFBhdGgsXG4gICAgd2F0Y2hDYWxsYmFjayxcbiAgICB0aGlzLmZzdy5fZW1pdFJhd1xuICApO1xuXG4gIHRoaXMuZnN3Ll9lbWl0UmVhZHkoKTtcbiAgcmV0dXJuIGNsb3Nlcjtcbn1cblxuLyoqXG4gKiBIYW5kbGUgc3ltbGlua3MgZW5jb3VudGVyZWQgZHVyaW5nIGRpcmVjdG9yeSBzY2FuXG4gKiBAcGFyYW0ge1N0cmluZ30gbGlua1BhdGggcGF0aCB0byBzeW1saW5rXG4gKiBAcGFyYW0ge1N0cmluZ30gZnVsbFBhdGggYWJzb2x1dGUgcGF0aCB0byB0aGUgc3ltbGlua1xuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIHByZS1leGlzdGluZyBwYXRoIHRyYW5zZm9ybWVyXG4gKiBAcGFyYW0ge051bWJlcn0gY3VyRGVwdGggbGV2ZWwgb2Ygc3ViZGlyZWN0b3JpZXMgdHJhdmVyc2VkIHRvIHdoZXJlIHN5bWxpbmsgaXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5hc3luYyBfaGFuZGxlRnNFdmVudHNTeW1saW5rKGxpbmtQYXRoLCBmdWxsUGF0aCwgdHJhbnNmb3JtLCBjdXJEZXB0aCkge1xuICAvLyBkb24ndCBmb2xsb3cgdGhlIHNhbWUgc3ltbGluayBtb3JlIHRoYW4gb25jZVxuICBpZiAodGhpcy5mc3cuY2xvc2VkIHx8IHRoaXMuZnN3Ll9zeW1saW5rUGF0aHMuaGFzKGZ1bGxQYXRoKSkgcmV0dXJuO1xuXG4gIHRoaXMuZnN3Ll9zeW1saW5rUGF0aHMuc2V0KGZ1bGxQYXRoLCB0cnVlKTtcbiAgdGhpcy5mc3cuX2luY3JSZWFkeUNvdW50KCk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBsaW5rVGFyZ2V0ID0gYXdhaXQgcmVhbHBhdGgobGlua1BhdGgpO1xuICAgIGlmICh0aGlzLmZzdy5jbG9zZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5mc3cuX2lzSWdub3JlZChsaW5rVGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZnN3Ll9lbWl0UmVhZHkoKTtcbiAgICB9XG5cbiAgICB0aGlzLmZzdy5faW5jclJlYWR5Q291bnQoKTtcblxuICAgIC8vIGFkZCB0aGUgbGlua1RhcmdldCBmb3Igd2F0Y2hpbmcgd2l0aCBhIHdyYXBwZXIgZm9yIHRyYW5zZm9ybVxuICAgIC8vIHRoYXQgY2F1c2VzIGVtaXR0ZWQgcGF0aHMgdG8gaW5jb3Jwb3JhdGUgdGhlIGxpbmsncyBwYXRoXG4gICAgdGhpcy5fYWRkVG9Gc0V2ZW50cyhsaW5rVGFyZ2V0IHx8IGxpbmtQYXRoLCAocGF0aCkgPT4ge1xuICAgICAgbGV0IGFsaWFzZWRQYXRoID0gbGlua1BhdGg7XG4gICAgICBpZiAobGlua1RhcmdldCAmJiBsaW5rVGFyZ2V0ICE9PSBET1RfU0xBU0gpIHtcbiAgICAgICAgYWxpYXNlZFBhdGggPSBwYXRoLnJlcGxhY2UobGlua1RhcmdldCwgbGlua1BhdGgpO1xuICAgICAgfSBlbHNlIGlmIChwYXRoICE9PSBET1RfU0xBU0gpIHtcbiAgICAgICAgYWxpYXNlZFBhdGggPSBzeXNQYXRoLmpvaW4obGlua1BhdGgsIHBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybShhbGlhc2VkUGF0aCk7XG4gICAgfSwgZmFsc2UsIGN1ckRlcHRoKTtcbiAgfSBjYXRjaChlcnJvcikge1xuICAgIGlmICh0aGlzLmZzdy5faGFuZGxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mc3cuX2VtaXRSZWFkeSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1BhdGh9IG5ld1BhdGhcbiAqIEBwYXJhbSB7ZnMuU3RhdHN9IHN0YXRzXG4gKi9cbmVtaXRBZGQobmV3UGF0aCwgc3RhdHMsIHByb2Nlc3NQYXRoLCBvcHRzLCBmb3JjZUFkZCkge1xuICBjb25zdCBwcCA9IHByb2Nlc3NQYXRoKG5ld1BhdGgpO1xuICBjb25zdCBpc0RpciA9IHN0YXRzLmlzRGlyZWN0b3J5KCk7XG4gIGNvbnN0IGRpck9iaiA9IHRoaXMuZnN3Ll9nZXRXYXRjaGVkRGlyKHN5c1BhdGguZGlybmFtZShwcCkpO1xuICBjb25zdCBiYXNlID0gc3lzUGF0aC5iYXNlbmFtZShwcCk7XG5cbiAgLy8gZW5zdXJlIGVtcHR5IGRpcnMgZ2V0IHRyYWNrZWRcbiAgaWYgKGlzRGlyKSB0aGlzLmZzdy5fZ2V0V2F0Y2hlZERpcihwcCk7XG4gIGlmIChkaXJPYmouaGFzKGJhc2UpKSByZXR1cm47XG4gIGRpck9iai5hZGQoYmFzZSk7XG5cbiAgaWYgKCFvcHRzLmlnbm9yZUluaXRpYWwgfHwgZm9yY2VBZGQgPT09IHRydWUpIHtcbiAgICB0aGlzLmZzdy5fZW1pdChpc0RpciA/IEVWX0FERF9ESVIgOiBFVl9BREQsIHBwLCBzdGF0cyk7XG4gIH1cbn1cblxuaW5pdFdhdGNoKHJlYWxQYXRoLCBwYXRoLCB3aCwgcHJvY2Vzc1BhdGgpIHtcbiAgaWYgKHRoaXMuZnN3LmNsb3NlZCkgcmV0dXJuO1xuICBjb25zdCBjbG9zZXIgPSB0aGlzLl93YXRjaFdpdGhGc0V2ZW50cyhcbiAgICB3aC53YXRjaFBhdGgsXG4gICAgc3lzUGF0aC5yZXNvbHZlKHJlYWxQYXRoIHx8IHdoLndhdGNoUGF0aCksXG4gICAgcHJvY2Vzc1BhdGgsXG4gICAgd2guZ2xvYkZpbHRlclxuICApO1xuICB0aGlzLmZzdy5fYWRkUGF0aENsb3NlcihwYXRoLCBjbG9zZXIpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBhZGRlZCBwYXRoIHdpdGggZnNldmVudHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGZpbGUvZGlyIHBhdGggb3IgZ2xvYiBwYXR0ZXJuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEJvb2xlYW49fSB0cmFuc2Zvcm0gY29udmVydHMgd29ya2luZyBwYXRoIHRvIHdoYXQgdGhlIHVzZXIgZXhwZWN0c1xuICogQHBhcmFtIHtCb29sZWFuPX0gZm9yY2VBZGQgZW5zdXJlIGFkZCBpcyBlbWl0dGVkXG4gKiBAcGFyYW0ge051bWJlcj19IHByaW9yRGVwdGggTGV2ZWwgb2Ygc3ViZGlyZWN0b3JpZXMgYWxyZWFkeSB0cmF2ZXJzZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuYXN5bmMgX2FkZFRvRnNFdmVudHMocGF0aCwgdHJhbnNmb3JtLCBmb3JjZUFkZCwgcHJpb3JEZXB0aCkge1xuICBpZiAodGhpcy5mc3cuY2xvc2VkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9wdHMgPSB0aGlzLmZzdy5vcHRpb25zO1xuICBjb25zdCBwcm9jZXNzUGF0aCA9IHR5cGVvZiB0cmFuc2Zvcm0gPT09IEZVTkNUSU9OX1RZUEUgPyB0cmFuc2Zvcm0gOiBJREVOVElUWV9GTjtcblxuICBjb25zdCB3aCA9IHRoaXMuZnN3Ll9nZXRXYXRjaEhlbHBlcnMocGF0aCk7XG5cbiAgLy8gZXZhbHVhdGUgd2hhdCBpcyBhdCB0aGUgcGF0aCB3ZSdyZSBiZWluZyBhc2tlZCB0byB3YXRjaFxuICB0cnkge1xuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgc3RhdE1ldGhvZHNbd2guc3RhdE1ldGhvZF0od2gud2F0Y2hQYXRoKTtcbiAgICBpZiAodGhpcy5mc3cuY2xvc2VkKSByZXR1cm47XG4gICAgaWYgKHRoaXMuZnN3Ll9pc0lnbm9yZWQod2gud2F0Y2hQYXRoLCBzdGF0cykpIHtcbiAgICAgIHRocm93IG51bGw7XG4gICAgfVxuICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAvLyBlbWl0IGFkZERpciB1bmxlc3MgdGhpcyBpcyBhIGdsb2IgcGFyZW50XG4gICAgICBpZiAoIXdoLmdsb2JGaWx0ZXIpIHRoaXMuZW1pdEFkZChwcm9jZXNzUGF0aChwYXRoKSwgc3RhdHMsIHByb2Nlc3NQYXRoLCBvcHRzLCBmb3JjZUFkZCk7XG5cbiAgICAgIC8vIGRvbid0IHJlY3Vyc2UgZnVydGhlciBpZiBpdCB3b3VsZCBleGNlZWQgZGVwdGggc2V0dGluZ1xuICAgICAgaWYgKHByaW9yRGVwdGggJiYgcHJpb3JEZXB0aCA+IG9wdHMuZGVwdGgpIHJldHVybjtcblxuICAgICAgLy8gc2NhbiB0aGUgY29udGVudHMgb2YgdGhlIGRpclxuICAgICAgdGhpcy5mc3cuX3JlYWRkaXJwKHdoLndhdGNoUGF0aCwge1xuICAgICAgICBmaWxlRmlsdGVyOiBlbnRyeSA9PiB3aC5maWx0ZXJQYXRoKGVudHJ5KSxcbiAgICAgICAgZGlyZWN0b3J5RmlsdGVyOiBlbnRyeSA9PiB3aC5maWx0ZXJEaXIoZW50cnkpLFxuICAgICAgICAuLi5EZXB0aChvcHRzLmRlcHRoIC0gKHByaW9yRGVwdGggfHwgMCkpXG4gICAgICB9KS5vbihTVFJfREFUQSwgKGVudHJ5KSA9PiB7XG4gICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgZmlsdGVyUGF0aCBvbiBkaXJzIGIvYyBmaWx0ZXJEaXIgaXMgbGVzcyByZXN0cmljdGl2ZVxuICAgICAgICBpZiAodGhpcy5mc3cuY2xvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeS5zdGF0cy5pc0RpcmVjdG9yeSgpICYmICF3aC5maWx0ZXJQYXRoKGVudHJ5KSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGpvaW5lZFBhdGggPSBzeXNQYXRoLmpvaW4od2gud2F0Y2hQYXRoLCBlbnRyeS5wYXRoKTtcbiAgICAgICAgY29uc3Qge2Z1bGxQYXRofSA9IGVudHJ5O1xuXG4gICAgICAgIGlmICh3aC5mb2xsb3dTeW1saW5rcyAmJiBlbnRyeS5zdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgLy8gcHJlc2VydmUgdGhlIGN1cnJlbnQgZGVwdGggaGVyZSBzaW5jZSBpdCBjYW4ndCBiZSBkZXJpdmVkIGZyb21cbiAgICAgICAgICAvLyByZWFsIHBhdGhzIHBhc3QgdGhlIHN5bWxpbmtcbiAgICAgICAgICBjb25zdCBjdXJEZXB0aCA9IG9wdHMuZGVwdGggPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB1bmRlZmluZWQgOiBjYWxjRGVwdGgoam9pbmVkUGF0aCwgc3lzUGF0aC5yZXNvbHZlKHdoLndhdGNoUGF0aCkpICsgMTtcblxuICAgICAgICAgIHRoaXMuX2hhbmRsZUZzRXZlbnRzU3ltbGluayhqb2luZWRQYXRoLCBmdWxsUGF0aCwgcHJvY2Vzc1BhdGgsIGN1ckRlcHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXRBZGQoam9pbmVkUGF0aCwgZW50cnkuc3RhdHMsIHByb2Nlc3NQYXRoLCBvcHRzLCBmb3JjZUFkZCk7XG4gICAgICAgIH1cbiAgICAgIH0pLm9uKEVWX0VSUk9SLCBFTVBUWV9GTikub24oU1RSX0VORCwgKCkgPT4ge1xuICAgICAgICB0aGlzLmZzdy5fZW1pdFJlYWR5KCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0QWRkKHdoLndhdGNoUGF0aCwgc3RhdHMsIHByb2Nlc3NQYXRoLCBvcHRzLCBmb3JjZUFkZCk7XG4gICAgICB0aGlzLmZzdy5fZW1pdFJlYWR5KCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICghZXJyb3IgfHwgdGhpcy5mc3cuX2hhbmRsZUVycm9yKGVycm9yKSkge1xuICAgICAgLy8gVE9ETzogU3RyYW5nZSB0aGluZzogXCJzaG91bGQgbm90IGNob2tlIG9uIGFuIGlnbm9yZWQgd2F0Y2ggcGF0aFwiIHdpbGwgYmUgZmFpbGVkIHdpdGhvdXQgMiByZWFkeSBjYWxscyAtX18tXG4gICAgICB0aGlzLmZzdy5fZW1pdFJlYWR5KCk7XG4gICAgICB0aGlzLmZzdy5fZW1pdFJlYWR5KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMucGVyc2lzdGVudCAmJiBmb3JjZUFkZCAhPT0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSBGVU5DVElPTl9UWVBFKSB7XG4gICAgICAvLyByZWFscGF0aCBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkXG4gICAgICB0aGlzLmluaXRXYXRjaCh1bmRlZmluZWQsIHBhdGgsIHdoLCBwcm9jZXNzUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZWFsUGF0aDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlYWxQYXRoID0gYXdhaXQgcmVhbHBhdGgod2gud2F0Y2hQYXRoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB0aGlzLmluaXRXYXRjaChyZWFsUGF0aCwgcGF0aCwgd2gsIHByb2Nlc3NQYXRoKTtcbiAgICB9XG4gIH1cbn1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZzRXZlbnRzSGFuZGxlcjtcbm1vZHVsZS5leHBvcnRzLmNhblVzZSA9IGNhblVzZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHN5c1BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgcmVhZGRpcnAgPSByZXF1aXJlKCdyZWFkZGlycCcpO1xuY29uc3QgYW55bWF0Y2ggPSByZXF1aXJlKCdhbnltYXRjaCcpLmRlZmF1bHQ7XG5jb25zdCBnbG9iUGFyZW50ID0gcmVxdWlyZSgnZ2xvYi1wYXJlbnQnKTtcbmNvbnN0IGlzR2xvYiA9IHJlcXVpcmUoJ2lzLWdsb2InKTtcbmNvbnN0IGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuY29uc3Qgbm9ybWFsaXplUGF0aCA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1wYXRoJyk7XG5cbmNvbnN0IE5vZGVGc0hhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9ub2RlZnMtaGFuZGxlcicpO1xuY29uc3QgRnNFdmVudHNIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvZnNldmVudHMtaGFuZGxlcicpO1xuY29uc3Qge1xuICBFVl9BTEwsXG4gIEVWX1JFQURZLFxuICBFVl9BREQsXG4gIEVWX0NIQU5HRSxcbiAgRVZfVU5MSU5LLFxuICBFVl9BRERfRElSLFxuICBFVl9VTkxJTktfRElSLFxuICBFVl9SQVcsXG4gIEVWX0VSUk9SLFxuXG4gIFNUUl9DTE9TRSxcbiAgU1RSX0VORCxcblxuICBCQUNLX1NMQVNIX1JFLFxuICBET1VCTEVfU0xBU0hfUkUsXG4gIFNMQVNIX09SX0JBQ0tfU0xBU0hfUkUsXG4gIERPVF9SRSxcbiAgUkVQTEFDRVJfUkUsXG5cbiAgU0xBU0gsXG4gIFNMQVNIX1NMQVNILFxuICBCUkFDRV9TVEFSVCxcbiAgQkFORyxcbiAgT05FX0RPVCxcbiAgVFdPX0RPVFMsXG4gIEdMT0JTVEFSLFxuICBTTEFTSF9HTE9CU1RBUixcbiAgQU5ZTUFUQ0hfT1BUUyxcbiAgU1RSSU5HX1RZUEUsXG4gIEZVTkNUSU9OX1RZUEUsXG4gIEVNUFRZX1NUUixcbiAgRU1QVFlfRk4sXG5cbiAgaXNXaW5kb3dzLFxuICBpc01hY29zLFxuICBpc0lCTWlcbn0gPSByZXF1aXJlKCcuL2xpYi9jb25zdGFudHMnKTtcblxuY29uc3Qgc3RhdCA9IHByb21pc2lmeShmcy5zdGF0KTtcbmNvbnN0IHJlYWRkaXIgPSBwcm9taXNpZnkoZnMucmVhZGRpcik7XG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ30gUGF0aFxuICogQHR5cGVkZWYgeydhbGwnfCdhZGQnfCdhZGREaXInfCdjaGFuZ2UnfCd1bmxpbmsnfCd1bmxpbmtEaXInfCdyYXcnfCdlcnJvcid8J3JlYWR5J30gRXZlbnROYW1lXG4gKiBAdHlwZWRlZiB7J3JlYWRkaXInfCd3YXRjaCd8J2FkZCd8J3JlbW92ZSd8J2NoYW5nZSd9IFRocm90dGxlVHlwZVxuICovXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdhdGNoSGVscGVyc1xuICogQHByb3BlcnR5IHtCb29sZWFufSBmb2xsb3dTeW1saW5rc1xuICogQHByb3BlcnR5IHsnc3RhdCd8J2xzdGF0J30gc3RhdE1ldGhvZFxuICogQHByb3BlcnR5IHtQYXRofSBwYXRoXG4gKiBAcHJvcGVydHkge1BhdGh9IHdhdGNoUGF0aFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZW50cnlQYXRoXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGhhc0dsb2JcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnbG9iRmlsdGVyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmaWx0ZXJQYXRoXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmaWx0ZXJEaXJcbiAqL1xuXG5jb25zdCBhcnJpZnkgPSAodmFsdWUgPSBbXSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG5jb25zdCBmbGF0dGVuID0gKGxpc3QsIHJlc3VsdCA9IFtdKSA9PiB7XG4gIGxpc3QuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgZmxhdHRlbihpdGVtLCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgdW5pZnlQYXRocyA9IChwYXRoc18pID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fVxuICAgKi9cbiAgY29uc3QgcGF0aHMgPSBmbGF0dGVuKGFycmlmeShwYXRoc18pKTtcbiAgaWYgKCFwYXRocy5ldmVyeShwID0+IHR5cGVvZiBwID09PSBTVFJJTkdfVFlQRSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBOb24tc3RyaW5nIHByb3ZpZGVkIGFzIHdhdGNoIHBhdGg6ICR7cGF0aHN9YCk7XG4gIH1cbiAgcmV0dXJuIHBhdGhzLm1hcChub3JtYWxpemVQYXRoVG9Vbml4KTtcbn07XG5cbi8vIElmIFNMQVNIX1NMQVNIIG9jY3VycyBhdCB0aGUgYmVnaW5uaW5nIG9mIHBhdGgsIGl0IGlzIG5vdCByZXBsYWNlZFxuLy8gICAgIGJlY2F1c2UgXCIvL1N0b3JhZ2VQQy9Ecml2ZVBvb2wvTW92aWVzXCIgaXMgYSB2YWxpZCBuZXR3b3JrIHBhdGhcbmNvbnN0IHRvVW5peCA9IChzdHJpbmcpID0+IHtcbiAgbGV0IHN0ciA9IHN0cmluZy5yZXBsYWNlKEJBQ0tfU0xBU0hfUkUsIFNMQVNIKTtcbiAgbGV0IHByZXBlbmQgPSBmYWxzZTtcbiAgaWYgKHN0ci5zdGFydHNXaXRoKFNMQVNIX1NMQVNIKSkge1xuICAgIHByZXBlbmQgPSB0cnVlO1xuICB9XG4gIHdoaWxlIChzdHIubWF0Y2goRE9VQkxFX1NMQVNIX1JFKSkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKERPVUJMRV9TTEFTSF9SRSwgU0xBU0gpO1xuICB9XG4gIGlmIChwcmVwZW5kKSB7XG4gICAgc3RyID0gU0xBU0ggKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8vIE91ciB2ZXJzaW9uIG9mIHVwYXRoLm5vcm1hbGl6ZVxuLy8gVE9ETzogdGhpcyBpcyBub3QgZXF1YWwgdG8gcGF0aC1ub3JtYWxpemUgbW9kdWxlIC0gaW52ZXN0aWdhdGUgd2h5XG5jb25zdCBub3JtYWxpemVQYXRoVG9Vbml4ID0gKHBhdGgpID0+IHRvVW5peChzeXNQYXRoLm5vcm1hbGl6ZSh0b1VuaXgocGF0aCkpKTtcblxuY29uc3Qgbm9ybWFsaXplSWdub3JlZCA9IChjd2QgPSBFTVBUWV9TVFIpID0+IChwYXRoKSA9PiB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gU1RSSU5HX1RZUEUpIHJldHVybiBwYXRoO1xuICByZXR1cm4gbm9ybWFsaXplUGF0aFRvVW5peChzeXNQYXRoLmlzQWJzb2x1dGUocGF0aCkgPyBwYXRoIDogc3lzUGF0aC5qb2luKGN3ZCwgcGF0aCkpO1xufTtcblxuY29uc3QgZ2V0QWJzb2x1dGVQYXRoID0gKHBhdGgsIGN3ZCkgPT4ge1xuICBpZiAoc3lzUGF0aC5pc0Fic29sdXRlKHBhdGgpKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChCQU5HKSkge1xuICAgIHJldHVybiBCQU5HICsgc3lzUGF0aC5qb2luKGN3ZCwgcGF0aC5zbGljZSgxKSk7XG4gIH1cbiAgcmV0dXJuIHN5c1BhdGguam9pbihjd2QsIHBhdGgpO1xufTtcblxuY29uc3QgdW5kZWYgPSAob3B0cywga2V5KSA9PiBvcHRzW2tleV0gPT09IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBEaXJlY3RvcnkgZW50cnkuXG4gKiBAcHJvcGVydHkge1BhdGh9IHBhdGhcbiAqIEBwcm9wZXJ0eSB7U2V0PFBhdGg+fSBpdGVtc1xuICovXG5jbGFzcyBEaXJFbnRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BhdGh9IGRpclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZW1vdmVXYXRjaGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkaXIsIHJlbW92ZVdhdGNoZXIpIHtcbiAgICB0aGlzLnBhdGggPSBkaXI7XG4gICAgdGhpcy5fcmVtb3ZlV2F0Y2hlciA9IHJlbW92ZVdhdGNoZXI7XG4gICAgLyoqIEB0eXBlIHtTZXQ8UGF0aD59ICovXG4gICAgdGhpcy5pdGVtcyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIGFkZChpdGVtKSB7XG4gICAgY29uc3Qge2l0ZW1zfSA9IHRoaXM7XG4gICAgaWYgKCFpdGVtcykgcmV0dXJuO1xuICAgIGlmIChpdGVtICE9PSBPTkVfRE9UICYmIGl0ZW0gIT09IFRXT19ET1RTKSBpdGVtcy5hZGQoaXRlbSk7XG4gIH1cblxuICBhc3luYyByZW1vdmUoaXRlbSkge1xuICAgIGNvbnN0IHtpdGVtc30gPSB0aGlzO1xuICAgIGlmICghaXRlbXMpIHJldHVybjtcbiAgICBpdGVtcy5kZWxldGUoaXRlbSk7XG4gICAgaWYgKGl0ZW1zLnNpemUgPiAwKSByZXR1cm47XG5cbiAgICBjb25zdCBkaXIgPSB0aGlzLnBhdGg7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJlYWRkaXIoZGlyKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0aGlzLl9yZW1vdmVXYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVdhdGNoZXIoc3lzUGF0aC5kaXJuYW1lKGRpciksIHN5c1BhdGguYmFzZW5hbWUoZGlyKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFzKGl0ZW0pIHtcbiAgICBjb25zdCB7aXRlbXN9ID0gdGhpcztcbiAgICBpZiAoIWl0ZW1zKSByZXR1cm47XG4gICAgcmV0dXJuIGl0ZW1zLmhhcyhpdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7QXJyYXk8U3RyaW5nPn1cbiAgICovXG4gIGdldENoaWxkcmVuKCkge1xuICAgIGNvbnN0IHtpdGVtc30gPSB0aGlzO1xuICAgIGlmICghaXRlbXMpIHJldHVybjtcbiAgICByZXR1cm4gWy4uLml0ZW1zLnZhbHVlcygpXTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5pdGVtcy5jbGVhcigpO1xuICAgIGRlbGV0ZSB0aGlzLnBhdGg7XG4gICAgZGVsZXRlIHRoaXMuX3JlbW92ZVdhdGNoZXI7XG4gICAgZGVsZXRlIHRoaXMuaXRlbXM7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxufVxuXG5jb25zdCBTVEFUX01FVEhPRF9GID0gJ3N0YXQnO1xuY29uc3QgU1RBVF9NRVRIT0RfTCA9ICdsc3RhdCc7XG5jbGFzcyBXYXRjaEhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKHBhdGgsIHdhdGNoUGF0aCwgZm9sbG93LCBmc3cpIHtcbiAgICB0aGlzLmZzdyA9IGZzdztcbiAgICB0aGlzLnBhdGggPSBwYXRoID0gcGF0aC5yZXBsYWNlKFJFUExBQ0VSX1JFLCBFTVBUWV9TVFIpO1xuICAgIHRoaXMud2F0Y2hQYXRoID0gd2F0Y2hQYXRoO1xuICAgIHRoaXMuZnVsbFdhdGNoUGF0aCA9IHN5c1BhdGgucmVzb2x2ZSh3YXRjaFBhdGgpO1xuICAgIHRoaXMuaGFzR2xvYiA9IHdhdGNoUGF0aCAhPT0gcGF0aDtcbiAgICAvKiogQHR5cGUge29iamVjdHxib29sZWFufSAqL1xuICAgIGlmIChwYXRoID09PSBFTVBUWV9TVFIpIHRoaXMuaGFzR2xvYiA9IGZhbHNlO1xuICAgIHRoaXMuZ2xvYlN5bWxpbmsgPSB0aGlzLmhhc0dsb2IgJiYgZm9sbG93ID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgdGhpcy5nbG9iRmlsdGVyID0gdGhpcy5oYXNHbG9iID8gYW55bWF0Y2gocGF0aCwgdW5kZWZpbmVkLCBBTllNQVRDSF9PUFRTKSA6IGZhbHNlO1xuICAgIHRoaXMuZGlyUGFydHMgPSB0aGlzLmdldERpclBhcnRzKHBhdGgpO1xuICAgIHRoaXMuZGlyUGFydHMuZm9yRWFjaCgocGFydHMpID0+IHtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSBwYXJ0cy5wb3AoKTtcbiAgICB9KTtcbiAgICB0aGlzLmZvbGxvd1N5bWxpbmtzID0gZm9sbG93O1xuICAgIHRoaXMuc3RhdE1ldGhvZCA9IGZvbGxvdyA/IFNUQVRfTUVUSE9EX0YgOiBTVEFUX01FVEhPRF9MO1xuICB9XG5cbiAgY2hlY2tHbG9iU3ltbGluayhlbnRyeSkge1xuICAgIC8vIG9ubHkgbmVlZCB0byByZXNvbHZlIG9uY2VcbiAgICAvLyBmaXJzdCBlbnRyeSBzaG91bGQgYWx3YXlzIGhhdmUgZW50cnkucGFyZW50RGlyID09PSBFTVBUWV9TVFJcbiAgICBpZiAodGhpcy5nbG9iU3ltbGluayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmdsb2JTeW1saW5rID0gZW50cnkuZnVsbFBhcmVudERpciA9PT0gdGhpcy5mdWxsV2F0Y2hQYXRoID9cbiAgICAgICAgZmFsc2UgOiB7cmVhbFBhdGg6IGVudHJ5LmZ1bGxQYXJlbnREaXIsIGxpbmtQYXRoOiB0aGlzLmZ1bGxXYXRjaFBhdGh9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdsb2JTeW1saW5rKSB7XG4gICAgICByZXR1cm4gZW50cnkuZnVsbFBhdGgucmVwbGFjZSh0aGlzLmdsb2JTeW1saW5rLnJlYWxQYXRoLCB0aGlzLmdsb2JTeW1saW5rLmxpbmtQYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkuZnVsbFBhdGg7XG4gIH1cblxuICBlbnRyeVBhdGgoZW50cnkpIHtcbiAgICByZXR1cm4gc3lzUGF0aC5qb2luKHRoaXMud2F0Y2hQYXRoLFxuICAgICAgc3lzUGF0aC5yZWxhdGl2ZSh0aGlzLndhdGNoUGF0aCwgdGhpcy5jaGVja0dsb2JTeW1saW5rKGVudHJ5KSlcbiAgICApO1xuICB9XG5cbiAgZmlsdGVyUGF0aChlbnRyeSkge1xuICAgIGNvbnN0IHtzdGF0c30gPSBlbnRyeTtcbiAgICBpZiAoc3RhdHMgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIHRoaXMuZmlsdGVyRGlyKGVudHJ5KTtcbiAgICBjb25zdCByZXNvbHZlZFBhdGggPSB0aGlzLmVudHJ5UGF0aChlbnRyeSk7XG4gICAgY29uc3QgbWF0Y2hlc0dsb2IgPSB0aGlzLmhhc0dsb2IgJiYgdHlwZW9mIHRoaXMuZ2xvYkZpbHRlciA9PT0gRlVOQ1RJT05fVFlQRSA/XG4gICAgICB0aGlzLmdsb2JGaWx0ZXIocmVzb2x2ZWRQYXRoKSA6IHRydWU7XG4gICAgcmV0dXJuIG1hdGNoZXNHbG9iICYmXG4gICAgICB0aGlzLmZzdy5faXNudElnbm9yZWQocmVzb2x2ZWRQYXRoLCBzdGF0cykgJiZcbiAgICAgIHRoaXMuZnN3Ll9oYXNSZWFkUGVybWlzc2lvbnMoc3RhdHMpO1xuICB9XG5cbiAgZ2V0RGlyUGFydHMocGF0aCkge1xuICAgIGlmICghdGhpcy5oYXNHbG9iKSByZXR1cm4gW107XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBjb25zdCBleHBhbmRlZFBhdGggPSBwYXRoLmluY2x1ZGVzKEJSQUNFX1NUQVJUKSA/IGJyYWNlcy5leHBhbmQocGF0aCkgOiBbcGF0aF07XG4gICAgZXhwYW5kZWRQYXRoLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIHBhcnRzLnB1c2goc3lzUGF0aC5yZWxhdGl2ZSh0aGlzLndhdGNoUGF0aCwgcGF0aCkuc3BsaXQoU0xBU0hfT1JfQkFDS19TTEFTSF9SRSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0cztcbiAgfVxuXG4gIGZpbHRlckRpcihlbnRyeSkge1xuICAgIGlmICh0aGlzLmhhc0dsb2IpIHtcbiAgICAgIGNvbnN0IGVudHJ5UGFydHMgPSB0aGlzLmdldERpclBhcnRzKHRoaXMuY2hlY2tHbG9iU3ltbGluayhlbnRyeSkpO1xuICAgICAgbGV0IGdsb2JzdGFyID0gZmFsc2U7XG4gICAgICB0aGlzLnVubWF0Y2hlZEdsb2IgPSAhdGhpcy5kaXJQYXJ0cy5zb21lKChwYXJ0cykgPT4ge1xuICAgICAgICByZXR1cm4gcGFydHMuZXZlcnkoKHBhcnQsIGkpID0+IHtcbiAgICAgICAgICBpZiAocGFydCA9PT0gR0xPQlNUQVIpIGdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZ2xvYnN0YXIgfHwgIWVudHJ5UGFydHNbMF1baV0gfHwgYW55bWF0Y2gocGFydCwgZW50cnlQYXJ0c1swXVtpXSwgQU5ZTUFUQ0hfT1BUUyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy51bm1hdGNoZWRHbG9iICYmIHRoaXMuZnN3Ll9pc250SWdub3JlZCh0aGlzLmVudHJ5UGF0aChlbnRyeSksIGVudHJ5LnN0YXRzKTtcbiAgfVxufVxuXG4vKipcbiAqIFdhdGNoZXMgZmlsZXMgJiBkaXJlY3RvcmllcyBmb3IgY2hhbmdlcy4gRW1pdHRlZCBldmVudHM6XG4gKiBgYWRkYCwgYGFkZERpcmAsIGBjaGFuZ2VgLCBgdW5saW5rYCwgYHVubGlua0RpcmAsIGBhbGxgLCBgZXJyb3JgXG4gKlxuICogICAgIG5ldyBGU1dhdGNoZXIoKVxuICogICAgICAgLmFkZChkaXJlY3RvcmllcylcbiAqICAgICAgIC5vbignYWRkJywgcGF0aCA9PiBsb2coJ0ZpbGUnLCBwYXRoLCAnd2FzIGFkZGVkJykpXG4gKi9cbmNsYXNzIEZTV2F0Y2hlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4vLyBOb3QgaW5kZW50aW5nIG1ldGhvZHMgZm9yIGhpc3Rvcnkgc2FrZTsgZm9yIG5vdy5cbmNvbnN0cnVjdG9yKF9vcHRzKSB7XG4gIHN1cGVyKCk7XG5cbiAgY29uc3Qgb3B0cyA9IHt9O1xuICBpZiAoX29wdHMpIE9iamVjdC5hc3NpZ24ob3B0cywgX29wdHMpOyAvLyBmb3IgZnJvemVuIG9iamVjdHNcblxuICAvKiogQHR5cGUge01hcDxTdHJpbmcsIERpckVudHJ5Pn0gKi9cbiAgdGhpcy5fd2F0Y2hlZCA9IG5ldyBNYXAoKTtcbiAgLyoqIEB0eXBlIHtNYXA8U3RyaW5nLCBBcnJheT59ICovXG4gIHRoaXMuX2Nsb3NlcnMgPSBuZXcgTWFwKCk7XG4gIC8qKiBAdHlwZSB7U2V0PFN0cmluZz59ICovXG4gIHRoaXMuX2lnbm9yZWRQYXRocyA9IG5ldyBTZXQoKTtcblxuICAvKiogQHR5cGUge01hcDxUaHJvdHRsZVR5cGUsIE1hcD59ICovXG4gIHRoaXMuX3Rocm90dGxlZCA9IG5ldyBNYXAoKTtcblxuICAvKiogQHR5cGUge01hcDxQYXRoLCBTdHJpbmd8Qm9vbGVhbj59ICovXG4gIHRoaXMuX3N5bWxpbmtQYXRocyA9IG5ldyBNYXAoKTtcblxuICB0aGlzLl9zdHJlYW1zID0gbmV3IFNldCgpO1xuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuXG4gIC8vIFNldCB1cCBkZWZhdWx0IG9wdGlvbnMuXG4gIGlmICh1bmRlZihvcHRzLCAncGVyc2lzdGVudCcpKSBvcHRzLnBlcnNpc3RlbnQgPSB0cnVlO1xuICBpZiAodW5kZWYob3B0cywgJ2lnbm9yZUluaXRpYWwnKSkgb3B0cy5pZ25vcmVJbml0aWFsID0gZmFsc2U7XG4gIGlmICh1bmRlZihvcHRzLCAnaWdub3JlUGVybWlzc2lvbkVycm9ycycpKSBvcHRzLmlnbm9yZVBlcm1pc3Npb25FcnJvcnMgPSBmYWxzZTtcbiAgaWYgKHVuZGVmKG9wdHMsICdpbnRlcnZhbCcpKSBvcHRzLmludGVydmFsID0gMTAwO1xuICBpZiAodW5kZWYob3B0cywgJ2JpbmFyeUludGVydmFsJykpIG9wdHMuYmluYXJ5SW50ZXJ2YWwgPSAzMDA7XG4gIGlmICh1bmRlZihvcHRzLCAnZGlzYWJsZUdsb2JiaW5nJykpIG9wdHMuZGlzYWJsZUdsb2JiaW5nID0gZmFsc2U7XG4gIG9wdHMuZW5hYmxlQmluYXJ5SW50ZXJ2YWwgPSBvcHRzLmJpbmFyeUludGVydmFsICE9PSBvcHRzLmludGVydmFsO1xuXG4gIC8vIEVuYWJsZSBmc2V2ZW50cyBvbiBPUyBYIHdoZW4gcG9sbGluZyBpc24ndCBleHBsaWNpdGx5IGVuYWJsZWQuXG4gIGlmICh1bmRlZihvcHRzLCAndXNlRnNFdmVudHMnKSkgb3B0cy51c2VGc0V2ZW50cyA9ICFvcHRzLnVzZVBvbGxpbmc7XG5cbiAgLy8gSWYgd2UgY2FuJ3QgdXNlIGZzZXZlbnRzLCBlbnN1cmUgdGhlIG9wdGlvbnMgcmVmbGVjdCBpdCdzIGRpc2FibGVkLlxuICBjb25zdCBjYW5Vc2VGc0V2ZW50cyA9IEZzRXZlbnRzSGFuZGxlci5jYW5Vc2UoKTtcbiAgaWYgKCFjYW5Vc2VGc0V2ZW50cykgb3B0cy51c2VGc0V2ZW50cyA9IGZhbHNlO1xuXG4gIC8vIFVzZSBwb2xsaW5nIG9uIE1hYyBpZiBub3QgdXNpbmcgZnNldmVudHMuXG4gIC8vIE90aGVyIHBsYXRmb3JtcyB1c2Ugbm9uLXBvbGxpbmcgZnNfd2F0Y2guXG4gIGlmICh1bmRlZihvcHRzLCAndXNlUG9sbGluZycpICYmICFvcHRzLnVzZUZzRXZlbnRzKSB7XG4gICAgb3B0cy51c2VQb2xsaW5nID0gaXNNYWNvcztcbiAgfVxuXG4gIC8vIEFsd2F5cyBkZWZhdWx0IHRvIHBvbGxpbmcgb24gSUJNIGkgYmVjYXVzZSBmcy53YXRjaCgpIGlzIG5vdCBhdmFpbGFibGUgb24gSUJNIGkuXG4gIGlmKGlzSUJNaSkge1xuICAgIG9wdHMudXNlUG9sbGluZyA9IHRydWU7XG4gIH1cblxuICAvLyBHbG9iYWwgb3ZlcnJpZGUgKHVzZWZ1bCBmb3IgZW5kLWRldmVsb3BlcnMgdGhhdCBuZWVkIHRvIGZvcmNlIHBvbGxpbmcgZm9yIGFsbFxuICAvLyBpbnN0YW5jZXMgb2YgY2hva2lkYXIsIHJlZ2FyZGxlc3Mgb2YgdXNhZ2UvZGVwZW5kZW5jeSBkZXB0aClcbiAgY29uc3QgZW52UG9sbCA9IHByb2Nlc3MuZW52LkNIT0tJREFSX1VTRVBPTExJTkc7XG4gIGlmIChlbnZQb2xsICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBlbnZMb3dlciA9IGVudlBvbGwudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChlbnZMb3dlciA9PT0gJ2ZhbHNlJyB8fCBlbnZMb3dlciA9PT0gJzAnKSB7XG4gICAgICBvcHRzLnVzZVBvbGxpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGVudkxvd2VyID09PSAndHJ1ZScgfHwgZW52TG93ZXIgPT09ICcxJykge1xuICAgICAgb3B0cy51c2VQb2xsaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy51c2VQb2xsaW5nID0gISFlbnZMb3dlcjtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW52SW50ZXJ2YWwgPSBwcm9jZXNzLmVudi5DSE9LSURBUl9JTlRFUlZBTDtcbiAgaWYgKGVudkludGVydmFsKSB7XG4gICAgb3B0cy5pbnRlcnZhbCA9IE51bWJlci5wYXJzZUludChlbnZJbnRlcnZhbCwgMTApO1xuICB9XG5cbiAgLy8gRWRpdG9yIGF0b21pYyB3cml0ZSBub3JtYWxpemF0aW9uIGVuYWJsZWQgYnkgZGVmYXVsdCB3aXRoIGZzLndhdGNoXG4gIGlmICh1bmRlZihvcHRzLCAnYXRvbWljJykpIG9wdHMuYXRvbWljID0gIW9wdHMudXNlUG9sbGluZyAmJiAhb3B0cy51c2VGc0V2ZW50cztcbiAgaWYgKG9wdHMuYXRvbWljKSB0aGlzLl9wZW5kaW5nVW5saW5rcyA9IG5ldyBNYXAoKTtcblxuICBpZiAodW5kZWYob3B0cywgJ2ZvbGxvd1N5bWxpbmtzJykpIG9wdHMuZm9sbG93U3ltbGlua3MgPSB0cnVlO1xuXG4gIGlmICh1bmRlZihvcHRzLCAnYXdhaXRXcml0ZUZpbmlzaCcpKSBvcHRzLmF3YWl0V3JpdGVGaW5pc2ggPSBmYWxzZTtcbiAgaWYgKG9wdHMuYXdhaXRXcml0ZUZpbmlzaCA9PT0gdHJ1ZSkgb3B0cy5hd2FpdFdyaXRlRmluaXNoID0ge307XG4gIGNvbnN0IGF3ZiA9IG9wdHMuYXdhaXRXcml0ZUZpbmlzaDtcbiAgaWYgKGF3Zikge1xuICAgIGlmICghYXdmLnN0YWJpbGl0eVRocmVzaG9sZCkgYXdmLnN0YWJpbGl0eVRocmVzaG9sZCA9IDIwMDA7XG4gICAgaWYgKCFhd2YucG9sbEludGVydmFsKSBhd2YucG9sbEludGVydmFsID0gMTAwO1xuICAgIHRoaXMuX3BlbmRpbmdXcml0ZXMgPSBuZXcgTWFwKCk7XG4gIH1cbiAgaWYgKG9wdHMuaWdub3JlZCkgb3B0cy5pZ25vcmVkID0gYXJyaWZ5KG9wdHMuaWdub3JlZCk7XG5cbiAgbGV0IHJlYWR5Q2FsbHMgPSAwO1xuICB0aGlzLl9lbWl0UmVhZHkgPSAoKSA9PiB7XG4gICAgcmVhZHlDYWxscysrO1xuICAgIGlmIChyZWFkeUNhbGxzID49IHRoaXMuX3JlYWR5Q291bnQpIHtcbiAgICAgIHRoaXMuX2VtaXRSZWFkeSA9IEVNUFRZX0ZOO1xuICAgICAgdGhpcy5fcmVhZHlFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIC8vIHVzZSBwcm9jZXNzLm5leHRUaWNrIHRvIGFsbG93IHRpbWUgZm9yIGxpc3RlbmVyIHRvIGJlIGJvdW5kXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHRoaXMuZW1pdChFVl9SRUFEWSkpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5fZW1pdFJhdyA9ICguLi5hcmdzKSA9PiB0aGlzLmVtaXQoRVZfUkFXLCAuLi5hcmdzKTtcbiAgdGhpcy5fcmVhZHlFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMub3B0aW9ucyA9IG9wdHM7XG5cbiAgLy8gSW5pdGlhbGl6ZSB3aXRoIHByb3BlciB3YXRjaGVyLlxuICBpZiAob3B0cy51c2VGc0V2ZW50cykge1xuICAgIHRoaXMuX2ZzRXZlbnRzSGFuZGxlciA9IG5ldyBGc0V2ZW50c0hhbmRsZXIodGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbm9kZUZzSGFuZGxlciA9IG5ldyBOb2RlRnNIYW5kbGVyKHRoaXMpO1xuICB9XG5cbiAgLy8gWW91XHUyMDE5cmUgZnJvemVuIHdoZW4geW91ciBoZWFydFx1MjAxOXMgbm90IG9wZW4uXG4gIE9iamVjdC5mcmVlemUob3B0cyk7XG59XG5cbi8vIFB1YmxpYyBtZXRob2RzXG5cbi8qKlxuICogQWRkcyBwYXRocyB0byBiZSB3YXRjaGVkIG9uIGFuIGV4aXN0aW5nIEZTV2F0Y2hlciBpbnN0YW5jZVxuICogQHBhcmFtIHtQYXRofEFycmF5PFBhdGg+fSBwYXRoc19cbiAqIEBwYXJhbSB7U3RyaW5nPX0gX29yaWdBZGQgcHJpdmF0ZTsgZm9yIGhhbmRsaW5nIG5vbi1leGlzdGVudCBwYXRocyB0byBiZSB3YXRjaGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW49fSBfaW50ZXJuYWwgcHJpdmF0ZTsgaW5kaWNhdGVzIGEgbm9uLXVzZXIgYWRkXG4gKiBAcmV0dXJucyB7RlNXYXRjaGVyfSBmb3IgY2hhaW5pbmdcbiAqL1xuYWRkKHBhdGhzXywgX29yaWdBZGQsIF9pbnRlcm5hbCkge1xuICBjb25zdCB7Y3dkLCBkaXNhYmxlR2xvYmJpbmd9ID0gdGhpcy5vcHRpb25zO1xuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICBsZXQgcGF0aHMgPSB1bmlmeVBhdGhzKHBhdGhzXyk7XG4gIGlmIChjd2QpIHtcbiAgICBwYXRocyA9IHBhdGhzLm1hcCgocGF0aCkgPT4ge1xuICAgICAgY29uc3QgYWJzUGF0aCA9IGdldEFic29sdXRlUGF0aChwYXRoLCBjd2QpO1xuXG4gICAgICAvLyBDaGVjayBgcGF0aGAgaW5zdGVhZCBvZiBgYWJzUGF0aGAgYmVjYXVzZSB0aGUgY3dkIHBvcnRpb24gY2FuJ3QgYmUgYSBnbG9iXG4gICAgICBpZiAoZGlzYWJsZUdsb2JiaW5nIHx8ICFpc0dsb2IocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGFic1BhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplUGF0aChhYnNQYXRoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHNldCBhc2lkZSBuZWdhdGVkIGdsb2Igc3RyaW5nc1xuICBwYXRocyA9IHBhdGhzLmZpbHRlcigocGF0aCkgPT4ge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoQkFORykpIHtcbiAgICAgIHRoaXMuX2lnbm9yZWRQYXRocy5hZGQocGF0aC5zbGljZSgxKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaWYgYSBwYXRoIGlzIGJlaW5nIGFkZGVkIHRoYXQgd2FzIHByZXZpb3VzbHkgaWdub3JlZCwgc3RvcCBpZ25vcmluZyBpdFxuICAgIHRoaXMuX2lnbm9yZWRQYXRocy5kZWxldGUocGF0aCk7XG4gICAgdGhpcy5faWdub3JlZFBhdGhzLmRlbGV0ZShwYXRoICsgU0xBU0hfR0xPQlNUQVIpO1xuXG4gICAgLy8gcmVzZXQgdGhlIGNhY2hlZCB1c2VySWdub3JlZCBhbnltYXRjaCBmblxuICAgIC8vIHRvIG1ha2UgaWdub3JlZFBhdGhzIGNoYW5nZXMgZWZmZWN0aXZlXG4gICAgdGhpcy5fdXNlcklnbm9yZWQgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy51c2VGc0V2ZW50cyAmJiB0aGlzLl9mc0V2ZW50c0hhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX3JlYWR5Q291bnQpIHRoaXMuX3JlYWR5Q291bnQgPSBwYXRocy5sZW5ndGg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJzaXN0ZW50KSB0aGlzLl9yZWFkeUNvdW50ICs9IHBhdGhzLmxlbmd0aDtcbiAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB0aGlzLl9mc0V2ZW50c0hhbmRsZXIuX2FkZFRvRnNFdmVudHMocGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIGlmICghdGhpcy5fcmVhZHlDb3VudCkgdGhpcy5fcmVhZHlDb3VudCA9IDA7XG4gICAgdGhpcy5fcmVhZHlDb3VudCArPSBwYXRocy5sZW5ndGg7XG4gICAgUHJvbWlzZS5hbGwoXG4gICAgICBwYXRocy5tYXAoYXN5bmMgcGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX25vZGVGc0hhbmRsZXIuX2FkZFRvTm9kZUZzKHBhdGgsICFfaW50ZXJuYWwsIDAsIDAsIF9vcmlnQWRkKTtcbiAgICAgICAgaWYgKHJlcykgdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KVxuICAgICkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuO1xuICAgICAgcmVzdWx0cy5maWx0ZXIoaXRlbSA9PiBpdGVtKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICB0aGlzLmFkZChzeXNQYXRoLmRpcm5hbWUoaXRlbSksIHN5c1BhdGguYmFzZW5hbWUoX29yaWdBZGQgfHwgaXRlbSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDbG9zZSB3YXRjaGVycyBvciBzdGFydCBpZ25vcmluZyBldmVudHMgZnJvbSBzcGVjaWZpZWQgcGF0aHMuXG4gKiBAcGFyYW0ge1BhdGh8QXJyYXk8UGF0aD59IHBhdGhzXyAtIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzLCBmaWxlL2RpcmVjdG9yeSBwYXRocyBhbmQvb3IgZ2xvYnNcbiAqIEByZXR1cm5zIHtGU1dhdGNoZXJ9IGZvciBjaGFpbmluZ1xuKi9cbnVud2F0Y2gocGF0aHNfKSB7XG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuIHRoaXM7XG4gIGNvbnN0IHBhdGhzID0gdW5pZnlQYXRocyhwYXRoc18pO1xuICBjb25zdCB7Y3dkfSA9IHRoaXMub3B0aW9ucztcblxuICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgLy8gY29udmVydCB0byBhYnNvbHV0ZSBwYXRoIHVubGVzcyByZWxhdGl2ZSBwYXRoIGFscmVhZHkgbWF0Y2hlc1xuICAgIGlmICghc3lzUGF0aC5pc0Fic29sdXRlKHBhdGgpICYmICF0aGlzLl9jbG9zZXJzLmhhcyhwYXRoKSkge1xuICAgICAgaWYgKGN3ZCkgcGF0aCA9IHN5c1BhdGguam9pbihjd2QsIHBhdGgpO1xuICAgICAgcGF0aCA9IHN5c1BhdGgucmVzb2x2ZShwYXRoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jbG9zZVBhdGgocGF0aCk7XG5cbiAgICB0aGlzLl9pZ25vcmVkUGF0aHMuYWRkKHBhdGgpO1xuICAgIGlmICh0aGlzLl93YXRjaGVkLmhhcyhwYXRoKSkge1xuICAgICAgdGhpcy5faWdub3JlZFBhdGhzLmFkZChwYXRoICsgU0xBU0hfR0xPQlNUQVIpO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IHRoZSBjYWNoZWQgdXNlcklnbm9yZWQgYW55bWF0Y2ggZm5cbiAgICAvLyB0byBtYWtlIGlnbm9yZWRQYXRocyBjaGFuZ2VzIGVmZmVjdGl2ZVxuICAgIHRoaXMuX3VzZXJJZ25vcmVkID0gdW5kZWZpbmVkO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDbG9zZSB3YXRjaGVycyBhbmQgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB3YXRjaGVkIHBhdGhzLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59LlxuKi9cbmNsb3NlKCkge1xuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiB0aGlzLl9jbG9zZVByb21pc2U7XG4gIHRoaXMuY2xvc2VkID0gdHJ1ZTtcblxuICAvLyBNZW1vcnkgbWFuYWdlbWVudC5cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgY29uc3QgY2xvc2VycyA9IFtdO1xuICB0aGlzLl9jbG9zZXJzLmZvckVhY2goY2xvc2VyTGlzdCA9PiBjbG9zZXJMaXN0LmZvckVhY2goY2xvc2VyID0+IHtcbiAgICBjb25zdCBwcm9taXNlID0gY2xvc2VyKCk7XG4gICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSBjbG9zZXJzLnB1c2gocHJvbWlzZSk7XG4gIH0pKTtcbiAgdGhpcy5fc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiBzdHJlYW0uZGVzdHJveSgpKTtcbiAgdGhpcy5fdXNlcklnbm9yZWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3JlYWR5Q291bnQgPSAwO1xuICB0aGlzLl9yZWFkeUVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5fd2F0Y2hlZC5mb3JFYWNoKGRpcmVudCA9PiBkaXJlbnQuZGlzcG9zZSgpKTtcbiAgWydjbG9zZXJzJywgJ3dhdGNoZWQnLCAnc3RyZWFtcycsICdzeW1saW5rUGF0aHMnLCAndGhyb3R0bGVkJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgIHRoaXNbYF8ke2tleX1gXS5jbGVhcigpO1xuICB9KTtcblxuICB0aGlzLl9jbG9zZVByb21pc2UgPSBjbG9zZXJzLmxlbmd0aCA/IFByb21pc2UuYWxsKGNsb3NlcnMpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICByZXR1cm4gdGhpcy5fY2xvc2VQcm9taXNlO1xufVxuXG4vKipcbiAqIEV4cG9zZSBsaXN0IG9mIHdhdGNoZWQgcGF0aHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGZvciBjaGFpbmluZ1xuKi9cbmdldFdhdGNoZWQoKSB7XG4gIGNvbnN0IHdhdGNoTGlzdCA9IHt9O1xuICB0aGlzLl93YXRjaGVkLmZvckVhY2goKGVudHJ5LCBkaXIpID0+IHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLm9wdGlvbnMuY3dkID8gc3lzUGF0aC5yZWxhdGl2ZSh0aGlzLm9wdGlvbnMuY3dkLCBkaXIpIDogZGlyO1xuICAgIHdhdGNoTGlzdFtrZXkgfHwgT05FX0RPVF0gPSBlbnRyeS5nZXRDaGlsZHJlbigpLnNvcnQoKTtcbiAgfSk7XG4gIHJldHVybiB3YXRjaExpc3Q7XG59XG5cbmVtaXRXaXRoQWxsKGV2ZW50LCBhcmdzKSB7XG4gIHRoaXMuZW1pdCguLi5hcmdzKTtcbiAgaWYgKGV2ZW50ICE9PSBFVl9FUlJPUikgdGhpcy5lbWl0KEVWX0FMTCwgLi4uYXJncyk7XG59XG5cbi8vIENvbW1vbiBoZWxwZXJzXG4vLyAtLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbmQgZW1pdCBldmVudHMuXG4gKiBDYWxsaW5nIF9lbWl0IERPRVMgTk9UIE1FQU4gZW1pdCgpIHdvdWxkIGJlIGNhbGxlZCFcbiAqIEBwYXJhbSB7RXZlbnROYW1lfSBldmVudCBUeXBlIG9mIGV2ZW50XG4gKiBAcGFyYW0ge1BhdGh9IHBhdGggRmlsZSBvciBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHsqPX0gdmFsMSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHdpdGggZXZlbnRcbiAqIEBwYXJhbSB7Kj19IHZhbDJcbiAqIEBwYXJhbSB7Kj19IHZhbDNcbiAqIEByZXR1cm5zIHRoZSBlcnJvciBpZiBkZWZpbmVkLCBvdGhlcndpc2UgdGhlIHZhbHVlIG9mIHRoZSBGU1dhdGNoZXIgaW5zdGFuY2UncyBgY2xvc2VkYCBmbGFnXG4gKi9cbmFzeW5jIF9lbWl0KGV2ZW50LCBwYXRoLCB2YWwxLCB2YWwyLCB2YWwzKSB7XG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuO1xuXG4gIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gIGlmIChpc1dpbmRvd3MpIHBhdGggPSBzeXNQYXRoLm5vcm1hbGl6ZShwYXRoKTtcbiAgaWYgKG9wdHMuY3dkKSBwYXRoID0gc3lzUGF0aC5yZWxhdGl2ZShvcHRzLmN3ZCwgcGF0aCk7XG4gIC8qKiBAdHlwZSBBcnJheTxhbnk+ICovXG4gIGNvbnN0IGFyZ3MgPSBbZXZlbnQsIHBhdGhdO1xuICBpZiAodmFsMyAhPT0gdW5kZWZpbmVkKSBhcmdzLnB1c2godmFsMSwgdmFsMiwgdmFsMyk7XG4gIGVsc2UgaWYgKHZhbDIgIT09IHVuZGVmaW5lZCkgYXJncy5wdXNoKHZhbDEsIHZhbDIpO1xuICBlbHNlIGlmICh2YWwxICE9PSB1bmRlZmluZWQpIGFyZ3MucHVzaCh2YWwxKTtcblxuICBjb25zdCBhd2YgPSBvcHRzLmF3YWl0V3JpdGVGaW5pc2g7XG4gIGxldCBwdztcbiAgaWYgKGF3ZiAmJiAocHcgPSB0aGlzLl9wZW5kaW5nV3JpdGVzLmdldChwYXRoKSkpIHtcbiAgICBwdy5sYXN0Q2hhbmdlID0gbmV3IERhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChvcHRzLmF0b21pYykge1xuICAgIGlmIChldmVudCA9PT0gRVZfVU5MSU5LKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nVW5saW5rcy5zZXQocGF0aCwgYXJncyk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1VubGlua3MuZm9yRWFjaCgoZW50cnksIHBhdGgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoLi4uZW50cnkpO1xuICAgICAgICAgIHRoaXMuZW1pdChFVl9BTEwsIC4uLmVudHJ5KTtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nVW5saW5rcy5kZWxldGUocGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgdHlwZW9mIG9wdHMuYXRvbWljID09PSAnbnVtYmVyJyA/IG9wdHMuYXRvbWljIDogMTAwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgPT09IEVWX0FERCAmJiB0aGlzLl9wZW5kaW5nVW5saW5rcy5oYXMocGF0aCkpIHtcbiAgICAgIGV2ZW50ID0gYXJnc1swXSA9IEVWX0NIQU5HRTtcbiAgICAgIHRoaXMuX3BlbmRpbmdVbmxpbmtzLmRlbGV0ZShwYXRoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXdmICYmIChldmVudCA9PT0gRVZfQUREIHx8IGV2ZW50ID09PSBFVl9DSEFOR0UpICYmIHRoaXMuX3JlYWR5RW1pdHRlZCkge1xuICAgIGNvbnN0IGF3ZkVtaXQgPSAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBldmVudCA9IGFyZ3NbMF0gPSBFVl9FUlJPUjtcbiAgICAgICAgYXJnc1sxXSA9IGVycjtcbiAgICAgICAgdGhpcy5lbWl0V2l0aEFsbChldmVudCwgYXJncyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRzKSB7XG4gICAgICAgIC8vIGlmIHN0YXRzIGRvZXNuJ3QgZXhpc3QgdGhlIGZpbGUgbXVzdCBoYXZlIGJlZW4gZGVsZXRlZFxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgYXJnc1syXSA9IHN0YXRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZ3MucHVzaChzdGF0cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0V2l0aEFsbChldmVudCwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX2F3YWl0V3JpdGVGaW5pc2gocGF0aCwgYXdmLnN0YWJpbGl0eVRocmVzaG9sZCwgZXZlbnQsIGF3ZkVtaXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKGV2ZW50ID09PSBFVl9DSEFOR0UpIHtcbiAgICBjb25zdCBpc1Rocm90dGxlZCA9ICF0aGlzLl90aHJvdHRsZShFVl9DSEFOR0UsIHBhdGgsIDUwKTtcbiAgICBpZiAoaXNUaHJvdHRsZWQpIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKG9wdHMuYWx3YXlzU3RhdCAmJiB2YWwxID09PSB1bmRlZmluZWQgJiZcbiAgICAoZXZlbnQgPT09IEVWX0FERCB8fCBldmVudCA9PT0gRVZfQUREX0RJUiB8fCBldmVudCA9PT0gRVZfQ0hBTkdFKVxuICApIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IG9wdHMuY3dkID8gc3lzUGF0aC5qb2luKG9wdHMuY3dkLCBwYXRoKSA6IHBhdGg7XG4gICAgbGV0IHN0YXRzO1xuICAgIHRyeSB7XG4gICAgICBzdGF0cyA9IGF3YWl0IHN0YXQoZnVsbFBhdGgpO1xuICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAvLyBTdXBwcmVzcyBldmVudCB3aGVuIGZzX3N0YXQgZmFpbHMsIHRvIGF2b2lkIHNlbmRpbmcgdW5kZWZpbmVkICdzdGF0J1xuICAgIGlmICghc3RhdHMgfHwgdGhpcy5jbG9zZWQpIHJldHVybjtcbiAgICBhcmdzLnB1c2goc3RhdHMpO1xuICB9XG4gIHRoaXMuZW1pdFdpdGhBbGwoZXZlbnQsIGFyZ3MpO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENvbW1vbiBoYW5kbGVyIGZvciBlcnJvcnNcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKiBAcmV0dXJucyB7RXJyb3J8Qm9vbGVhbn0gVGhlIGVycm9yIGlmIGRlZmluZWQsIG90aGVyd2lzZSB0aGUgdmFsdWUgb2YgdGhlIEZTV2F0Y2hlciBpbnN0YW5jZSdzIGBjbG9zZWRgIGZsYWdcbiAqL1xuX2hhbmRsZUVycm9yKGVycm9yKSB7XG4gIGNvbnN0IGNvZGUgPSBlcnJvciAmJiBlcnJvci5jb2RlO1xuICBpZiAoZXJyb3IgJiYgY29kZSAhPT0gJ0VOT0VOVCcgJiYgY29kZSAhPT0gJ0VOT1RESVInICYmXG4gICAgKCF0aGlzLm9wdGlvbnMuaWdub3JlUGVybWlzc2lvbkVycm9ycyB8fCAoY29kZSAhPT0gJ0VQRVJNJyAmJiBjb2RlICE9PSAnRUFDQ0VTJykpXG4gICkge1xuICAgIHRoaXMuZW1pdChFVl9FUlJPUiwgZXJyb3IpO1xuICB9XG4gIHJldHVybiBlcnJvciB8fCB0aGlzLmNsb3NlZDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXRpbGl0eSBmb3IgdGhyb3R0bGluZ1xuICogQHBhcmFtIHtUaHJvdHRsZVR5cGV9IGFjdGlvblR5cGUgdHlwZSBiZWluZyB0aHJvdHRsZWRcbiAqIEBwYXJhbSB7UGF0aH0gcGF0aCBiZWluZyBhY3RlZCB1cG9uXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCBkdXJhdGlvbiBvZiB0aW1lIHRvIHN1cHByZXNzIGR1cGxpY2F0ZSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fGZhbHNlfSB0cmFja2luZyBvYmplY3Qgb3IgZmFsc2UgaWYgYWN0aW9uIHNob3VsZCBiZSBzdXBwcmVzc2VkXG4gKi9cbl90aHJvdHRsZShhY3Rpb25UeXBlLCBwYXRoLCB0aW1lb3V0KSB7XG4gIGlmICghdGhpcy5fdGhyb3R0bGVkLmhhcyhhY3Rpb25UeXBlKSkge1xuICAgIHRoaXMuX3Rocm90dGxlZC5zZXQoYWN0aW9uVHlwZSwgbmV3IE1hcCgpKTtcbiAgfVxuXG4gIC8qKiBAdHlwZSB7TWFwPFBhdGgsIE9iamVjdD59ICovXG4gIGNvbnN0IGFjdGlvbiA9IHRoaXMuX3Rocm90dGxlZC5nZXQoYWN0aW9uVHlwZSk7XG4gIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICBjb25zdCBhY3Rpb25QYXRoID0gYWN0aW9uLmdldChwYXRoKTtcblxuICBpZiAoYWN0aW9uUGF0aCkge1xuICAgIGFjdGlvblBhdGguY291bnQrKztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsZXQgdGltZW91dE9iamVjdDtcbiAgY29uc3QgY2xlYXIgPSAoKSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGFjdGlvbi5nZXQocGF0aCk7XG4gICAgY29uc3QgY291bnQgPSBpdGVtID8gaXRlbS5jb3VudCA6IDA7XG4gICAgYWN0aW9uLmRlbGV0ZShwYXRoKTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dE9iamVjdCk7XG4gICAgaWYgKGl0ZW0pIGNsZWFyVGltZW91dChpdGVtLnRpbWVvdXRPYmplY3QpO1xuICAgIHJldHVybiBjb3VudDtcbiAgfTtcbiAgdGltZW91dE9iamVjdCA9IHNldFRpbWVvdXQoY2xlYXIsIHRpbWVvdXQpO1xuICBjb25zdCB0aHIgPSB7dGltZW91dE9iamVjdCwgY2xlYXIsIGNvdW50OiAwfTtcbiAgYWN0aW9uLnNldChwYXRoLCB0aHIpO1xuICByZXR1cm4gdGhyO1xufVxuXG5faW5jclJlYWR5Q291bnQoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkeUNvdW50Kys7XG59XG5cbi8qKlxuICogQXdhaXRzIHdyaXRlIG9wZXJhdGlvbiB0byBmaW5pc2guXG4gKiBQb2xscyBhIG5ld2x5IGNyZWF0ZWQgZmlsZSBmb3Igc2l6ZSB2YXJpYXRpb25zLiBXaGVuIGZpbGVzIHNpemUgZG9lcyBub3QgY2hhbmdlIGZvciAndGhyZXNob2xkJyBtaWxsaXNlY29uZHMgY2FsbHMgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1BhdGh9IHBhdGggYmVpbmcgYWN0ZWQgdXBvblxuICogQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZCBUaW1lIGluIG1pbGxpc2Vjb25kcyBhIGZpbGUgc2l6ZSBtdXN0IGJlIGZpeGVkIGJlZm9yZSBhY2tub3dsZWRnaW5nIHdyaXRlIE9QIGlzIGZpbmlzaGVkXG4gKiBAcGFyYW0ge0V2ZW50TmFtZX0gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGF3ZkVtaXQgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gcmVhZHkgZm9yIGV2ZW50IHRvIGJlIGVtaXR0ZWQuXG4gKi9cbl9hd2FpdFdyaXRlRmluaXNoKHBhdGgsIHRocmVzaG9sZCwgZXZlbnQsIGF3ZkVtaXQpIHtcbiAgbGV0IHRpbWVvdXRIYW5kbGVyO1xuXG4gIGxldCBmdWxsUGF0aCA9IHBhdGg7XG4gIGlmICh0aGlzLm9wdGlvbnMuY3dkICYmICFzeXNQYXRoLmlzQWJzb2x1dGUocGF0aCkpIHtcbiAgICBmdWxsUGF0aCA9IHN5c1BhdGguam9pbih0aGlzLm9wdGlvbnMuY3dkLCBwYXRoKTtcbiAgfVxuXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG5cbiAgY29uc3QgYXdhaXRXcml0ZUZpbmlzaCA9IChwcmV2U3RhdCkgPT4ge1xuICAgIGZzLnN0YXQoZnVsbFBhdGgsIChlcnIsIGN1clN0YXQpID0+IHtcbiAgICAgIGlmIChlcnIgfHwgIXRoaXMuX3BlbmRpbmdXcml0ZXMuaGFzKHBhdGgpKSB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFTk9FTlQnKSBhd2ZFbWl0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm93ID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXG4gICAgICBpZiAocHJldlN0YXQgJiYgY3VyU3RhdC5zaXplICE9PSBwcmV2U3RhdC5zaXplKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdXcml0ZXMuZ2V0KHBhdGgpLmxhc3RDaGFuZ2UgPSBub3c7XG4gICAgICB9XG4gICAgICBjb25zdCBwdyA9IHRoaXMuX3BlbmRpbmdXcml0ZXMuZ2V0KHBhdGgpO1xuICAgICAgY29uc3QgZGYgPSBub3cgLSBwdy5sYXN0Q2hhbmdlO1xuXG4gICAgICBpZiAoZGYgPj0gdGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdXcml0ZXMuZGVsZXRlKHBhdGgpO1xuICAgICAgICBhd2ZFbWl0KHVuZGVmaW5lZCwgY3VyU3RhdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0SGFuZGxlciA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgYXdhaXRXcml0ZUZpbmlzaCxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYXdhaXRXcml0ZUZpbmlzaC5wb2xsSW50ZXJ2YWwsXG4gICAgICAgICAgY3VyU3RhdFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGlmICghdGhpcy5fcGVuZGluZ1dyaXRlcy5oYXMocGF0aCkpIHtcbiAgICB0aGlzLl9wZW5kaW5nV3JpdGVzLnNldChwYXRoLCB7XG4gICAgICBsYXN0Q2hhbmdlOiBub3csXG4gICAgICBjYW5jZWxXYWl0OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdXcml0ZXMuZGVsZXRlKHBhdGgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGltZW91dEhhbmRsZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgYXdhaXRXcml0ZUZpbmlzaCxcbiAgICAgIHRoaXMub3B0aW9ucy5hd2FpdFdyaXRlRmluaXNoLnBvbGxJbnRlcnZhbFxuICAgICk7XG4gIH1cbn1cblxuX2dldEdsb2JJZ25vcmVkKCkge1xuICByZXR1cm4gWy4uLnRoaXMuX2lnbm9yZWRQYXRocy52YWx1ZXMoKV07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHVzZXIgaGFzIGFza2VkIHRvIGlnbm9yZSB0aGlzIHBhdGguXG4gKiBAcGFyYW0ge1BhdGh9IHBhdGggZmlsZXBhdGggb3IgZGlyXG4gKiBAcGFyYW0ge2ZzLlN0YXRzPX0gc3RhdHMgcmVzdWx0IG9mIGZzLnN0YXRcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5faXNJZ25vcmVkKHBhdGgsIHN0YXRzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuYXRvbWljICYmIERPVF9SRS50ZXN0KHBhdGgpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCF0aGlzLl91c2VySWdub3JlZCkge1xuICAgIGNvbnN0IHtjd2R9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGlnbiA9IHRoaXMub3B0aW9ucy5pZ25vcmVkO1xuXG4gICAgY29uc3QgaWdub3JlZCA9IGlnbiAmJiBpZ24ubWFwKG5vcm1hbGl6ZUlnbm9yZWQoY3dkKSk7XG4gICAgY29uc3QgcGF0aHMgPSBhcnJpZnkoaWdub3JlZClcbiAgICAgIC5maWx0ZXIoKHBhdGgpID0+IHR5cGVvZiBwYXRoID09PSBTVFJJTkdfVFlQRSAmJiAhaXNHbG9iKHBhdGgpKVxuICAgICAgLm1hcCgocGF0aCkgPT4gcGF0aCArIFNMQVNIX0dMT0JTVEFSKTtcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5fZ2V0R2xvYklnbm9yZWQoKS5tYXAobm9ybWFsaXplSWdub3JlZChjd2QpKS5jb25jYXQoaWdub3JlZCwgcGF0aHMpO1xuICAgIHRoaXMuX3VzZXJJZ25vcmVkID0gYW55bWF0Y2gobGlzdCwgdW5kZWZpbmVkLCBBTllNQVRDSF9PUFRTKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl91c2VySWdub3JlZChbcGF0aCwgc3RhdHNdKTtcbn1cblxuX2lzbnRJZ25vcmVkKHBhdGgsIHN0YXQpIHtcbiAgcmV0dXJuICF0aGlzLl9pc0lnbm9yZWQocGF0aCwgc3RhdCk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBzZXQgb2YgY29tbW9uIGhlbHBlcnMgYW5kIHByb3BlcnRpZXMgcmVsYXRpbmcgdG8gc3ltbGluayBhbmQgZ2xvYiBoYW5kbGluZy5cbiAqIEBwYXJhbSB7UGF0aH0gcGF0aCBmaWxlLCBkaXJlY3RvcnksIG9yIGdsb2IgcGF0dGVybiBiZWluZyB3YXRjaGVkXG4gKiBAcGFyYW0ge051bWJlcj19IGRlcHRoIGF0IGFueSBkZXB0aCA+IDAsIHRoaXMgaXNuJ3QgYSBnbG9iXG4gKiBAcmV0dXJucyB7V2F0Y2hIZWxwZXJ9IG9iamVjdCBjb250YWluaW5nIGhlbHBlcnMgZm9yIHRoaXMgcGF0aFxuICovXG5fZ2V0V2F0Y2hIZWxwZXJzKHBhdGgsIGRlcHRoKSB7XG4gIGNvbnN0IHdhdGNoUGF0aCA9IGRlcHRoIHx8IHRoaXMub3B0aW9ucy5kaXNhYmxlR2xvYmJpbmcgfHwgIWlzR2xvYihwYXRoKSA/IHBhdGggOiBnbG9iUGFyZW50KHBhdGgpO1xuICBjb25zdCBmb2xsb3cgPSB0aGlzLm9wdGlvbnMuZm9sbG93U3ltbGlua3M7XG5cbiAgcmV0dXJuIG5ldyBXYXRjaEhlbHBlcihwYXRoLCB3YXRjaFBhdGgsIGZvbGxvdywgdGhpcyk7XG59XG5cbi8vIERpcmVjdG9yeSBoZWxwZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFByb3ZpZGVzIGRpcmVjdG9yeSB0cmFja2luZyBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0b3J5IHBhdGggb2YgdGhlIGRpcmVjdG9yeVxuICogQHJldHVybnMge0RpckVudHJ5fSB0aGUgZGlyZWN0b3J5J3MgdHJhY2tpbmcgb2JqZWN0XG4gKi9cbl9nZXRXYXRjaGVkRGlyKGRpcmVjdG9yeSkge1xuICBpZiAoIXRoaXMuX2JvdW5kUmVtb3ZlKSB0aGlzLl9ib3VuZFJlbW92ZSA9IHRoaXMuX3JlbW92ZS5iaW5kKHRoaXMpO1xuICBjb25zdCBkaXIgPSBzeXNQYXRoLnJlc29sdmUoZGlyZWN0b3J5KTtcbiAgaWYgKCF0aGlzLl93YXRjaGVkLmhhcyhkaXIpKSB0aGlzLl93YXRjaGVkLnNldChkaXIsIG5ldyBEaXJFbnRyeShkaXIsIHRoaXMuX2JvdW5kUmVtb3ZlKSk7XG4gIHJldHVybiB0aGlzLl93YXRjaGVkLmdldChkaXIpO1xufVxuXG4vLyBGaWxlIGhlbHBlcnNcbi8vIC0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIENoZWNrIGZvciByZWFkIHBlcm1pc3Npb25zLlxuICogQmFzZWQgb24gdGhpcyBhbnN3ZXIgb24gU086IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTc4MTQwNC8xMzU4NDA1XG4gKiBAcGFyYW0ge2ZzLlN0YXRzfSBzdGF0cyAtIG9iamVjdCwgcmVzdWx0IG9mIGZzX3N0YXRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZmlsZSBjYW4gYmUgcmVhZFxuKi9cbl9oYXNSZWFkUGVybWlzc2lvbnMoc3RhdHMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVQZXJtaXNzaW9uRXJyb3JzKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBzdGF0cy5tb2RlIG1heSBiZSBiaWdpbnRcbiAgY29uc3QgbWQgPSBzdGF0cyAmJiBOdW1iZXIucGFyc2VJbnQoc3RhdHMubW9kZSwgMTApO1xuICBjb25zdCBzdCA9IG1kICYgMG83Nzc7XG4gIGNvbnN0IGl0ID0gTnVtYmVyLnBhcnNlSW50KHN0LnRvU3RyaW5nKDgpWzBdLCAxMCk7XG4gIHJldHVybiBCb29sZWFuKDQgJiBpdCk7XG59XG5cbi8qKlxuICogSGFuZGxlcyBlbWl0dGluZyB1bmxpbmsgZXZlbnRzIGZvclxuICogZmlsZXMgYW5kIGRpcmVjdG9yaWVzLCBhbmQgdmlhIHJlY3Vyc2lvbiwgZm9yXG4gKiBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgd2l0aGluIGRpcmVjdG9yaWVzIHRoYXQgYXJlIHVubGlua2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0b3J5IHdpdGhpbiB3aGljaCB0aGUgZm9sbG93aW5nIGl0ZW0gaXMgbG9jYXRlZFxuICogQHBhcmFtIHtTdHJpbmd9IGl0ZW0gICAgICBiYXNlIHBhdGggb2YgaXRlbS9kaXJlY3RvcnlcbiAqIEByZXR1cm5zIHt2b2lkfVxuKi9cbl9yZW1vdmUoZGlyZWN0b3J5LCBpdGVtLCBpc0RpcmVjdG9yeSkge1xuICAvLyBpZiB3aGF0IGlzIGJlaW5nIGRlbGV0ZWQgaXMgYSBkaXJlY3RvcnksIGdldCB0aGF0IGRpcmVjdG9yeSdzIHBhdGhzXG4gIC8vIGZvciByZWN1cnNpdmUgZGVsZXRpbmcgYW5kIGNsZWFuaW5nIG9mIHdhdGNoZWQgb2JqZWN0XG4gIC8vIGlmIGl0IGlzIG5vdCBhIGRpcmVjdG9yeSwgbmVzdGVkRGlyZWN0b3J5Q2hpbGRyZW4gd2lsbCBiZSBlbXB0eSBhcnJheVxuICBjb25zdCBwYXRoID0gc3lzUGF0aC5qb2luKGRpcmVjdG9yeSwgaXRlbSk7XG4gIGNvbnN0IGZ1bGxQYXRoID0gc3lzUGF0aC5yZXNvbHZlKHBhdGgpO1xuICBpc0RpcmVjdG9yeSA9IGlzRGlyZWN0b3J5ICE9IG51bGxcbiAgICA/IGlzRGlyZWN0b3J5XG4gICAgOiB0aGlzLl93YXRjaGVkLmhhcyhwYXRoKSB8fCB0aGlzLl93YXRjaGVkLmhhcyhmdWxsUGF0aCk7XG5cbiAgLy8gcHJldmVudCBkdXBsaWNhdGUgaGFuZGxpbmcgaW4gY2FzZSBvZiBhcnJpdmluZyBoZXJlIG5lYXJseSBzaW11bHRhbmVvdXNseVxuICAvLyB2aWEgbXVsdGlwbGUgcGF0aHMgKHN1Y2ggYXMgX2hhbmRsZUZpbGUgYW5kIF9oYW5kbGVEaXIpXG4gIGlmICghdGhpcy5fdGhyb3R0bGUoJ3JlbW92ZScsIHBhdGgsIDEwMCkpIHJldHVybjtcblxuICAvLyBpZiB0aGUgb25seSB3YXRjaGVkIGZpbGUgaXMgcmVtb3ZlZCwgd2F0Y2ggZm9yIGl0cyByZXR1cm5cbiAgaWYgKCFpc0RpcmVjdG9yeSAmJiAhdGhpcy5vcHRpb25zLnVzZUZzRXZlbnRzICYmIHRoaXMuX3dhdGNoZWQuc2l6ZSA9PT0gMSkge1xuICAgIHRoaXMuYWRkKGRpcmVjdG9yeSwgaXRlbSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IGVudHJ5IGluIHRoZSB3YXRjaGVkIG9iamVjdCBpbiBlaXRoZXIgY2FzZVxuICAvLyBzbyB3ZSBnb3QgdG8gZG8gdGhlIGRpcmVjdG9yeSBjaGVjayBiZWZvcmVoYW5kXG4gIGNvbnN0IHdwID0gdGhpcy5fZ2V0V2F0Y2hlZERpcihwYXRoKTtcbiAgY29uc3QgbmVzdGVkRGlyZWN0b3J5Q2hpbGRyZW4gPSB3cC5nZXRDaGlsZHJlbigpO1xuXG4gIC8vIFJlY3Vyc2l2ZWx5IHJlbW92ZSBjaGlsZHJlbiBkaXJlY3RvcmllcyAvIGZpbGVzLlxuICBuZXN0ZWREaXJlY3RvcnlDaGlsZHJlbi5mb3JFYWNoKG5lc3RlZCA9PiB0aGlzLl9yZW1vdmUocGF0aCwgbmVzdGVkKSk7XG5cbiAgLy8gQ2hlY2sgaWYgaXRlbSB3YXMgb24gdGhlIHdhdGNoZWQgbGlzdCBhbmQgcmVtb3ZlIGl0XG4gIGNvbnN0IHBhcmVudCA9IHRoaXMuX2dldFdhdGNoZWREaXIoZGlyZWN0b3J5KTtcbiAgY29uc3Qgd2FzVHJhY2tlZCA9IHBhcmVudC5oYXMoaXRlbSk7XG4gIHBhcmVudC5yZW1vdmUoaXRlbSk7XG5cbiAgLy8gRml4ZXMgaXNzdWUgIzEwNDIgLT4gUmVsYXRpdmUgcGF0aHMgd2VyZSBkZXRlY3RlZCBhbmQgYWRkZWQgYXMgc3ltbGlua3NcbiAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvY2hva2lkYXIvYmxvYi9lMTc1M2RkYmM5NTcxYmRjMzNiNGE0YWYxNzJkNTJjYjZlNjExYzEwL2xpYi9ub2RlZnMtaGFuZGxlci5qcyNMNjEyKSxcbiAgLy8gYnV0IG5ldmVyIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGluIGNhc2UgdGhlIHBhdGggd2FzIGRlbGV0ZWQuXG4gIC8vIFRoaXMgbGVhZHMgdG8gYW4gaW5jb3JyZWN0IHN0YXRlIGlmIHRoZSBwYXRoIHdhcyByZWNyZWF0ZWQ6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvY2hva2lkYXIvYmxvYi9lMTc1M2RkYmM5NTcxYmRjMzNiNGE0YWYxNzJkNTJjYjZlNjExYzEwL2xpYi9ub2RlZnMtaGFuZGxlci5qcyNMNTUzXG4gIGlmICh0aGlzLl9zeW1saW5rUGF0aHMuaGFzKGZ1bGxQYXRoKSkge1xuICAgIHRoaXMuX3N5bWxpbmtQYXRocy5kZWxldGUoZnVsbFBhdGgpO1xuICB9XG5cbiAgLy8gSWYgd2Ugd2FpdCBmb3IgdGhpcyBmaWxlIHRvIGJlIGZ1bGx5IHdyaXR0ZW4sIGNhbmNlbCB0aGUgd2FpdC5cbiAgbGV0IHJlbFBhdGggPSBwYXRoO1xuICBpZiAodGhpcy5vcHRpb25zLmN3ZCkgcmVsUGF0aCA9IHN5c1BhdGgucmVsYXRpdmUodGhpcy5vcHRpb25zLmN3ZCwgcGF0aCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuYXdhaXRXcml0ZUZpbmlzaCAmJiB0aGlzLl9wZW5kaW5nV3JpdGVzLmhhcyhyZWxQYXRoKSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fcGVuZGluZ1dyaXRlcy5nZXQocmVsUGF0aCkuY2FuY2VsV2FpdCgpO1xuICAgIGlmIChldmVudCA9PT0gRVZfQUREKSByZXR1cm47XG4gIH1cblxuICAvLyBUaGUgRW50cnkgd2lsbCBlaXRoZXIgYmUgYSBkaXJlY3RvcnkgdGhhdCBqdXN0IGdvdCByZW1vdmVkXG4gIC8vIG9yIGEgYm9ndXMgZW50cnkgdG8gYSBmaWxlLCBpbiBlaXRoZXIgY2FzZSB3ZSBoYXZlIHRvIHJlbW92ZSBpdFxuICB0aGlzLl93YXRjaGVkLmRlbGV0ZShwYXRoKTtcbiAgdGhpcy5fd2F0Y2hlZC5kZWxldGUoZnVsbFBhdGgpO1xuICBjb25zdCBldmVudE5hbWUgPSBpc0RpcmVjdG9yeSA/IEVWX1VOTElOS19ESVIgOiBFVl9VTkxJTks7XG4gIGlmICh3YXNUcmFja2VkICYmICF0aGlzLl9pc0lnbm9yZWQocGF0aCkpIHRoaXMuX2VtaXQoZXZlbnROYW1lLCBwYXRoKTtcblxuICAvLyBBdm9pZCBjb25mbGljdHMgaWYgd2UgbGF0ZXIgY3JlYXRlIGFub3RoZXIgZmlsZSB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgaWYgKCF0aGlzLm9wdGlvbnMudXNlRnNFdmVudHMpIHtcbiAgICB0aGlzLl9jbG9zZVBhdGgocGF0aCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbG9zZXMgYWxsIHdhdGNoZXJzIGZvciBhIHBhdGhcbiAqIEBwYXJhbSB7UGF0aH0gcGF0aFxuICovXG5fY2xvc2VQYXRoKHBhdGgpIHtcbiAgdGhpcy5fY2xvc2VGaWxlKHBhdGgpXG4gIGNvbnN0IGRpciA9IHN5c1BhdGguZGlybmFtZShwYXRoKTtcbiAgdGhpcy5fZ2V0V2F0Y2hlZERpcihkaXIpLnJlbW92ZShzeXNQYXRoLmJhc2VuYW1lKHBhdGgpKTtcbn1cblxuLyoqXG4gKiBDbG9zZXMgb25seSBmaWxlLXNwZWNpZmljIHdhdGNoZXJzXG4gKiBAcGFyYW0ge1BhdGh9IHBhdGhcbiAqL1xuX2Nsb3NlRmlsZShwYXRoKSB7XG4gIGNvbnN0IGNsb3NlcnMgPSB0aGlzLl9jbG9zZXJzLmdldChwYXRoKTtcbiAgaWYgKCFjbG9zZXJzKSByZXR1cm47XG4gIGNsb3NlcnMuZm9yRWFjaChjbG9zZXIgPT4gY2xvc2VyKCkpO1xuICB0aGlzLl9jbG9zZXJzLmRlbGV0ZShwYXRoKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtQYXRofSBwYXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9zZXJcbiAqL1xuX2FkZFBhdGhDbG9zZXIocGF0aCwgY2xvc2VyKSB7XG4gIGlmICghY2xvc2VyKSByZXR1cm47XG4gIGxldCBsaXN0ID0gdGhpcy5fY2xvc2Vycy5nZXQocGF0aCk7XG4gIGlmICghbGlzdCkge1xuICAgIGxpc3QgPSBbXTtcbiAgICB0aGlzLl9jbG9zZXJzLnNldChwYXRoLCBsaXN0KTtcbiAgfVxuICBsaXN0LnB1c2goY2xvc2VyKTtcbn1cblxuX3JlYWRkaXJwKHJvb3QsIG9wdHMpIHtcbiAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm47XG4gIGNvbnN0IG9wdGlvbnMgPSB7dHlwZTogRVZfQUxMLCBhbHdheXNTdGF0OiB0cnVlLCBsc3RhdDogdHJ1ZSwgLi4ub3B0c307XG4gIGxldCBzdHJlYW0gPSByZWFkZGlycChyb290LCBvcHRpb25zKTtcbiAgdGhpcy5fc3RyZWFtcy5hZGQoc3RyZWFtKTtcbiAgc3RyZWFtLm9uY2UoU1RSX0NMT1NFLCAoKSA9PiB7XG4gICAgc3RyZWFtID0gdW5kZWZpbmVkO1xuICB9KTtcbiAgc3RyZWFtLm9uY2UoU1RSX0VORCwgKCkgPT4ge1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3N0cmVhbXMuZGVsZXRlKHN0cmVhbSk7XG4gICAgICBzdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxufVxuXG4vLyBFeHBvcnQgRlNXYXRjaGVyIGNsYXNzXG5leHBvcnRzLkZTV2F0Y2hlciA9IEZTV2F0Y2hlcjtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgd2F0Y2hlciB3aXRoIHBhdGhzIHRvIGJlIHRyYWNrZWQuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheTxTdHJpbmc+fSBwYXRocyBmaWxlL2RpcmVjdG9yeSBwYXRocyBhbmQvb3IgZ2xvYnNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBjaG9raWRhciBvcHRzXG4gKiBAcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBGU1dhdGNoZXIgZm9yIGNoYWluaW5nLlxuICovXG5jb25zdCB3YXRjaCA9IChwYXRocywgb3B0aW9ucykgPT4ge1xuICBjb25zdCB3YXRjaGVyID0gbmV3IEZTV2F0Y2hlcihvcHRpb25zKTtcbiAgd2F0Y2hlci5hZGQocGF0aHMpO1xuICByZXR1cm4gd2F0Y2hlcjtcbn07XG5cbmV4cG9ydHMud2F0Y2ggPSB3YXRjaDtcbiIsICJpbXBvcnQge0FwcCwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCAqIGFzIGNob2tpZGFyIGZyb20gJ2Nob2tpZGFyJztcclxuXHJcbmludGVyZmFjZSBGaWxlV2F0Y2hlclNldHRpbmdzIHtcclxuICBmb2xsb3dTeW1saW5rczogYm9vbGVhbjtcclxuICBkaXNhYmxlR2xvYmJpbmc6IGJvb2xlYW47XHJcbiAgdXNlUG9sbGluZzogYm9vbGVhbjtcclxuICBpbnRlcnZhbDogbnVtYmVyO1xyXG4gIGJpbmFyeUludGVydmFsOiBudW1iZXI7XHJcbiAgYXdhaXRXcml0ZUZpbmlzaDogYm9vbGVhbjtcclxuICBhd2FpdFdyaXRlRmluaXNoX3N0YWJpbGl0eVRocmVzaG9sZDogbnVtYmVyO1xyXG4gIGF3YWl0V3JpdGVGaW5pc2hfcG9sbEludGVydmFsOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IEZpbGVXYXRjaGVyU2V0dGluZ3MgPSB7XHJcblx0Zm9sbG93U3ltbGlua3M6IHRydWUsXHJcbiAgZGlzYWJsZUdsb2JiaW5nOiBmYWxzZSxcclxuICB1c2VQb2xsaW5nOiB0cnVlLFxyXG4gIGludGVydmFsOiAxMDAsXHJcbiAgYmluYXJ5SW50ZXJ2YWw6IDMwMCxcclxuICBhd2FpdFdyaXRlRmluaXNoOiB0cnVlLFxyXG4gIGF3YWl0V3JpdGVGaW5pc2hfc3RhYmlsaXR5VGhyZXNob2xkOiAyMDAwLFxyXG4gIGF3YWl0V3JpdGVGaW5pc2hfcG9sbEludGVydmFsOiAxMDAsXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVXYXRjaGVyUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuICBzZXR0aW5nczogRmlsZVdhdGNoZXJTZXR0aW5ncztcclxuICByb290X3BhdGg6IHN0cmluZyA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuYmFzZVBhdGg7XHJcbiAgbGFzdF9tb2RpZmllZDogTWFwPFN0cmluZywgYW55PiA9IG5ldyBNYXAoKTtcclxuICB3YXRjaGVyOiBjaG9raWRhci5GU1dhdGNoZXI7XHJcbiAgYXN5bmMgb25sb2FkKCkge1xyXG4gICAgY29uc29sZS5sb2coJ0xvYWRpbmcgZmlsZSB3YXRjaGVyIHBsdWdpbicpO1xyXG5cclxuICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IEZpbGVXYXRjaGVyU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgQ2hva2lkYXIgd2F0Y2hlclxyXG4gICAgdGhpcy53YXRjaGVyID0gdGhpcy5jcmVhdGVfd2F0Y2hlcigpO1xyXG5cclxuICAgIC8vIFN0b3Agd2F0Y2hpbmcgd2hlbiB0aGUgcGx1Z2luIGlzIHVubG9hZGVkXHJcbiAgICB0aGlzLnJlZ2lzdGVyKCgpID0+IHtcclxuICAgICAgdGhpcy53YXRjaGVyLmNsb3NlKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnV2F0Y2hlciBjbG9zZWQnKSk7XHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKCdmaWxlIHdhdGNoZXIgcGx1Z2luIGxvYWRlZCEnKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZV93YXRjaGVyKCk6IGNob2tpZGFyLkZTV2F0Y2hlciB7XHJcbiAgICBjb25zdCB3YXRjaGVyID0gY2hva2lkYXIud2F0Y2godGhpcy5yb290X3BhdGgsIHtcclxuICAgICAgaWdub3JlZDogLyhefFtcXC9cXFxcXSlcXC4uLywgLy8gaWdub3JlIGRvdGZpbGVzXHJcbiAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXHJcbiAgICAgIGlnbm9yZUluaXRpYWw6IHRydWUsXHJcbiAgICAgIC8vIHVzZVBvbGxpbmc6IHRydWUsXHJcbiAgICAgIC8vIGF3YWl0V3JpdGVGaW5pc2g6IHRydWUsXHJcbiAgICAgIGN3ZDogdGhpcy5yb290X3BhdGgsXHJcbiAgICAgIC8vIGNvbmZpZ1xyXG4gICAgICBmb2xsb3dTeW1saW5rczogdGhpcy5zZXR0aW5ncy5mb2xsb3dTeW1saW5rcyxcclxuICAgICAgZGlzYWJsZUdsb2JiaW5nOiB0aGlzLnNldHRpbmdzLmRpc2FibGVHbG9iYmluZyxcclxuICAgICAgdXNlUG9sbGluZzogdGhpcy5zZXR0aW5ncy51c2VQb2xsaW5nLFxyXG4gICAgICBpbnRlcnZhbDogdGhpcy5zZXR0aW5ncy5pbnRlcnZhbCxcclxuICAgICAgYmluYXJ5SW50ZXJ2YWw6IHRoaXMuc2V0dGluZ3MuYmluYXJ5SW50ZXJ2YWwsXHJcbiAgICAgIGF3YWl0V3JpdGVGaW5pc2g6IHRoaXMuc2V0dGluZ3MuYXdhaXRXcml0ZUZpbmlzaD97XHJcbiAgICAgICAgc3RhYmlsaXR5VGhyZXNob2xkOiB0aGlzLnNldHRpbmdzLmF3YWl0V3JpdGVGaW5pc2hfc3RhYmlsaXR5VGhyZXNob2xkLFxyXG4gICAgICAgIHBvbGxJbnRlcnZhbDogdGhpcy5zZXR0aW5ncy5hd2FpdFdyaXRlRmluaXNoX3BvbGxJbnRlcnZhbCxcclxuICAgICAgfTpmYWxzZSxcclxuXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICB3YXRjaGVyXHJcbiAgICAgIC5vbignYWRkJywgKHBhdGg6YW55ICwgc3RhdHM6YW55ICkgPT4gdGhpcy5maWxlX21vZGlmaWVkKCdhZGQnLCBwYXRoLCBzdGF0cykpXHJcbiAgICAgIC5vbignY2hhbmdlJywgKHBhdGg6YW55LCBzdGF0czphbnkpID0+IHRoaXMuZmlsZV9tb2RpZmllZCgnY2hhbmdlJywgcGF0aCwgc3RhdHMpKVxyXG4gICAgICAub24oJ3VubGluaycsIChwYXRoOmFueSwgc3RhdHM6YW55KSA9PiB0aGlzLmZpbGVfbW9kaWZpZWQoJ3VubGluaycsIHBhdGgsIHN0YXRzKSk7XHJcbiAgICBcclxuICAgICAgcmV0dXJuIHdhdGNoZXI7XHJcbiAgfVxyXG5cclxuICBvbnVubG9hZCgpIHtcclxuICAgIGNvbnNvbGUubG9nKCdVbmxvYWRpbmcgZmlsZSB3YXRjaGVyIHBsdWdpbicpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG4gICAgY29uc3QgbmV3X3dhdGNoZXIgPSB0aGlzLmNyZWF0ZV93YXRjaGVyKClcclxuICAgIHRoaXMud2F0Y2hlci5jbG9zZSgpLnRoZW4oKCkgPT4gdGhpcy53YXRjaGVyID0gbmV3X3dhdGNoZXIpO1xyXG5cdH1cclxuXHJcbiAgYXN5bmMgZmlsZV9tb2RpZmllZChldmVudDpzdHJpbmcsIHBhdGg6IHN0cmluZywgc3RhdHM6IGFueSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHRoaXMubGFzdF9tb2RpZmllZC5nZXQocGF0aCkgIT0gc3RhdHMubXRpbWUpIHtcclxuICAgICAgICB0aGlzLmxhc3RfbW9kaWZpZWQuc2V0KHBhdGgsIHN0YXRzLm10aW1lKTtcclxuICAgICAgICBjb25zdCBiYXNlX3dhdGNoZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLndhdGNoZXJzWycvJ107XHJcbiAgICAgICAgaWYgKGJhc2Vfd2F0Y2hlcikge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYmFzZV93YXRjaGVyLndhdGNoZXJbJ19oYW5kbGUnXS5vbmNoYW5nZSgwLCBldmVudCwgcGF0aClcclxuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2goZXJyb3IpIHtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEZpbGVXYXRjaGVyU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG5cdHBsdWdpbjogRmlsZVdhdGNoZXJQbHVnaW47XHJcbiAgdXBkYXRlX2ludGVydmFsX3ZhbHVlOiAodmFsdWU6IG51bWJlcikgPT4gdm9pZDtcclxuICB1cGRhdGVfYmluYXJ5SW50ZXJ2YWxfdmFsdWU6ICh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkO1xyXG4gIHVwZGF0ZV9hd2FpdFdyaXRlRmluaXNoX3N0YWJpbGl0eVRocmVzaG9sZF92YWx1ZTogKHZhbHVlOiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgdXBkYXRlX2F3YWl0V3JpdGVGaW5pc2hfcG9sbEludGVydmFsX3ZhbHVlOiAodmFsdWU6IG51bWJlcikgPT4gdm9pZDtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRmlsZVdhdGNoZXJQbHVnaW4pIHtcclxuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG5cdH1cclxuXHJcblx0ZGlzcGxheSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdDaG9raWRhciBTZXR0aW5ncyd9KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoJ2ZvbGxvd1N5bWxpbmtzJylcclxuXHRcdFx0LnNldERlc2MoJ2ZvbGxvd1N5bWxpbmtzJylcclxuICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGxvd1N5bWxpbmtzKVxyXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyB2YWx1ZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xsb3dTeW1saW5rcyA9IHZhbHVlO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIFxyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKCdkaXNhYmxlR2xvYmJpbmcnKVxyXG4gICAgICAuc2V0RGVzYygnZGlzYWJsZUdsb2JiaW5nJylcclxuICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmRpc2FibGVHbG9iYmluZylcclxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgdmFsdWUgPT4ge1xyXG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGlzYWJsZUdsb2JiaW5nID0gdmFsdWU7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoJ3VzZVBvbGxpbmcnKVxyXG4gICAgICAuc2V0RGVzYygndXNlUG9sbGluZycpXHJcbiAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VQb2xsaW5nKVxyXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyB2YWx1ZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VQb2xsaW5nID0gdmFsdWU7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoJ2ludGVydmFsJylcclxuICAgICAgLnNldERlc2MoJ3BvbGxpbmcgaW50ZXJ2YWwgZm9yIG5vbiBiaW5hcnkgZmlsZXMnKVxyXG4gICAgICAuYWRkU2xpZGVyKHNsaWRlciA9PiBzbGlkZXJcclxuICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW50ZXJ2YWwpXHJcbiAgICAgICAgLnNldExpbWl0cygxMDAsIDYwMDAwLCAxMDApXHJcbiAgICAgICAgLm9uQ2hhbmdlKGFzeW5jIHZhbHVlID0+IHtcclxuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmludGVydmFsID0gdmFsdWU7XHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZV9pbnRlcnZhbF92YWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgbGV0IGludGVydmFsX3ZhbHVlID0gY29udGFpbmVyRWwuY3JlYXRlU3BhbihgVmFsdWU6ICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuaW50ZXJ2YWx9YCk7XHJcbiAgICB0aGlzLnVwZGF0ZV9pbnRlcnZhbF92YWx1ZSA9ICh2YWx1ZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGludGVydmFsX3ZhbHVlLnNldFRleHQoYFZhbHVlOiAke3ZhbHVlfWApO1xyXG4gICAgfVxyXG4gICAgdGhpcy51cGRhdGVfaW50ZXJ2YWxfdmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW50ZXJ2YWwpO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZSgnYmluYXJ5SW50ZXJ2YWwnKVxyXG4gICAgICAuc2V0RGVzYygncG9sbGluZyBpbnRlcnZhbCBmb3IgYmluYXJ5IGZpbGVzJylcclxuICAgICAgLmFkZFNsaWRlcihzbGlkZXIgPT4gc2xpZGVyXHJcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJpbmFyeUludGVydmFsKVxyXG4gICAgICAgIC5zZXRMaW1pdHMoMTAwLCA2MDAwMCwgMTAwKVxyXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyB2YWx1ZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iaW5hcnlJbnRlcnZhbCA9IHZhbHVlO1xyXG4gICAgICAgICAgdGhpcy51cGRhdGVfYmluYXJ5SW50ZXJ2YWxfdmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIGxldCBiaW5hcnlJbnRlcnZhbF92YWx1ZSA9IGNvbnRhaW5lckVsLmNyZWF0ZVNwYW4oYFZhbHVlOiAke3RoaXMucGx1Z2luLnNldHRpbmdzLmJpbmFyeUludGVydmFsfWApO1xyXG4gICAgdGhpcy51cGRhdGVfYmluYXJ5SW50ZXJ2YWxfdmFsdWUgPSAodmFsdWU6IG51bWJlcikgPT4ge1xyXG4gICAgICBiaW5hcnlJbnRlcnZhbF92YWx1ZS5zZXRUZXh0KGBWYWx1ZTogJHt2YWx1ZX1gKTtcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlX2JpbmFyeUludGVydmFsX3ZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJpbmFyeUludGVydmFsKTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoJ2F3YWl0V3JpdGVGaW5pc2gnKVxyXG4gICAgICAuc2V0RGVzYygnYXdhaXRXcml0ZUZpbmlzaCcpXHJcbiAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hd2FpdFdyaXRlRmluaXNoKVxyXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyB2YWx1ZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hd2FpdFdyaXRlRmluaXNoID0gdmFsdWU7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZSgnYXdhaXRXcml0ZUZpbmlzaF9zdGFiaWxpdHlUaHJlc2hvbGQnKVxyXG4gICAgICAuc2V0RGVzYygnc3RhYmlsaXR5VGhyZXNob2xkIGZvciBhd2FpdFdyaXRlRmluaXNoJylcclxuICAgICAgLmFkZFNsaWRlcihzbGlkZXIgPT4gc2xpZGVyXHJcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmF3YWl0V3JpdGVGaW5pc2hfc3RhYmlsaXR5VGhyZXNob2xkKVxyXG4gICAgICAgIC5zZXRMaW1pdHMoMTAwLCAxMDAwMDAsIDEwMClcclxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgdmFsdWUgPT4ge1xyXG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYXdhaXRXcml0ZUZpbmlzaF9zdGFiaWxpdHlUaHJlc2hvbGQgPSB2YWx1ZTtcclxuICAgICAgICAgIHRoaXMudXBkYXRlX2F3YWl0V3JpdGVGaW5pc2hfc3RhYmlsaXR5VGhyZXNob2xkX3ZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICBsZXQgYXdhaXRXcml0ZUZpbmlzaF9zdGFiaWxpdHlUaHJlc2hvbGRfdmFsdWUgPSBjb250YWluZXJFbC5jcmVhdGVTcGFuKGBWYWx1ZTogJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5hd2FpdFdyaXRlRmluaXNoX3N0YWJpbGl0eVRocmVzaG9sZH1gKTtcclxuICAgIHRoaXMudXBkYXRlX2F3YWl0V3JpdGVGaW5pc2hfc3RhYmlsaXR5VGhyZXNob2xkX3ZhbHVlID0gKHZhbHVlOiBudW1iZXIpID0+IHtcclxuICAgICAgYXdhaXRXcml0ZUZpbmlzaF9zdGFiaWxpdHlUaHJlc2hvbGRfdmFsdWUuc2V0VGV4dChgVmFsdWU6ICR7dmFsdWV9YCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZV9hd2FpdFdyaXRlRmluaXNoX3N0YWJpbGl0eVRocmVzaG9sZF92YWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hd2FpdFdyaXRlRmluaXNoX3N0YWJpbGl0eVRocmVzaG9sZCk7XHJcbiAgICBcclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZSgnYXdhaXRXcml0ZUZpbmlzaF9wb2xsSW50ZXJ2YWwnKVxyXG4gICAgICAuc2V0RGVzYygncG9sbGluZyBpbnRlcnZhbCBmb3IgYXdhaXRXcml0ZUZpbmlzaCcpXHJcbiAgICAgIC5hZGRTbGlkZXIoc2xpZGVyID0+IHNsaWRlclxyXG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hd2FpdFdyaXRlRmluaXNoX3BvbGxJbnRlcnZhbClcclxuICAgICAgICAuc2V0TGltaXRzKDEwMCwgNTAwMCwgMTAwKVxyXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyB2YWx1ZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hd2FpdFdyaXRlRmluaXNoX3BvbGxJbnRlcnZhbCA9IHZhbHVlO1xyXG4gICAgICAgICAgdGhpcy51cGRhdGVfYXdhaXRXcml0ZUZpbmlzaF9wb2xsSW50ZXJ2YWxfdmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIGxldCBhd2FpdFdyaXRlRmluaXNoX3BvbGxJbnRlcnZhbF92YWx1ZSA9IGNvbnRhaW5lckVsLmNyZWF0ZVNwYW4oYFZhbHVlOiAke3RoaXMucGx1Z2luLnNldHRpbmdzLmF3YWl0V3JpdGVGaW5pc2hfcG9sbEludGVydmFsfWApO1xyXG4gICAgdGhpcy51cGRhdGVfYXdhaXRXcml0ZUZpbmlzaF9wb2xsSW50ZXJ2YWxfdmFsdWUgPSAodmFsdWU6IG51bWJlcikgPT4ge1xyXG4gICAgICBhd2FpdFdyaXRlRmluaXNoX3BvbGxJbnRlcnZhbF92YWx1ZS5zZXRUZXh0KGBWYWx1ZTogJHt2YWx1ZX1gKTtcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlX2F3YWl0V3JpdGVGaW5pc2hfcG9sbEludGVydmFsX3ZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmF3YWl0V3JpdGVGaW5pc2hfcG9sbEludGVydmFsKTtcclxuXHR9XHJcbn1cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEscURBQUFBLFNBQUE7QUFBQTtBQUVBLFFBQU0sT0FBTyxRQUFRLE1BQU07QUFDM0IsUUFBTSxZQUFZO0FBQ2xCLFFBQU0sZUFBZSxLQUFLO0FBTTFCLFFB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TUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEs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QUFLO0FBQ3JELGNBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxNQUNqQyxDQUFDO0FBQUEsSUFDSDtBQUNGLFFBQUksc0NBQXNDLFlBQVksV0FBVyxVQUFVLEtBQUssT0FBTyxTQUFTLCtCQUErQjtBQUMvSCxTQUFLLDZDQUE2QyxDQUFDLFVBQWtCO0FBQ25FLDBDQUFvQyxRQUFRLFVBQVUsT0FBTztBQUFBLElBQy9EO0FBQ0EsU0FBSywyQ0FBMkMsS0FBSyxPQUFPLFNBQVMsNkJBQTZCO0FBQUEsRUFDckc7QUFDRDsiLAogICJuYW1lcyI6IFsibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAib3B0cyIsICJ2YWx1ZSIsICJyZXN0IiwgInNvdXJjZSIsICJtb2R1bGUiLCAic3RhdGUiLCAicmVxdWlyZV9waWNvbWF0Y2giLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgInRlc3RTdHJpbmciLCAicmV0dXJuSW5kZXgiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAicmVxdWlyZV91dGlscyIsICJub2RlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1heCIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJyZXF1aXJlX2NvbnN0YW50cyIsICJtb2R1bGUiLCAicmVxdWlyZV9wYXJzZSIsICJtb2R1bGUiLCAiaW5kZXgiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJyZXF1aXJlX2JpbmFyeV9leHRlbnNpb25zIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAicmVxdWlyZV9jb25zdGFudHMiLCAibW9kdWxlIiwgInJhd0VtaXR0ZXIiLCAibGlzdGVuZXIiLCAibmV3U3RhdHMiLCAic3RhdHMiLCAibW9kdWxlIiwgInBhdGgiLCAibm93IiwgInN0YXQiLCAid2F0Y2giXQp9Cg==
